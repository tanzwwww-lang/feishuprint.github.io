(() => { // webpackBootstrap
"use strict";
var __webpack_modules__ = ({
"./lib/globals/tinymce/core/api/Env.js": 
/*!*********************************************!*\
  !*** ./lib/globals/tinymce/core/api/Env.js ***!
  \*********************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Env: () => (Env),
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
var global = tinymce.util.Tools.resolve('tinymce.Env');

/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = (global);
var Env = global;


}),
"./lib/globals/tinymce/core/api/PluginManager.js": 
/*!*******************************************************!*\
  !*** ./lib/globals/tinymce/core/api/PluginManager.js ***!
  \*******************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  PluginManager: () => (PluginManager),
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
var global = tinymce.util.Tools.resolve('tinymce.PluginManager');

/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = (global);
var PluginManager = global;


}),
"./lib/globals/tinymce/core/api/html/Node.js": 
/*!***************************************************!*\
  !*** ./lib/globals/tinymce/core/api/html/Node.js ***!
  \***************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Node: () => (Node),
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
var global = tinymce.util.Tools.resolve('tinymce.html.Node');

/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = (global);
var Node = global;


}),
"./lib/globals/tinymce/core/api/util/Tools.js": 
/*!****************************************************!*\
  !*** ./lib/globals/tinymce/core/api/util/Tools.js ***!
  \****************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Tools: () => (Tools),
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
var global = tinymce.util.Tools.resolve('tinymce.util.Tools');

/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = (global);
var Tools = global;


}),
"./lib/globals/tinymce/core/api/util/VK.js": 
/*!*************************************************!*\
  !*** ./lib/globals/tinymce/core/api/util/VK.js ***!
  \*************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  VK: () => (VK),
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
var global = tinymce.util.Tools.resolve('tinymce.util.VK');

/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = (global);
var VK = global;


}),
"../boss/src/main/ts/ephox/boss/api/DomUniverse.ts": 
/*!*********************************************************!*\
  !*** ../boss/src/main/ts/ephox/boss/api/DomUniverse.ts ***!
  \*********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/search/Traverse.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/properties/Attribute.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/search/SelectorFind.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/search/PredicateFind.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/search/SelectorFilter.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/search/PredicateFilter.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/properties/Css.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/dom/Insert.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/dom/InsertAll.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/dom/Remove.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarText.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/dom/Compare.ts");
/* ESM import */var _common_TagBoundaries__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../common/TagBoundaries */ "../boss/src/main/ts/ephox/boss/common/TagBoundaries.ts");



/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = (()=>{
    const clone = (element)=>{
        return _ephox_sugar__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom(element.dom.cloneNode(false));
    };
    const document = (element)=>_ephox_sugar__WEBPACK_IMPORTED_MODULE_1__.documentOrOwner(element).dom;
    const isBoundary = (element)=>{
        if (!_ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.isElement(element)) {
            return false;
        }
        if (_ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.name(element) === 'body') {
            return true;
        }
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.contains(_common_TagBoundaries__WEBPACK_IMPORTED_MODULE_4__["default"], _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.name(element));
    };
    const isEmptyTag = (element)=>{
        if (!_ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.isElement(element)) {
            return false;
        }
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.contains([
            'br',
            'img',
            'hr',
            'input'
        ], _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.name(element));
    };
    const isNonEditable = (element)=>_ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.isElement(element) && _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__.get(element, 'contenteditable') === 'false';
    const comparePosition = (element, other)=>{
        return element.dom.compareDocumentPosition(other.dom);
    };
    const copyAttributesTo = (source, destination)=>{
        const as = _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__.clone(source);
        _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__.setAll(destination, as);
    };
    const isSpecial = (element)=>{
        const tag = _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.name(element);
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.contains([
            'script',
            'noscript',
            'iframe',
            'noframes',
            'noembed',
            'title',
            'style',
            'textarea',
            'xmp'
        ], tag);
    };
    const getLanguage = (element)=>_ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.isElement(element) ? _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__.getOpt(element, 'lang') : _ephox_katamari__WEBPACK_IMPORTED_MODULE_6__.Optional.none();
    return {
        up: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            selector: _ephox_sugar__WEBPACK_IMPORTED_MODULE_8__.ancestor,
            closest: _ephox_sugar__WEBPACK_IMPORTED_MODULE_8__.closest,
            predicate: _ephox_sugar__WEBPACK_IMPORTED_MODULE_9__.ancestor,
            all: _ephox_sugar__WEBPACK_IMPORTED_MODULE_1__.parents
        }),
        down: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            selector: _ephox_sugar__WEBPACK_IMPORTED_MODULE_10__.descendants,
            predicate: _ephox_sugar__WEBPACK_IMPORTED_MODULE_11__.descendants
        }),
        styles: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            get: _ephox_sugar__WEBPACK_IMPORTED_MODULE_12__.get,
            getRaw: _ephox_sugar__WEBPACK_IMPORTED_MODULE_12__.getRaw,
            set: _ephox_sugar__WEBPACK_IMPORTED_MODULE_12__.set,
            remove: _ephox_sugar__WEBPACK_IMPORTED_MODULE_12__.remove
        }),
        attrs: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            get: _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__.get,
            set: _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__.set,
            remove: _ephox_sugar__WEBPACK_IMPORTED_MODULE_5__.remove,
            copyTo: copyAttributesTo
        }),
        insert: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            before: _ephox_sugar__WEBPACK_IMPORTED_MODULE_13__.before,
            after: _ephox_sugar__WEBPACK_IMPORTED_MODULE_13__.after,
            afterAll: _ephox_sugar__WEBPACK_IMPORTED_MODULE_14__.after,
            append: _ephox_sugar__WEBPACK_IMPORTED_MODULE_13__.append,
            appendAll: _ephox_sugar__WEBPACK_IMPORTED_MODULE_14__.append,
            prepend: _ephox_sugar__WEBPACK_IMPORTED_MODULE_13__.prepend,
            wrap: _ephox_sugar__WEBPACK_IMPORTED_MODULE_13__.wrap
        }),
        remove: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            unwrap: _ephox_sugar__WEBPACK_IMPORTED_MODULE_15__.unwrap,
            remove: _ephox_sugar__WEBPACK_IMPORTED_MODULE_15__.remove
        }),
        create: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            nu: _ephox_sugar__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromTag,
            clone,
            text: _ephox_sugar__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromText
        }),
        query: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            comparePosition,
            prevSibling: _ephox_sugar__WEBPACK_IMPORTED_MODULE_1__.prevSibling,
            nextSibling: _ephox_sugar__WEBPACK_IMPORTED_MODULE_1__.nextSibling
        }),
        property: _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.constant({
            children: _ephox_sugar__WEBPACK_IMPORTED_MODULE_1__.children,
            name: _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.name,
            parent: _ephox_sugar__WEBPACK_IMPORTED_MODULE_1__.parent,
            document,
            isText: _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.isText,
            isComment: _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.isComment,
            isElement: _ephox_sugar__WEBPACK_IMPORTED_MODULE_2__.isElement,
            isSpecial,
            getLanguage,
            getText: _ephox_sugar__WEBPACK_IMPORTED_MODULE_16__.get,
            setText: _ephox_sugar__WEBPACK_IMPORTED_MODULE_16__.set,
            isBoundary,
            isEmptyTag,
            isNonEditable
        }),
        eq: _ephox_sugar__WEBPACK_IMPORTED_MODULE_17__.eq,
        is: _ephox_sugar__WEBPACK_IMPORTED_MODULE_17__.is
    };
});


}),
"../boss/src/main/ts/ephox/boss/common/TagBoundaries.ts": 
/*!**************************************************************!*\
  !*** ../boss/src/main/ts/ephox/boss/common/TagBoundaries.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([
    'body',
    'p',
    'div',
    'article',
    'aside',
    'figcaption',
    'figure',
    'footer',
    'header',
    'nav',
    'section',
    'ol',
    'ul',
    'li',
    'table',
    'thead',
    'tbody',
    'tfoot',
    'caption',
    'tr',
    'td',
    'th',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'blockquote',
    'pre',
    'address'
]);


}),
"../katamari/src/main/ts/ephox/katamari/api/Arr.ts": 
/*!*********************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Arr.ts ***!
  \*********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  bind: () => (bind),
  chunk: () => (chunk),
  contains: () => (contains),
  difference: () => (difference),
  each: () => (each),
  eachr: () => (eachr),
  equal: () => (equal),
  exists: () => (exists),
  filter: () => (filter),
  find: () => (find),
  findIndex: () => (findIndex),
  findLastIndex: () => (findLastIndex),
  findMap: () => (findMap),
  findUntil: () => (findUntil),
  flatten: () => (flatten),
  foldl: () => (foldl),
  foldr: () => (foldr),
  forall: () => (forall),
  from: () => (from),
  get: () => (get),
  groupBy: () => (groupBy),
  head: () => (head),
  indexOf: () => (indexOf),
  last: () => (last),
  map: () => (map),
  mapToObject: () => (mapToObject),
  partition: () => (partition),
  pure: () => (pure),
  range: () => (range),
  reverse: () => (reverse),
  sort: () => (sort),
  unique: () => (unique)
});
/* ESM import */var _ephox_dispute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ephox/dispute */ "../../node_modules/@ephox/dispute/lib/main/ts/api/Eq.js");
/* ESM import */var _Fun__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fun */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _Optional__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Optional */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _Type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Type */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");




const nativeSlice = Array.prototype.slice;
const nativeIndexOf = Array.prototype.indexOf;
const nativePush = Array.prototype.push;
const rawIndexOf = (ts, t)=>nativeIndexOf.call(ts, t);
const indexOf = (xs, x)=>{
    // The rawIndexOf method does not wrap up in an option. This is for performance reasons.
    const r = rawIndexOf(xs, x);
    return r === -1 ? _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.none() : _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.some(r);
};
const contains = (xs, x)=>rawIndexOf(xs, x) > -1;
const exists = (xs, pred)=>{
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        if (pred(x, i)) {
            return true;
        }
    }
    return false;
};
const range = (num, f)=>{
    const r = [];
    for(let i = 0; i < num; i++){
        r.push(f(i));
    }
    return r;
};
// It's a total micro optimisation, but these do make some difference.
// Particularly for browsers other than Chrome.
// - length caching
// http://jsperf.com/browser-diet-jquery-each-vs-for-loop/69
// - not using push
// http://jsperf.com/array-direct-assignment-vs-push/2
const chunk = (array, size)=>{
    const r = [];
    for(let i = 0; i < array.length; i += size){
        const s = nativeSlice.call(array, i, i + size);
        r.push(s);
    }
    return r;
};
const map = (xs, f)=>{
    // pre-allocating array size when it's guaranteed to be known
    // http://jsperf.com/push-allocated-vs-dynamic/22
    const len = xs.length;
    const r = new Array(len);
    for(let i = 0; i < len; i++){
        const x = xs[i];
        r[i] = f(x, i);
    }
    return r;
};
// Unwound implementing other functions in terms of each.
// The code size is roughly the same, and it should allow for better optimisation.
// const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {
const each = (xs, f)=>{
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        f(x, i);
    }
};
const eachr = (xs, f)=>{
    for(let i = xs.length - 1; i >= 0; i--){
        const x = xs[i];
        f(x, i);
    }
};
const partition = (xs, pred)=>{
    const pass = [];
    const fail = [];
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        const arr = pred(x, i) ? pass : fail;
        arr.push(x);
    }
    return {
        pass,
        fail
    };
};
const filter = (xs, pred)=>{
    const r = [];
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        if (pred(x, i)) {
            r.push(x);
        }
    }
    return r;
};
/*
 * Groups an array into contiguous arrays of like elements. Whether an element is like or not depends on f.
 *
 * f is a function that derives a value from an element - e.g. true or false, or a string.
 * Elements are like if this function generates the same value for them (according to ===).
 *
 *
 * Order of the elements is preserved. Arr.flatten() on the result will return the original list, as with Haskell groupBy function.
 *  For a good explanation, see the group function (which is a special case of groupBy)
 *  http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:group
 */ const groupBy = (xs, f)=>{
    if (xs.length === 0) {
        return [];
    } else {
        let wasType = f(xs[0]); // initial case for matching
        const r = [];
        let group = [];
        for(let i = 0, len = xs.length; i < len; i++){
            const x = xs[i];
            const type = f(x);
            if (type !== wasType) {
                r.push(group);
                group = [];
            }
            wasType = type;
            group.push(x);
        }
        if (group.length !== 0) {
            r.push(group);
        }
        return r;
    }
};
const foldr = (xs, f, acc)=>{
    eachr(xs, (x, i)=>{
        acc = f(acc, x, i);
    });
    return acc;
};
const foldl = (xs, f, acc)=>{
    each(xs, (x, i)=>{
        acc = f(acc, x, i);
    });
    return acc;
};
const findUntil = (xs, pred, until)=>{
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        if (pred(x, i)) {
            return _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.some(x);
        } else if (until(x, i)) {
            break;
        }
    }
    return _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.none();
};
const find = (xs, pred)=>{
    return findUntil(xs, pred, _Fun__WEBPACK_IMPORTED_MODULE_1__.never);
};
const findIndex = (xs, pred)=>{
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        if (pred(x, i)) {
            return _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.some(i);
        }
    }
    return _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.none();
};
const findLastIndex = (arr, pred)=>{
    for(let i = arr.length - 1; i >= 0; i--){
        if (pred(arr[i], i)) {
            return _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.some(i);
        }
    }
    return _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.none();
};
const flatten = (xs)=>{
    // Note, this is possible because push supports multiple arguments:
    // http://jsperf.com/concat-push/6
    // Note that in the past, concat() would silently work (very slowly) for array-like objects.
    // With this change it will throw an error.
    const r = [];
    for(let i = 0, len = xs.length; i < len; ++i){
        // Ensure that each value is an array itself
        if (!_Type__WEBPACK_IMPORTED_MODULE_2__.isArray(xs[i])) {
            throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);
        }
        nativePush.apply(r, xs[i]);
    }
    return r;
};
const bind = (xs, f)=>flatten(map(xs, f));
const forall = (xs, pred)=>{
    for(let i = 0, len = xs.length; i < len; ++i){
        const x = xs[i];
        if (pred(x, i) !== true) {
            return false;
        }
    }
    return true;
};
const equal = (a1, a2, eq = _ephox_dispute__WEBPACK_IMPORTED_MODULE_3__.eqAny)=>_ephox_dispute__WEBPACK_IMPORTED_MODULE_3__.eqArray(eq).eq(a1, a2);
const reverse = (xs)=>{
    const r = nativeSlice.call(xs, 0);
    r.reverse();
    return r;
};
const difference = (a1, a2)=>filter(a1, (x)=>!contains(a2, x));
const mapToObject = (xs, f)=>{
    const r = {};
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        r[String(x)] = f(x, i);
    }
    return r;
};
const pure = (x)=>[
        x
    ];
const sort = (xs, comparator)=>{
    const copy = nativeSlice.call(xs, 0);
    copy.sort(comparator);
    return copy;
};
const get = (xs, i)=>i >= 0 && i < xs.length ? _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.some(xs[i]) : _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.none();
const head = (xs)=>get(xs, 0);
const last = (xs)=>get(xs, xs.length - 1);
const from = _Type__WEBPACK_IMPORTED_MODULE_2__.isFunction(Array.from) ? Array.from : (x)=>nativeSlice.call(x);
const findMap = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        const r = f(arr[i], i);
        if (r.isSome()) {
            return r;
        }
    }
    return _Optional__WEBPACK_IMPORTED_MODULE_0__.Optional.none();
};
const unique = (xs, comparator)=>{
    const r = [];
    const isDuplicated = _Type__WEBPACK_IMPORTED_MODULE_2__.isFunction(comparator) ? (x)=>exists(r, (i)=>comparator(i, x)) : (x)=>contains(r, x);
    for(let i = 0, len = xs.length; i < len; i++){
        const x = xs[i];
        if (!isDuplicated(x)) {
            r.push(x);
        }
    }
    return r;
};


}),
"../katamari/src/main/ts/ephox/katamari/api/Fun.ts": 
/*!*********************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Fun.ts ***!
  \*********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  always: () => (always),
  apply: () => (apply),
  call: () => (call),
  compose: () => (compose),
  compose1: () => (compose1),
  constant: () => (constant),
  curry: () => (curry),
  die: () => (die),
  identity: () => (identity),
  never: () => (never),
  noarg: () => (noarg),
  noop: () => (noop),
  not: () => (not),
  pipe: () => (pipe),
  tripleEquals: () => (tripleEquals),
  weaken: () => (weaken)
});
/* ESM import */var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");

const noop = ()=>{};
const noarg = (f)=>()=>f();
/** Compose a unary function with an n-ary function */ const compose = (fa, fb)=>{
    return (...args)=>{
        return fa(fb.apply(null, args));
    };
};
/** Compose two unary functions. Similar to compose, but avoids using Function.prototype.apply. */ const compose1 = (fbc, fab)=>(a)=>fbc(fab(a));
const constant = (value)=>{
    return ()=>{
        return value;
    };
};
const identity = (x)=>{
    return x;
};
const tripleEquals = (a, b)=>{
    return a === b;
};
function curry(fn, ...initialArgs) {
    return (...restArgs)=>{
        const all = initialArgs.concat(restArgs);
        return fn.apply(null, all);
    };
}
const not = (f)=>(t)=>!f(t);
const die = (msg)=>{
    return ()=>{
        throw new Error(msg);
    };
};
const apply = (f)=>{
    return f();
};
const call = (f)=>{
    f();
};
const never = constant(false);
const always = constant(true);
/* Used to weaken types */ const weaken = (b)=>b;
const pipe = (a, ab, bc, cd, de, ef, fg, gh)=>{
    const b = ab(a);
    if (_Type__WEBPACK_IMPORTED_MODULE_0__.isNullable(bc)) {
        return b;
    }
    const c = bc(b);
    if (_Type__WEBPACK_IMPORTED_MODULE_0__.isNullable(cd)) {
        return c;
    }
    const d = cd(c);
    if (_Type__WEBPACK_IMPORTED_MODULE_0__.isNullable(de)) {
        return d;
    }
    const e = de(d);
    if (_Type__WEBPACK_IMPORTED_MODULE_0__.isNullable(ef)) {
        return e;
    }
    const f = ef(e);
    if (_Type__WEBPACK_IMPORTED_MODULE_0__.isNullable(fg)) {
        return f;
    }
    const g = fg(f);
    if (_Type__WEBPACK_IMPORTED_MODULE_0__.isNullable(gh)) {
        return g;
    }
    return gh(g);
};



}),
"../katamari/src/main/ts/ephox/katamari/api/Global.ts": 
/*!************************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Global.ts ***!
  \************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Global: () => (Global)
});
// Use window object as the global if it's available since CSP will block script evals
// eslint-disable-next-line @typescript-eslint/no-implied-eval
const Global = typeof window !== 'undefined' ? window : Function('return this;')();


}),
"../katamari/src/main/ts/ephox/katamari/api/Id.ts": 
/*!********************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Id.ts ***!
  \********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  generate: () => (generate),
  uuidV4: () => (uuidV4)
});
/* ESM import */var _util_IdUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/IdUtils */ "../katamari/src/main/ts/ephox/katamari/util/IdUtils.ts");
/* ESM import */var _Num__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Num */ "../katamari/src/main/ts/ephox/katamari/api/Num.ts");


/**
 * Generate a unique identifier.
 *
 * The unique portion of the identifier only contains an underscore
 * and digits, so that it may safely be used within HTML attributes.
 *
 * The chance of generating a non-unique identifier has been minimized
 * by combining the current time, a random number and a one-up counter.
 *
 * generate :: String -> String
 */ let unique = 0;
const generate = (prefix)=>{
    const date = new Date();
    const time = date.getTime();
    const random = Math.floor(_Num__WEBPACK_IMPORTED_MODULE_0__.random() * 1000000000);
    unique++;
    return prefix + '_' + random + unique + String(time);
};
/**
 * Generate a uuidv4 string
 * In accordance with RFC 4122 (https://datatracker.ietf.org/doc/html/rfc4122)
 */ const uuidV4 = ()=>{
    if (window.isSecureContext) {
        return window.crypto.randomUUID();
    } else {
        return _util_IdUtils__WEBPACK_IMPORTED_MODULE_1__.uuidV4String();
    }
};



}),
"../katamari/src/main/ts/ephox/katamari/api/Num.ts": 
/*!*********************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Num.ts ***!
  \*********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  clamp: () => (clamp),
  cycleBy: () => (cycleBy),
  random: () => (random)
});
/**
 * Adds two numbers, and wrap to a range.
 * If the result overflows to the right, snap to the left.
 * If the result overflows to the left, snap to the right.
 */ const cycleBy = (value, delta, min, max)=>{
    const r = value + delta;
    if (r > max) {
        return min;
    } else if (r < min) {
        return max;
    } else {
        return r;
    }
};
// ASSUMPTION: Max will always be larger than min
const clamp = (value, min, max)=>Math.min(Math.max(value, min), max);
// the division is meant to get a number between 0 and 1 for more information check this discussion: https://stackoverflow.com/questions/58285941/how-to-replace-math-random-with-crypto-getrandomvalues-and-keep-same-result
const random = ()=>window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;


}),
"../katamari/src/main/ts/ephox/katamari/api/Obj.ts": 
/*!*********************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Obj.ts ***!
  \*********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  bifilter: () => (bifilter),
  each: () => (each),
  equal: () => (equal),
  filter: () => (filter),
  find: () => (find),
  get: () => (get),
  has: () => (has),
  hasNonNullableKey: () => (hasNonNullableKey),
  hasOwnProperty: () => (hasOwnProperty),
  isEmpty: () => (isEmpty),
  keys: () => (keys),
  map: () => (map),
  mapToArray: () => (mapToArray),
  size: () => (size),
  tupleMap: () => (tupleMap),
  values: () => (values)
});
/* ESM import */var _ephox_dispute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ephox/dispute */ "../../node_modules/@ephox/dispute/lib/main/ts/api/Eq.js");
/* ESM import */var _Fun__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Fun */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _Optional__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Optional */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");



// There are many variations of Object iteration that are faster than the 'for-in' style:
// http://jsperf.com/object-keys-iteration/107
//
// Use the native keys if it is available (IE9+), otherwise fall back to manually filtering
const keys = Object.keys;
const hasOwnProperty = Object.hasOwnProperty;
const each = (obj, f)=>{
    const props = keys(obj);
    for(let k = 0, len = props.length; k < len; k++){
        const i = props[k];
        const x = obj[i];
        f(x, i);
    }
};
const map = (obj, f)=>{
    return tupleMap(obj, (x, i)=>({
            k: i,
            v: f(x, i)
        }));
};
const tupleMap = (obj, f)=>{
    const r = {};
    each(obj, (x, i)=>{
        const tuple = f(x, i);
        r[tuple.k] = tuple.v;
    });
    return r;
};
const objAcc = (r)=>(x, i)=>{
        r[i] = x;
    };
const internalFilter = (obj, pred, onTrue, onFalse)=>{
    each(obj, (x, i)=>{
        (pred(x, i) ? onTrue : onFalse)(x, i);
    });
};
const bifilter = (obj, pred)=>{
    const t = {};
    const f = {};
    internalFilter(obj, pred, objAcc(t), objAcc(f));
    return {
        t,
        f
    };
};
const filter = (obj, pred)=>{
    const t = {};
    internalFilter(obj, pred, objAcc(t), _Fun__WEBPACK_IMPORTED_MODULE_0__.noop);
    return t;
};
const mapToArray = (obj, f)=>{
    const r = [];
    each(obj, (value, name)=>{
        r.push(f(value, name));
    });
    return r;
};
const find = (obj, pred)=>{
    const props = keys(obj);
    for(let k = 0, len = props.length; k < len; k++){
        const i = props[k];
        const x = obj[i];
        if (pred(x, i, obj)) {
            return _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(x);
        }
    }
    return _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
};
const values = (obj)=>{
    return mapToArray(obj, _Fun__WEBPACK_IMPORTED_MODULE_0__.identity);
};
const size = (obj)=>{
    return keys(obj).length;
};
const get = (obj, key)=>{
    return has(obj, key) ? _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.from(obj[key]) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
};
const has = (obj, key)=>hasOwnProperty.call(obj, key);
const hasNonNullableKey = (obj, key)=>has(obj, key) && obj[key] !== undefined && obj[key] !== null;
const isEmpty = (r)=>{
    for(const x in r){
        if (hasOwnProperty.call(r, x)) {
            return false;
        }
    }
    return true;
};
const equal = (a1, a2, eq = _ephox_dispute__WEBPACK_IMPORTED_MODULE_2__.eqAny)=>_ephox_dispute__WEBPACK_IMPORTED_MODULE_2__.eqRecord(eq).eq(a1, a2);


}),
"../katamari/src/main/ts/ephox/katamari/api/Optional.ts": 
/*!**************************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Optional.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  Optional: () => (Optional)
});
/* ESM import */var _Type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");

/**
 * The `Optional` type represents a value (of any type) that potentially does
 * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the
 * value does exist) or a `None` (in which case the value does not exist). This
 * module defines a whole lot of FP-inspired utility functions for dealing with
 * `Optional` objects.
 *
 * Comparison with null or undefined:
 * - We don't get fancy null coalescing operators with `Optional`
 * - We do get fancy helper functions with `Optional`
 * - `Optional` support nesting, and allow for the type to still be nullable (or
 * another `Optional`)
 * - There is no option to turn off strict-optional-checks like there is for
 * strict-null-checks
 */ class Optional {
    tag;
    value;
    // Sneaky optimisation: every instance of Optional.none is identical, so just
    // reuse the same object
    static singletonNone = new Optional(false);
    // The internal representation has a `tag` and a `value`, but both are
    // private: able to be console.logged, but not able to be accessed by code
    constructor(tag, value){
        this.tag = tag;
        this.value = value;
    }
    // --- Identities ---
    /**
   * Creates a new `Optional<T>` that **does** contain a value.
   */ static some(value) {
        return new Optional(true, value);
    }
    /**
   * Create a new `Optional<T>` that **does not** contain a value. `T` can be
   * any type because we don't actually have a `T`.
   */ static none() {
        return Optional.singletonNone;
    }
    /**
   * Perform a transform on an `Optional` type. Regardless of whether this
   * `Optional` contains a value or not, `fold` will return a value of type `U`.
   * If this `Optional` does not contain a value, the `U` will be created by
   * calling `onNone`. If this `Optional` does contain a value, the `U` will be
   * created by calling `onSome`.
   *
   * For the FP enthusiasts in the room, this function:
   * 1. Could be used to implement all of the functions below
   * 2. Forms a catamorphism
   */ fold(onNone, onSome) {
        if (this.tag) {
            return onSome(this.value);
        } else {
            return onNone();
        }
    }
    /**
   * Determine if this `Optional` object contains a value.
   */ isSome() {
        return this.tag;
    }
    /**
   * Determine if this `Optional` object **does not** contain a value.
   */ isNone() {
        return !this.tag;
    }
    // --- Functor (name stolen from Haskell / maths) ---
    /**
   * Perform a transform on an `Optional` object, **if** there is a value. If
   * you provide a function to turn a T into a U, this is the function you use
   * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
   * a value then the output will also contain a value (that value being the
   * output of `mapper(this.value)`), and if this **does not** contain a value
   * then neither will the output.
   */ map(mapper) {
        if (this.tag) {
            return Optional.some(mapper(this.value));
        } else {
            return Optional.none();
        }
    }
    // --- Monad (name stolen from Haskell / maths) ---
    /**
   * Perform a transform on an `Optional` object, **if** there is a value.
   * Unlike `map`, here the transform itself also returns an `Optional`.
   */ bind(binder) {
        if (this.tag) {
            return binder(this.value);
        } else {
            return Optional.none();
        }
    }
    // --- Traversable (name stolen from Haskell / maths) ---
    /**
   * For a given predicate, this function finds out if there **exists** a value
   * inside this `Optional` object that meets the predicate. In practice, this
   * means that for `Optional`s that do not contain a value it returns false (as
   * no predicate-meeting value exists).
   */ exists(predicate) {
        return this.tag && predicate(this.value);
    }
    /**
   * For a given predicate, this function finds out if **all** the values inside
   * this `Optional` object meet the predicate. In practice, this means that
   * for `Optional`s that do not contain a value it returns true (as all 0
   * objects do meet the predicate).
   */ forall(predicate) {
        return !this.tag || predicate(this.value);
    }
    filter(predicate) {
        if (!this.tag || predicate(this.value)) {
            return this;
        } else {
            return Optional.none();
        }
    }
    // --- Getters ---
    /**
   * Get the value out of the inside of the `Optional` object, using a default
   * `replacement` value if the provided `Optional` object does not contain a
   * value.
   */ getOr(replacement) {
        return this.tag ? this.value : replacement;
    }
    /**
   * Get the value out of the inside of the `Optional` object, using a default
   * `replacement` value if the provided `Optional` object does not contain a
   * value.  Unlike `getOr`, in this method the `replacement` object is also
   * `Optional` - meaning that this method will always return an `Optional`.
   */ or(replacement) {
        return this.tag ? this : replacement;
    }
    /**
   * Get the value out of the inside of the `Optional` object, using a default
   * `replacement` value if the provided `Optional` object does not contain a
   * value. Unlike `getOr`, in this method the `replacement` value is
   * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
   * pass a function which (if called) will **return** the `value` you want to
   * use.
   */ getOrThunk(thunk) {
        return this.tag ? this.value : thunk();
    }
    /**
   * Get the value out of the inside of the `Optional` object, using a default
   * `replacement` value if the provided Optional object does not contain a
   * value.
   *
   * Unlike `or`, in this method the `replacement` value is "thunked" - that is
   * to say that you don't pass a value to `orThunk`, you pass a function which
   * (if called) will **return** the `value` you want to use.
   *
   * Unlike `getOrThunk`, in this method the `replacement` value is also
   * `Optional`, meaning that this method will always return an `Optional`.
   */ orThunk(thunk) {
        return this.tag ? this : thunk();
    }
    /**
   * Get the value out of the inside of the `Optional` object, throwing an
   * exception if the provided `Optional` object does not contain a value.
   *
   * WARNING:
   * You should only be using this function if you know that the `Optional`
   * object **is not** empty (otherwise you're throwing exceptions in production
   * code, which is bad).
   *
   * In tests this is more acceptable.
   *
   * Prefer other methods to this, such as `.each`.
   */ getOrDie(message) {
        if (!this.tag) {
            throw new Error(message ?? 'Called getOrDie on None');
        } else {
            return this.value;
        }
    }
    // --- Interop with null and undefined ---
    /**
   * Creates an `Optional` value from a nullable (or undefined-able) input.
   * Null, or undefined, is converted to `None`, and anything else is converted
   * to `Some`.
   */ static from(value) {
        return _Type__WEBPACK_IMPORTED_MODULE_0__.isNonNullable(value) ? Optional.some(value) : Optional.none();
    }
    /**
   * Converts an `Optional` to a nullable type, by getting the value if it
   * exists, or returning `null` if it does not.
   */ getOrNull() {
        return this.tag ? this.value : null;
    }
    /**
   * Converts an `Optional` to an undefined-able type, by getting the value if
   * it exists, or returning `undefined` if it does not.
   */ getOrUndefined() {
        return this.value;
    }
    // --- Utilities ---
    /**
   * If the `Optional` contains a value, perform an action on that value.
   * Unlike the rest of the methods on this type, `.each` has side-effects. If
   * you want to transform an `Optional<T>` **into** something, then this is not
   * the method for you. If you want to use an `Optional<T>` to **do**
   * something, then this is the method for you - provided you're okay with not
   * doing anything in the case where the `Optional` doesn't have a value inside
   * it. If you're not sure whether your use-case fits into transforming
   * **into** something or **doing** something, check whether it has a return
   * value. If it does, you should be performing a transform.
   */ each(worker) {
        if (this.tag) {
            worker(this.value);
        }
    }
    /**
   * Turn the `Optional` object into an array that contains all of the values
   * stored inside the `Optional`. In practice, this means the output will have
   * either 0 or 1 elements.
   */ toArray() {
        return this.tag ? [
            this.value
        ] : [];
    }
    /**
   * Turn the `Optional` object into a string for debugging or printing. Not
   * recommended for production code, but good for debugging. Also note that
   * these days an `Optional` object can be logged to the console directly, and
   * its inner value (if it exists) will be visible.
   */ toString() {
        return this.tag ? `some(${this.value})` : 'none()';
    }
}


}),
"../katamari/src/main/ts/ephox/katamari/api/Optionals.ts": 
/*!***************************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Optionals.ts ***!
  \***************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  bindFrom: () => (bindFrom),
  cat: () => (cat),
  equals: () => (equals),
  findMap: () => (findMap),
  flatten: () => (flatten),
  is: () => (is),
  lift2: () => (lift2),
  lift3: () => (lift3),
  lift4: () => (lift4),
  lift5: () => (lift5),
  mapFrom: () => (mapFrom),
  sequence: () => (sequence),
  someIf: () => (someIf),
  traverse: () => (traverse)
});
/* ESM import */var _Arr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Arr */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _Fun__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Fun */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _Optional__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Optional */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");



/**
 * **Is** the value stored inside this Optional object equal to `rhs`?
 */ const is = (lhs, rhs, comparator = _Fun__WEBPACK_IMPORTED_MODULE_0__.tripleEquals)=>lhs.exists((left)=>comparator(left, rhs));
/**
 * Are these two Optional objects equal? Equality here means either they're both
 * `Some` (and the values are equal under the comparator) or they're both `None`.
 */ const equals = (lhs, rhs, comparator = _Fun__WEBPACK_IMPORTED_MODULE_0__.tripleEquals)=>lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
const cat = (arr)=>{
    const r = [];
    const push = (x)=>{
        r.push(x);
    };
    for(let i = 0; i < arr.length; i++){
        arr[i].each(push);
    }
    return r;
};
const sequence = (arr)=>{
    const r = [];
    for(let i = 0; i < arr.length; i++){
        const x = arr[i];
        if (x.isSome()) {
            r.push(x.getOrDie());
        } else {
            return _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
        }
    }
    return _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(r);
};
/** @deprecated Use Arr.findMap instead. */ const findMap = _Arr__WEBPACK_IMPORTED_MODULE_2__.findMap;
/** Map each element of an array to an Optional and collect the results.
 *  If all results are "some", return Optional.some of the results.
 *  If any result is "none", return Optional.none
 */ const traverse = (arr, f)=>sequence(_Arr__WEBPACK_IMPORTED_MODULE_2__.map(arr, f));
/*
Notes on the lift functions:
- We used to have a generic liftN, but we were concerned about its type-safety, and the below variants were faster in microbenchmarks.
- The getOrDie calls are partial functions, but are checked beforehand. This is faster and more convenient (but less safe) than folds.
- && is used instead of a loop for simplicity and performance.
*/ const lift2 = (oa, ob, f)=>oa.isSome() && ob.isSome() ? _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(f(oa.getOrDie(), ob.getOrDie())) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
const lift3 = (oa, ob, oc, f)=>oa.isSome() && ob.isSome() && oc.isSome() ? _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
const lift4 = (oa, ob, oc, od, f)=>oa.isSome() && ob.isSome() && oc.isSome() && od.isSome() ? _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie(), od.getOrDie())) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
const lift5 = (oa, ob, oc, od, oe, f)=>oa.isSome() && ob.isSome() && oc.isSome() && od.isSome() && oe.isSome() ? _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie(), od.getOrDie(), oe.getOrDie())) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
const mapFrom = (a, f)=>a !== undefined && a !== null ? _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(f(a)) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
const bindFrom = (a, f)=>a !== undefined && a !== null ? f(a) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
const flatten = (oot)=>oot.bind(_Fun__WEBPACK_IMPORTED_MODULE_0__.identity);
// This can help with type inference, by specifying the type param on the none case, so the caller doesn't have to.
const someIf = (b, a)=>b ? _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.some(a) : _Optional__WEBPACK_IMPORTED_MODULE_1__.Optional.none();


}),
"../katamari/src/main/ts/ephox/katamari/api/Resolve.ts": 
/*!*************************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Resolve.ts ***!
  \*************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  forge: () => (forge),
  namespace: () => (namespace),
  path: () => (path),
  resolve: () => (resolve),
  step: () => (step)
});
/* ESM import */var _Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Global */ "../katamari/src/main/ts/ephox/katamari/api/Global.ts");

/** path :: ([String], JsObj?) -> JsObj */ const path = (parts, scope)=>{
    let o = scope !== undefined && scope !== null ? scope : _Global__WEBPACK_IMPORTED_MODULE_0__.Global;
    for(let i = 0; i < parts.length && o !== undefined && o !== null; ++i){
        o = o[parts[i]];
    }
    return o;
};
/** resolve :: (String, JsObj?) -> JsObj */ const resolve = (p, scope)=>{
    const parts = p.split('.');
    return path(parts, scope);
};
/** step :: (JsObj, String) -> JsObj */ const step = (o, part)=>{
    if (o[part] === undefined || o[part] === null) {
        o[part] = {};
    }
    return o[part];
};
/** forge :: ([String], JsObj?) -> JsObj */ const forge = (parts, target)=>{
    let o = target !== undefined ? target : _Global__WEBPACK_IMPORTED_MODULE_0__.Global;
    for(let i = 0; i < parts.length; ++i){
        o = step(o, parts[i]);
    }
    return o;
};
/** namespace :: (String, JsObj?) -> JsObj */ const namespace = (name, target)=>{
    const parts = name.split('.');
    return forge(parts, target);
};


}),
"../katamari/src/main/ts/ephox/katamari/api/Strings.ts": 
/*!*************************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Strings.ts ***!
  \*************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  capitalize: () => (capitalize),
  contains: () => (contains),
  endsWith: () => (endsWith),
  ensureLeading: () => (ensureLeading),
  ensureTrailing: () => (ensureTrailing),
  fromCodePoint: () => (fromCodePoint),
  isEmpty: () => (isEmpty),
  isNotEmpty: () => (isNotEmpty),
  lTrim: () => (lTrim),
  rTrim: () => (rTrim),
  removeLeading: () => (removeLeading),
  removeTrailing: () => (removeTrailing),
  repeat: () => (repeat),
  startsWith: () => (startsWith),
  supplant: () => (supplant),
  toFloat: () => (toFloat),
  toInt: () => (toInt),
  trim: () => (trim)
});
/* ESM import */var _str_StrAppend__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../str/StrAppend */ "../katamari/src/main/ts/ephox/katamari/str/StrAppend.ts");
/* ESM import */var _Optional__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Optional */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");



const checkRange = (str, substr, start)=>substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;
/** Given a string and object, perform template-replacements on the string, as specified by the object.
 * Any template fields of the form ${name} are replaced by the string or number specified as obj["name"]
 * Based on Douglas Crockford's 'supplant' method for template-replace of strings. Uses different template format.
 */ const supplant = (str, obj)=>{
    const isStringOrNumber = (a)=>{
        const t = typeof a;
        return t === 'string' || t === 'number';
    };
    return str.replace(/\$\{([^{}]*)\}/g, (fullMatch, key)=>{
        const value = obj[key];
        return isStringOrNumber(value) ? value.toString() : fullMatch;
    });
};
const removeLeading = (str, prefix)=>{
    return startsWith(str, prefix) ? _str_StrAppend__WEBPACK_IMPORTED_MODULE_0__.removeFromStart(str, prefix.length) : str;
};
const removeTrailing = (str, suffix)=>{
    return endsWith(str, suffix) ? _str_StrAppend__WEBPACK_IMPORTED_MODULE_0__.removeFromEnd(str, suffix.length) : str;
};
const ensureLeading = (str, prefix)=>{
    return startsWith(str, prefix) ? str : _str_StrAppend__WEBPACK_IMPORTED_MODULE_0__.addToStart(str, prefix);
};
const ensureTrailing = (str, suffix)=>{
    return endsWith(str, suffix) ? str : _str_StrAppend__WEBPACK_IMPORTED_MODULE_0__.addToEnd(str, suffix);
};
const contains = (str, substr, start = 0, end)=>{
    const idx = str.indexOf(substr, start);
    if (idx !== -1) {
        return _Type__WEBPACK_IMPORTED_MODULE_1__.isUndefined(end) ? true : idx + substr.length <= end;
    } else {
        return false;
    }
};
const capitalize = (str)=>{
    return str === '' ? '' : str.charAt(0).toUpperCase() + str.substring(1);
};
/** Does 'str' start with 'prefix'?
 *  Note: all strings start with the empty string.
 *        More formally, for all strings x, startsWith(x, "").
 *        This is so that for all strings x and y, startsWith(y + x, y)
 */ const startsWith = (str, prefix)=>{
    return checkRange(str, prefix, 0);
};
/** Does 'str' end with 'suffix'?
 *  Note: all strings end with the empty string.
 *        More formally, for all strings x, endsWith(x, "").
 *        This is so that for all strings x and y, endsWith(x + y, y)
 */ const endsWith = (str, suffix)=>{
    return checkRange(str, suffix, str.length - suffix.length);
};
const blank = (r)=>(s)=>s.replace(r, '');
/** removes all leading and trailing spaces */ const trim = blank(/^\s+|\s+$/g);
const lTrim = blank(/^\s+/g);
const rTrim = blank(/\s+$/g);
const isNotEmpty = (s)=>s.length > 0;
const isEmpty = (s)=>!isNotEmpty(s);
const repeat = (s, count)=>count <= 0 ? '' : new Array(count + 1).join(s);
const fromCodePoint = String.fromCodePoint;
const toInt = (value, radix = 10)=>{
    const num = parseInt(value, radix);
    return isNaN(num) ? _Optional__WEBPACK_IMPORTED_MODULE_2__.Optional.none() : _Optional__WEBPACK_IMPORTED_MODULE_2__.Optional.some(num);
};
const toFloat = (value)=>{
    const num = parseFloat(value);
    return isNaN(num) ? _Optional__WEBPACK_IMPORTED_MODULE_2__.Optional.none() : _Optional__WEBPACK_IMPORTED_MODULE_2__.Optional.some(num);
};


}),
"../katamari/src/main/ts/ephox/katamari/api/Type.ts": 
/*!**********************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/api/Type.ts ***!
  \**********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  is: () => (is),
  isArray: () => (isArray),
  isArrayOf: () => (isArrayOf),
  isBoolean: () => (isBoolean),
  isFunction: () => (isFunction),
  isNonNullable: () => (isNonNullable),
  isNull: () => (isNull),
  isNullable: () => (isNullable),
  isNumber: () => (isNumber),
  isObject: () => (isObject),
  isPlainObject: () => (isPlainObject),
  isPromiseLike: () => (isPromiseLike),
  isString: () => (isString),
  isUndefined: () => (isUndefined)
});
/* eslint-disable @typescript-eslint/no-wrapper-object-types */ const getPrototypeOf = Object.getPrototypeOf;
const hasProto = (v, constructor, predicate)=>{
    if (predicate(v, constructor.prototype)) {
        return true;
    } else {
        // String-based fallback time
        return v.constructor?.name === constructor.name;
    }
};
const typeOf = (x)=>{
    const t = typeof x;
    if (x === null) {
        return 'null';
    } else if (t === 'object' && Array.isArray(x)) {
        return 'array';
    } else if (t === 'object' && hasProto(x, String, (o, proto)=>proto.isPrototypeOf(o))) {
        return 'string';
    } else {
        return t;
    }
};
const isType = (type)=>(value)=>typeOf(value) === type;
const isSimpleType = (type)=>(value)=>typeof value === type;
const eq = (t)=>(a)=>t === a;
const is = (value, constructor)=>isObject(value) && hasProto(value, constructor, (o, proto)=>getPrototypeOf(o) === proto);
const isString = isType('string');
const isObject = isType('object');
const isPlainObject = (value)=>is(value, Object);
const isArray = isType('array');
const isNull = eq(null);
const isBoolean = isSimpleType('boolean');
const isUndefined = eq(undefined);
const isNullable = (a)=>a === null || a === undefined;
const isNonNullable = (a)=>!isNullable(a);
const isFunction = isSimpleType('function');
const isNumber = isSimpleType('number');
const isArrayOf = (value, pred)=>{
    if (isArray(value)) {
        for(let i = 0, len = value.length; i < len; ++i){
            if (!pred(value[i])) {
                return false;
            }
        }
        return true;
    }
    return false;
};
const isPromiseLike = (x)=>isObject(x) && isFunction(x.then) && isFunction(x.catch);


}),
"../katamari/src/main/ts/ephox/katamari/str/StrAppend.ts": 
/*!***************************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/str/StrAppend.ts ***!
  \***************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  addToEnd: () => (addToEnd),
  addToStart: () => (addToStart),
  removeFromEnd: () => (removeFromEnd),
  removeFromStart: () => (removeFromStart)
});
const addToStart = (str, prefix)=>{
    return prefix + str;
};
const addToEnd = (str, suffix)=>{
    return str + suffix;
};
const removeFromStart = (str, numChars)=>{
    return str.substring(numChars);
};
const removeFromEnd = (str, numChars)=>{
    return str.substring(0, str.length - numChars);
};


}),
"../katamari/src/main/ts/ephox/katamari/util/IdUtils.ts": 
/*!**************************************************************!*\
  !*** ../katamari/src/main/ts/ephox/katamari/util/IdUtils.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  uuidV4Bytes: () => (uuidV4Bytes),
  uuidV4String: () => (uuidV4String)
});
/* eslint-disable no-bitwise */ const uuidV4Bytes = ()=>{
    const bytes = window.crypto.getRandomValues(new Uint8Array(16));
    // https://tools.ietf.org/html/rfc4122#section-4.1.3
    // This will first bit mask away the most significant 4 bits (version octet)
    // then mask in the v4 number we only care about v4 random version at this point so (byte & 0b00001111 | 0b01000000)
    bytes[6] = bytes[6] & 15 | 64;
    // https://tools.ietf.org/html/rfc4122#section-4.1.1
    // This will first bit mask away the highest two bits then masks in the highest bit so (byte & 0b00111111 | 0b10000000)
    // So it will set the Msb0=1 & Msb1=0 described by the "The variant specified in this document." row in the table
    bytes[8] = bytes[8] & 63 | 128;
    return bytes;
};
const uuidV4String = ()=>{
    const uuid = uuidV4Bytes();
    const getHexRange = (startIndex, endIndex)=>{
        let buff = '';
        for(let i = startIndex; i <= endIndex; ++i){
            const hexByte = uuid[i].toString(16).padStart(2, '0');
            buff += hexByte;
        }
        return buff;
    };
    // RFC 4122 UUID format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    return `${getHexRange(0, 3)}-${getHexRange(4, 5)}-${getHexRange(6, 7)}-${getHexRange(8, 9)}-${getHexRange(10, 15)}`;
};



}),
"../phoenix/src/main/ts/ephox/phoenix/api/data/Spot.ts": 
/*!*************************************************************!*\
  !*** ../phoenix/src/main/ts/ephox/phoenix/api/data/Spot.ts ***!
  \*************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  delta: () => (delta),
  point: () => (point),
  points: () => (points),
  range: () => (range),
  text: () => (text)
});
const point = (element, offset)=>({
        element,
        offset
    });
const delta = (element, deltaOffset)=>({
        element,
        deltaOffset
    });
const range = (element, start, finish)=>({
        element,
        start,
        finish
    });
const points = (begin, end)=>({
        begin,
        end
    });
const text = (element, text)=>({
        element,
        text
    });



}),
"../phoenix/src/main/ts/ephox/phoenix/api/dom/DomDescent.ts": 
/*!******************************************************************!*\
  !*** ../phoenix/src/main/ts/ephox/phoenix/api/dom/DomDescent.ts ***!
  \******************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  freefallLtr: () => (freefallLtr),
  freefallRtl: () => (freefallRtl),
  toLeaf: () => (toLeaf)
});
/* ESM import */var _ephox_boss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/boss */ "../boss/src/main/ts/ephox/boss/api/DomUniverse.ts");
/* ESM import */var _general_Descent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../general/Descent */ "../phoenix/src/main/ts/ephox/phoenix/api/general/Descent.ts");


const universe = (0,_ephox_boss__WEBPACK_IMPORTED_MODULE_0__["default"])();
const toLeaf = (element, offset)=>{
    return _general_Descent__WEBPACK_IMPORTED_MODULE_1__.toLeaf(universe, element, offset);
};
/* The purpose of freefall is that they will land on an element that is not whitespace text. This
 * can be very useful inside beautified content
 */ const freefallLtr = (element)=>{
    return _general_Descent__WEBPACK_IMPORTED_MODULE_1__.freefallLtr(universe, element);
};
const freefallRtl = (element)=>{
    return _general_Descent__WEBPACK_IMPORTED_MODULE_1__.freefallRtl(universe, element);
};



}),
"../phoenix/src/main/ts/ephox/phoenix/api/general/Descent.ts": 
/*!*******************************************************************!*\
  !*** ../phoenix/src/main/ts/ephox/phoenix/api/general/Descent.ts ***!
  \*******************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  freefallLtr: () => (freefallLtr),
  freefallRtl: () => (freefallRtl),
  toLeaf: () => (toLeaf)
});
/* ESM import */var _wrap_Navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../wrap/Navigation */ "../phoenix/src/main/ts/ephox/phoenix/wrap/Navigation.ts");

const toLeaf = _wrap_Navigation__WEBPACK_IMPORTED_MODULE_0__.toLeaf;
const freefallLtr = _wrap_Navigation__WEBPACK_IMPORTED_MODULE_0__.freefallLtr;
const freefallRtl = _wrap_Navigation__WEBPACK_IMPORTED_MODULE_0__.freefallRtl;



}),
"../phoenix/src/main/ts/ephox/phoenix/wrap/Navigation.ts": 
/*!***************************************************************!*\
  !*** ../phoenix/src/main/ts/ephox/phoenix/wrap/Navigation.ts ***!
  \***************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  freefallLtr: () => (freefallLtr),
  freefallRtl: () => (freefallRtl),
  toLast: () => (toLast),
  toLeaf: () => (toLeaf),
  toLower: () => (toLower)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/data/Spot */ "../phoenix/src/main/ts/ephox/phoenix/api/data/Spot.ts");


/**
 * Return the last available cursor position in the node.
 */ const toLast = (universe, node)=>{
    if (universe.property().isText(node)) {
        return _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(node, universe.property().getText(node).length);
    } else {
        const children = universe.property().children(node);
        // keep descending if there are children.
        return children.length > 0 ? toLast(universe, children[children.length - 1]) : _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(node, children.length);
    }
};
const toLower = (universe, node)=>{
    const lastOffset = universe.property().isText(node) ? universe.property().getText(node).length : universe.property().children(node).length;
    return _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(node, lastOffset);
};
/**
 * Descend down to a leaf node at the given offset.
 */ const toLeaf = (universe, element, offset)=>{
    const children = universe.property().children(element);
    if (children.length > 0 && offset < children.length) {
        return toLeaf(universe, children[offset], 0);
    } else if (children.length > 0 && universe.property().isElement(element) && children.length === offset) {
        return toLast(universe, children[children.length - 1]);
    } else {
        return _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(element, offset);
    }
};
const scan = (universe, element, direction)=>{
    // if a comment or zero-length text, scan the siblings
    if (universe.property().isText(element) && universe.property().getText(element).trim().length === 0 || universe.property().isComment(element)) {
        return direction(element).bind((elem)=>{
            return scan(universe, elem, direction).orThunk(()=>{
                return _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.Optional.some(elem);
            });
        });
    } else {
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.Optional.none();
    }
};
const freefallLtr = (universe, element)=>{
    const candidate = scan(universe, element, universe.query().nextSibling).getOr(element);
    if (universe.property().isText(candidate)) {
        return _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(candidate, 0);
    }
    const children = universe.property().children(candidate);
    return children.length > 0 ? freefallLtr(universe, children[0]) : _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(candidate, 0);
};
const toEnd = (universe, element)=>{
    if (universe.property().isText(element)) {
        return universe.property().getText(element).length;
    }
    const children = universe.property().children(element);
    return children.length;
};
const freefallRtl = (universe, element)=>{
    const candidate = scan(universe, element, universe.query().prevSibling).getOr(element);
    if (universe.property().isText(candidate)) {
        return _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(candidate, toEnd(universe, candidate));
    }
    const children = universe.property().children(candidate);
    return children.length > 0 ? freefallRtl(universe, children[children.length - 1]) : _api_data_Spot__WEBPACK_IMPORTED_MODULE_0__.point(candidate, toEnd(universe, candidate));
};



}),
"../sand/src/main/ts/ephox/sand/api/SandHTMLElement.ts": 
/*!*************************************************************!*\
  !*** ../sand/src/main/ts/ephox/sand/api/SandHTMLElement.ts ***!
  \*************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  isPrototypeOf: () => (isPrototypeOf)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Resolve.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");
/* ESM import */var _util_Global__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Global */ "../sand/src/main/ts/ephox/sand/util/Global.ts");


const getPrototypeOf = Object.getPrototypeOf;
/*
 * IE9 and above
 *
 * MDN no use on this one, but here's the link anyway:
 * https://developer.mozilla.org/en/docs/Web/API/HTMLElement
 */ const sandHTMLElement = (scope)=>{
    return _util_Global__WEBPACK_IMPORTED_MODULE_0__.getOrDie('HTMLElement', scope);
};
const isPrototypeOf = (x)=>{
    // use Resolve to get the window object for x and just return undefined if it can't find it.
    // undefined scope later triggers using the global window.
    const scope = _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.resolve('ownerDocument.defaultView', x);
    // TINY-7374: We can't rely on looking at the owner window HTMLElement as the element may have
    // been constructed in a different window and then appended to the current window document.
    return _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf(x).constructor.name));
};



}),
"../sand/src/main/ts/ephox/sand/util/Global.ts": 
/*!*****************************************************!*\
  !*** ../sand/src/main/ts/ephox/sand/util/Global.ts ***!
  \*****************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  getOrDie: () => (getOrDie)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Resolve.ts");

const unsafe = (name, scope)=>{
    return _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.resolve(name, scope);
};
const getOrDie = (name, scope)=>{
    const actual = unsafe(name, scope);
    if (actual === undefined || actual === null) {
        throw new Error(name + ' not available on this browser');
    }
    return actual;
};



}),
"../sugar/src/main/ts/ephox/sugar/alien/Recurse.ts": 
/*!*********************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/alien/Recurse.ts ***!
  \*********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  toArray: () => (toArray)
});
/**
 * Applies f repeatedly until it completes (by returning Optional.none()).
 *
 * Normally would just use recursion, but JavaScript lacks tail call optimisation.
 *
 * This is what recursion looks like when manually unravelled :)
 */ const toArray = (target, f)=>{
    const r = [];
    const recurse = (e)=>{
        r.push(e);
        return f(e);
    };
    let cur = f(target);
    do {
        cur = cur.bind(recurse);
    }while (cur.isSome())
    return r;
};



}),
"../sugar/src/main/ts/ephox/sugar/api/dom/Compare.ts": 
/*!***********************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/dom/Compare.ts ***!
  \***********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  contains: () => (contains),
  eq: () => (eq),
  is: () => (is),
  isEqualNode: () => (isEqualNode),
  member: () => (member)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _search_Selectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../search/Selectors */ "../sugar/src/main/ts/ephox/sugar/api/search/Selectors.ts");


const eq = (e1, e2)=>e1.dom === e2.dom;
const isEqualNode = (e1, e2)=>e1.dom.isEqualNode(e2.dom);
const member = (element, elements)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.exists(elements, _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.curry(eq, element));
// Returns: true if node e1 contains e2, otherwise false.
// (returns false if e1===e2: A node does not contain itself).
const contains = (e1, e2)=>{
    const d1 = e1.dom;
    const d2 = e2.dom;
    return d1 === d2 ? false : d1.contains(d2);
};
const is = _search_Selectors__WEBPACK_IMPORTED_MODULE_2__.is;



}),
"../sugar/src/main/ts/ephox/sugar/api/dom/Insert.ts": 
/*!**********************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/dom/Insert.ts ***!
  \**********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  after: () => (after),
  append: () => (append),
  appendAt: () => (appendAt),
  before: () => (before),
  prepend: () => (prepend),
  wrap: () => (wrap)
});
/* ESM import */var _search_Traverse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../search/Traverse */ "../sugar/src/main/ts/ephox/sugar/api/search/Traverse.ts");

const before = (marker, element)=>{
    const parent = _search_Traverse__WEBPACK_IMPORTED_MODULE_0__.parent(marker);
    parent.each((v)=>{
        v.dom.insertBefore(element.dom, marker.dom);
    });
};
const after = (marker, element)=>{
    const sibling = _search_Traverse__WEBPACK_IMPORTED_MODULE_0__.nextSibling(marker);
    sibling.fold(()=>{
        const parent = _search_Traverse__WEBPACK_IMPORTED_MODULE_0__.parent(marker);
        parent.each((v)=>{
            append(v, element);
        });
    }, (v)=>{
        before(v, element);
    });
};
const prepend = (parent, element)=>{
    const firstChild = _search_Traverse__WEBPACK_IMPORTED_MODULE_0__.firstChild(parent);
    firstChild.fold(()=>{
        append(parent, element);
    }, (v)=>{
        parent.dom.insertBefore(element.dom, v.dom);
    });
};
const append = (parent, element)=>{
    parent.dom.appendChild(element.dom);
};
const appendAt = (parent, element, index)=>{
    _search_Traverse__WEBPACK_IMPORTED_MODULE_0__.child(parent, index).fold(()=>{
        append(parent, element);
    }, (v)=>{
        before(v, element);
    });
};
const wrap = (element, wrapper)=>{
    before(element, wrapper);
    append(wrapper, element);
};



}),
"../sugar/src/main/ts/ephox/sugar/api/dom/InsertAll.ts": 
/*!*************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/dom/InsertAll.ts ***!
  \*************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  after: () => (after),
  append: () => (append),
  before: () => (before),
  prepend: () => (prepend)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _Insert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Insert */ "../sugar/src/main/ts/ephox/sugar/api/dom/Insert.ts");


const before = (marker, elements)=>{
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.each(elements, (x)=>{
        _Insert__WEBPACK_IMPORTED_MODULE_1__.before(marker, x);
    });
};
const after = (marker, elements)=>{
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.each(elements, (x, i)=>{
        const e = i === 0 ? marker : elements[i - 1];
        _Insert__WEBPACK_IMPORTED_MODULE_1__.after(e, x);
    });
};
const prepend = (parent, elements)=>{
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.each(elements.slice().reverse(), (x)=>{
        _Insert__WEBPACK_IMPORTED_MODULE_1__.prepend(parent, x);
    });
};
const append = (parent, elements)=>{
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.each(elements, (x)=>{
        _Insert__WEBPACK_IMPORTED_MODULE_1__.append(parent, x);
    });
};



}),
"../sugar/src/main/ts/ephox/sugar/api/dom/Remove.ts": 
/*!**********************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/dom/Remove.ts ***!
  \**********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  empty: () => (empty),
  remove: () => (remove),
  unwrap: () => (unwrap)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _search_Traverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../search/Traverse */ "../sugar/src/main/ts/ephox/sugar/api/search/Traverse.ts");
/* ESM import */var _InsertAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InsertAll */ "../sugar/src/main/ts/ephox/sugar/api/dom/InsertAll.ts");



const empty = (element)=>{
    // shortcut "empty node" trick. Requires IE 9.
    element.dom.textContent = '';
    // If the contents was a single empty text node, the above doesn't remove it. But, it's still faster in general
    // than removing every child node manually.
    // The following is (probably) safe for performance as 99.9% of the time the trick works and
    // Traverse.children will return an empty array.
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.each(_search_Traverse__WEBPACK_IMPORTED_MODULE_1__.children(element), (rogue)=>{
        remove(rogue);
    });
};
const remove = (element)=>{
    const dom = element.dom;
    if (dom.parentNode !== null) {
        dom.parentNode.removeChild(dom);
    }
};
const unwrap = (wrapper)=>{
    const children = _search_Traverse__WEBPACK_IMPORTED_MODULE_1__.children(wrapper);
    if (children.length > 0) {
        _InsertAll__WEBPACK_IMPORTED_MODULE_2__.after(wrapper, children);
    }
    remove(wrapper);
};



}),
"../sugar/src/main/ts/ephox/sugar/api/node/NodeTypes.ts": 
/*!**************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/node/NodeTypes.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ATTRIBUTE: () => (ATTRIBUTE),
  CDATA_SECTION: () => (CDATA_SECTION),
  COMMENT: () => (COMMENT),
  DOCUMENT: () => (DOCUMENT),
  DOCUMENT_FRAGMENT: () => (DOCUMENT_FRAGMENT),
  DOCUMENT_TYPE: () => (DOCUMENT_TYPE),
  ELEMENT: () => (ELEMENT),
  ENTITY: () => (ENTITY),
  ENTITY_REFERENCE: () => (ENTITY_REFERENCE),
  NOTATION: () => (NOTATION),
  PROCESSING_INSTRUCTION: () => (PROCESSING_INSTRUCTION),
  TEXT: () => (TEXT)
});
const ATTRIBUTE = 2;
const CDATA_SECTION = 4;
const COMMENT = 8;
const DOCUMENT = 9;
const DOCUMENT_TYPE = 10;
const DOCUMENT_FRAGMENT = 11;
const ELEMENT = 1;
const TEXT = 3;
const PROCESSING_INSTRUCTION = 7;
const ENTITY_REFERENCE = 5;
const ENTITY = 6;
const NOTATION = 12;



}),
"../sugar/src/main/ts/ephox/sugar/api/node/SugarBody.ts": 
/*!**************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/node/SugarBody.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  body: () => (body),
  getBody: () => (getBody),
  inBody: () => (inBody)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _SugarElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SugarElement */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");
/* ESM import */var _SugarNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SugarNode */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts");
/* ESM import */var _SugarShadowDom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SugarShadowDom */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarShadowDom.ts");




// Node.contains() is very, very, very good performance
// http://jsperf.com/closest-vs-contains/5
const inBody = (element)=>{
    // Technically this is only required on IE, where contains() returns false for text nodes.
    // But it's cheap enough to run everywhere and Sugar doesn't have platform detection (yet).
    const dom = _SugarNode__WEBPACK_IMPORTED_MODULE_0__.isText(element) ? element.dom.parentNode : element.dom;
    // use ownerDocument.body to ensure this works inside iframes.
    // Normally contains is bad because an element "contains" itself, but here we want that.
    if (dom === undefined || dom === null || dom.ownerDocument === null) {
        return false;
    }
    const doc = dom.ownerDocument;
    return (0,_SugarShadowDom__WEBPACK_IMPORTED_MODULE_1__.getShadowRoot)(_SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom(dom)).fold(()=>doc.body.contains(dom), _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.compose1(inBody, _SugarShadowDom__WEBPACK_IMPORTED_MODULE_1__.getShadowHost));
};
const body = ()=>getBody(_SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom(document));
const getBody = (doc)=>{
    const b = doc.dom.body;
    if (b === null || b === undefined) {
        throw new Error('Body is not available yet');
    }
    return _SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom(b);
};



}),
"../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts": 
/*!*****************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts ***!
  \*****************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  SugarElement: () => (SugarElement)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");

const fromHtml = (html, scope)=>{
    const doc = scope || document;
    const div = doc.createElement('div');
    div.innerHTML = html;
    if (!div.hasChildNodes() || div.childNodes.length > 1) {
        const message = 'HTML does not have a single root node';
        // eslint-disable-next-line no-console
        console.error(message, html);
        throw new Error(message);
    }
    return fromDom(div.childNodes[0]);
};
const fromTag = (tag, scope)=>{
    const doc = scope || document;
    const node = doc.createElement(tag);
    return fromDom(node);
};
const fromText = (text, scope)=>{
    const doc = scope || document;
    const node = doc.createTextNode(text);
    return fromDom(node);
};
const fromDom = (node)=>{
    // TODO: Consider removing this check, but left atm for safety
    if (node === null || node === undefined) {
        throw new Error('Node cannot be null or undefined');
    }
    return {
        dom: node
    };
};
const fromPoint = (docElm, x, y)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
// tslint:disable-next-line:variable-name
const SugarElement = {
    fromHtml,
    fromTag,
    fromText,
    fromDom,
    fromPoint
};



}),
"../sugar/src/main/ts/ephox/sugar/api/node/SugarHead.ts": 
/*!**************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/node/SugarHead.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  getHead: () => (getHead),
  head: () => (head)
});
/* ESM import */var _SugarElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SugarElement */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");

const head = ()=>getHead(_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom(document));
const getHead = (doc)=>{
    /*
   * IE9 and above per
   * https://developer.mozilla.org/en-US/docs/Web/API/Document/head
   */ const b = doc.dom.head;
    if (b === null || b === undefined) {
        throw new Error('Head is not available yet');
    }
    return _SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom(b);
};


}),
"../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts": 
/*!**************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  isComment: () => (isComment),
  isDocument: () => (isDocument),
  isDocumentFragment: () => (isDocumentFragment),
  isElement: () => (isElement),
  isHTMLElement: () => (isHTMLElement),
  isTag: () => (isTag),
  isText: () => (isText),
  name: () => (name),
  type: () => (type),
  value: () => (value)
});
/* ESM import */var _ephox_sand__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/sand */ "../sand/src/main/ts/ephox/sand/api/SandHTMLElement.ts");
/* ESM import */var _NodeTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NodeTypes */ "../sugar/src/main/ts/ephox/sugar/api/node/NodeTypes.ts");


const name = (element)=>{
    const r = element.dom.nodeName;
    return r.toLowerCase();
};
const type = (element)=>element.dom.nodeType;
const value = (element)=>element.dom.nodeValue;
const isType = (t)=>(element)=>type(element) === t;
const isComment = (element)=>type(element) === _NodeTypes__WEBPACK_IMPORTED_MODULE_0__.COMMENT || name(element) === '#comment';
const isHTMLElement = (element)=>isElement(element) && _ephox_sand__WEBPACK_IMPORTED_MODULE_1__.isPrototypeOf(element.dom);
const isElement = isType(_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.ELEMENT);
const isText = isType(_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.TEXT);
const isDocument = isType(_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT);
const isDocumentFragment = isType(_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT_FRAGMENT);
const isTag = (tag)=>(e)=>isElement(e) && name(e) === tag;



}),
"../sugar/src/main/ts/ephox/sugar/api/node/SugarShadowDom.ts": 
/*!*******************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/node/SugarShadowDom.ts ***!
  \*******************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  createElement: () => (createElement),
  getContentContainer: () => (getContentContainer),
  getOriginalEventTarget: () => (getOriginalEventTarget),
  getRootNode: () => (getRootNode),
  getShadowHost: () => (getShadowHost),
  getShadowRoot: () => (getShadowRoot),
  getStyleContainer: () => (getStyleContainer),
  isClosedShadowRoot: () => (isClosedShadowRoot),
  isInShadowRoot: () => (isInShadowRoot),
  isOpenShadowHost: () => (isOpenShadowHost),
  isOpenShadowRoot: () => (isOpenShadowRoot),
  isShadowRoot: () => (isShadowRoot)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _search_Traverse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../search/Traverse */ "../sugar/src/main/ts/ephox/sugar/api/search/Traverse.ts");
/* ESM import */var _SugarElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SugarElement */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");
/* ESM import */var _SugarHead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SugarHead */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarHead.ts");
/* ESM import */var _SugarNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SugarNode */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts");





/**
 * Is the element a ShadowRoot?
 *
 * Note: this is insufficient to test if any element is a shadow root, but it is sufficient to differentiate between
 * a Document and a ShadowRoot.
 */ const isShadowRoot = (dos)=>_SugarNode__WEBPACK_IMPORTED_MODULE_0__.isDocumentFragment(dos) && _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.isNonNullable(dos.dom.host);
const getRootNode = (e)=>_SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom(e.dom.getRootNode());
/** Create an element, using the actual document. */ const createElement = (dos, tag)=>_SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromTag(tag, _search_Traverse__WEBPACK_IMPORTED_MODULE_3__.documentOrOwner(dos).dom);
/** Where style tags need to go. ShadowRoot or document head */ const getStyleContainer = (dos)=>isShadowRoot(dos) ? dos : _SugarHead__WEBPACK_IMPORTED_MODULE_4__.getHead(_search_Traverse__WEBPACK_IMPORTED_MODULE_3__.documentOrOwner(dos));
/** Where content needs to go. ShadowRoot or document body */ const getContentContainer = (dos)=>// Can't use SugarBody.body without causing a circular module reference (since SugarBody.inBody uses SugarShadowDom)
    isShadowRoot(dos) ? dos : _SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom(_search_Traverse__WEBPACK_IMPORTED_MODULE_3__.documentOrOwner(dos).dom.body);
/** Is this element either a ShadowRoot or a descendent of a ShadowRoot. */ const isInShadowRoot = (e)=>getShadowRoot(e).isSome();
/** If this element is in a ShadowRoot, return it. */ const getShadowRoot = (e)=>{
    const r = getRootNode(e);
    return isShadowRoot(r) ? _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__.Optional.some(r) : _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__.Optional.none();
};
/** Return the host of a ShadowRoot.
 *
 * This function will throw if Shadow DOM is unsupported in the browser, or if the host is null.
 * If you actually have a ShadowRoot, this shouldn't happen.
 */ const getShadowHost = (e)=>_SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom(e.dom.host);
/**
 * When Events bubble up through a ShadowRoot, the browser changes the target to be the shadow host.
 * This function gets the "original" event target if possible.
 * This only works if the shadow tree is open - if the shadow tree is closed, event.target is returned.
 * See: https://developers.google.com/web/fundamentals/web-components/shadowdom#events
 */ const getOriginalEventTarget = (event)=>{
    if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.isNonNullable(event.target)) {
        const el = _SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom(event.target);
        if (_SugarNode__WEBPACK_IMPORTED_MODULE_0__.isElement(el) && isOpenShadowHost(el)) {
            // When target element is inside Shadow DOM we need to take first element from composedPath
            // otherwise we'll get Shadow Root parent, not actual target element.
            if (event.composed && event.composedPath) {
                const composedPath = event.composedPath();
                if (composedPath) {
                    return _ephox_katamari__WEBPACK_IMPORTED_MODULE_6__.head(composedPath);
                }
            }
        }
    }
    return _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__.Optional.from(event.target);
};
const isOpenShadowRoot = (sr)=>sr.dom.mode === 'open';
const isClosedShadowRoot = (sr)=>sr.dom.mode === 'closed';
/** Return true if the element is a host of an open shadow root.
 *  Return false if the element is a host of a closed shadow root, or if the element is not a host.
 */ const isOpenShadowHost = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.isNonNullable(element.dom.shadowRoot);


}),
"../sugar/src/main/ts/ephox/sugar/api/node/SugarText.ts": 
/*!**************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/node/SugarText.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  get: () => (get),
  getOption: () => (getOption),
  set: () => (set)
});
/* ESM import */var _impl_NodeValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../impl/NodeValue */ "../sugar/src/main/ts/ephox/sugar/impl/NodeValue.ts");
/* ESM import */var _SugarNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SugarNode */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts");


const api = (0,_impl_NodeValue__WEBPACK_IMPORTED_MODULE_0__.NodeValue)(_SugarNode__WEBPACK_IMPORTED_MODULE_1__.isText, 'text');
const get = (element)=>api.get(element);
const getOption = (element)=>api.getOption(element);
const set = (element, value)=>api.set(element, value);



}),
"../sugar/src/main/ts/ephox/sugar/api/properties/Attribute.ts": 
/*!********************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/properties/Attribute.ts ***!
  \********************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  clone: () => (clone),
  get: () => (get),
  getOpt: () => (getOpt),
  has: () => (has),
  hasNone: () => (hasNone),
  remove: () => (remove),
  set: () => (set),
  setAll: () => (setAll),
  setOptions: () => (setOptions),
  transfer: () => (transfer)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Obj.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _node_SugarNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../node/SugarNode */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts");


const rawSet = (dom, key, value)=>{
    /*
   * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.
   *
   * We fail on those invalid cases, only allowing numbers and booleans.
   */ if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.isString(value) || _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.isBoolean(value) || _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.isNumber(value)) {
        dom.setAttribute(key, value + '');
    } else {
        // eslint-disable-next-line no-console
        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);
        throw new Error('Attribute value was not simple');
    }
};
const set = (element, key, value)=>{
    rawSet(element.dom, key, value);
};
const setAll = (element, attrs)=>{
    const dom = element.dom;
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.each(attrs, (v, k)=>{
        rawSet(dom, k, v);
    });
};
const setOptions = (element, attrs)=>{
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.each(attrs, (v, k)=>{
        v.fold(()=>{
            remove(element, k);
        }, (value)=>{
            rawSet(element.dom, k, value);
        });
    });
};
const get = (element, key)=>{
    const v = element.dom.getAttribute(key);
    // undefined is the more appropriate value for JS, and this matches JQuery
    return v === null ? undefined : v;
};
const getOpt = (element, key)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.Optional.from(get(element, key));
const has = (element, key)=>{
    const dom = element.dom;
    // return false for non-element nodes, no point in throwing an error
    return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;
};
const remove = (element, key)=>{
    element.dom.removeAttribute(key);
};
const hasNone = (element)=>{
    const attrs = element.dom.attributes;
    return attrs === undefined || attrs === null || attrs.length === 0;
};
const clone = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.foldl(element.dom.attributes, (acc, attr)=>{
        acc[attr.name] = attr.value;
        return acc;
    }, {});
const transferOne = (source, destination, attr)=>{
    // NOTE: We don't want to clobber any existing attributes
    if (!has(destination, attr)) {
        getOpt(source, attr).each((srcValue)=>set(destination, attr, srcValue));
    }
};
// Transfer attributes(attrs) from source to destination, unless they are already present
const transfer = (source, destination, attrs)=>{
    if (!_node_SugarNode__WEBPACK_IMPORTED_MODULE_4__.isElement(source) || !_node_SugarNode__WEBPACK_IMPORTED_MODULE_4__.isElement(destination)) {
        return;
    }
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.each(attrs, (attr)=>{
        transferOne(source, destination, attr);
    });
};



}),
"../sugar/src/main/ts/ephox/sugar/api/properties/Css.ts": 
/*!**************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/properties/Css.ts ***!
  \**************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  copy: () => (copy),
  get: () => (get),
  getAllRaw: () => (getAllRaw),
  getRaw: () => (getRaw),
  isValidValue: () => (isValidValue),
  preserve: () => (preserve),
  reflow: () => (reflow),
  remove: () => (remove),
  set: () => (set),
  setAll: () => (setAll),
  setOptions: () => (setOptions),
  transfer: () => (transfer)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Obj.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optionals.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Strings.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _impl_Style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../impl/Style */ "../sugar/src/main/ts/ephox/sugar/impl/Style.ts");
/* ESM import */var _node_SugarBody__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node/SugarBody */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarBody.ts");
/* ESM import */var _node_SugarElement__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../node/SugarElement */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");
/* ESM import */var _node_SugarNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../node/SugarNode */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts");
/* ESM import */var _Attribute__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Attribute */ "../sugar/src/main/ts/ephox/sugar/api/properties/Attribute.ts");






const internalSet = (dom, property, value)=>{
    // This is going to hurt. Apologies.
    // JQuery coerces numbers to pixels for certain property names, and other times lets numbers through.
    // we're going to be explicit; strings only.
    if (!_ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.isString(value)) {
        // eslint-disable-next-line no-console
        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);
        throw new Error('CSS value must be a string: ' + value);
    }
    // removed: support for dom().style[property] where prop is camel case instead of normal property name
    if (_impl_Style__WEBPACK_IMPORTED_MODULE_1__.isSupported(dom)) {
        dom.style.setProperty(property, value);
    }
};
const internalRemove = (dom, property)=>{
    /*
   * IE9 and above - MDN doesn't have details, but here's a couple of random internet claims
   *
   * http://help.dottoro.com/ljopsjck.php
   * http://stackoverflow.com/a/7901886/7546
   */ if (_impl_Style__WEBPACK_IMPORTED_MODULE_1__.isSupported(dom)) {
        dom.style.removeProperty(property);
    }
};
const set = (element, property, value)=>{
    const dom = element.dom;
    internalSet(dom, property, value);
};
const setAll = (element, css)=>{
    const dom = element.dom;
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.each(css, (v, k)=>{
        internalSet(dom, k, v);
    });
};
const setOptions = (element, css)=>{
    const dom = element.dom;
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.each(css, (v, k)=>{
        v.fold(()=>{
            internalRemove(dom, k);
        }, (value)=>{
            internalSet(dom, k, value);
        });
    });
};
/*
 * NOTE: For certain properties, this returns the "used value" which is subtly different to the "computed value" (despite calling getComputedStyle).
 * Blame CSS 2.0.
 *
 * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 */ const get = (element, property)=>{
    const dom = element.dom;
    /*
   * IE9 and above per
   * https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle
   *
   * Not in numerosity, because it doesn't memoize and looking this up dynamically in performance critical code would be horrendous.
   *
   * JQuery has some magic here for IE popups, but we don't really need that.
   * It also uses element.ownerDocument.defaultView to handle iframes but that hasn't been required since FF 3.6.
   */ const styles = window.getComputedStyle(dom);
    const r = styles.getPropertyValue(property);
    // jquery-ism: If r is an empty string, check that the element is not in a document. If it isn't, return the raw value.
    // Turns out we do this a lot.
    return r === '' && !_node_SugarBody__WEBPACK_IMPORTED_MODULE_3__.inBody(element) ? getUnsafeProperty(dom, property) : r;
};
// removed: support for dom().style[property] where prop is camel case instead of normal property name
// empty string is what the browsers (IE11 and Chrome) return when the propertyValue doesn't exists.
const getUnsafeProperty = (dom, property)=>_impl_Style__WEBPACK_IMPORTED_MODULE_1__.isSupported(dom) ? dom.style.getPropertyValue(property) : '';
/*
 * Gets the raw value from the style attribute. Useful for retrieving "used values" from the DOM:
 * https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
 *
 * Returns NONE if the property isn't set, or the value is an empty string.
 */ const getRaw = (element, property)=>{
    const dom = element.dom;
    const raw = getUnsafeProperty(dom, property);
    return _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.Optional.from(raw).filter((r)=>r.length > 0);
};
const getAllRaw = (element)=>{
    const css = {};
    const dom = element.dom;
    if (_impl_Style__WEBPACK_IMPORTED_MODULE_1__.isSupported(dom)) {
        for(let i = 0; i < dom.style.length; i++){
            const ruleName = dom.style.item(i);
            css[ruleName] = dom.style[ruleName];
        }
    }
    return css;
};
const isValidValue = (tag, property, value)=>{
    const element = _node_SugarElement__WEBPACK_IMPORTED_MODULE_5__.SugarElement.fromTag(tag);
    set(element, property, value);
    const style = getRaw(element, property);
    return style.isSome();
};
const remove = (element, property)=>{
    const dom = element.dom;
    internalRemove(dom, property);
    if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_6__.is(_Attribute__WEBPACK_IMPORTED_MODULE_7__.getOpt(element, 'style').map(_ephox_katamari__WEBPACK_IMPORTED_MODULE_8__.trim), '')) {
        // No more styles left, remove the style attribute as well
        _Attribute__WEBPACK_IMPORTED_MODULE_7__.remove(element, 'style');
    }
};
const preserve = (element, f)=>{
    const oldStyles = _Attribute__WEBPACK_IMPORTED_MODULE_7__.get(element, 'style');
    const result = f(element);
    if (oldStyles === undefined) {
        _Attribute__WEBPACK_IMPORTED_MODULE_7__.remove(element, 'style');
    } else {
        _Attribute__WEBPACK_IMPORTED_MODULE_7__.set(element, 'style', oldStyles);
    }
    return result;
};
const copy = (source, target)=>{
    const sourceDom = source.dom;
    const targetDom = target.dom;
    if (_impl_Style__WEBPACK_IMPORTED_MODULE_1__.isSupported(sourceDom) && _impl_Style__WEBPACK_IMPORTED_MODULE_1__.isSupported(targetDom)) {
        targetDom.style.cssText = sourceDom.style.cssText;
    }
};
/* NOTE: This function is here for the side effect it triggers.
The value itself is not used.
Be sure to not use the return value, and that it is not removed by a minifier.
 */ const reflow = (e)=>e.dom.offsetWidth;
const transferOne = (source, destination, style)=>{
    getRaw(source, style).each((value)=>{
        // NOTE: We don't want to clobber any existing inline styles.
        if (getRaw(destination, style).isNone()) {
            set(destination, style, value);
        }
    });
};
const transfer = (source, destination, styles)=>{
    if (!_node_SugarNode__WEBPACK_IMPORTED_MODULE_9__.isElement(source) || !_node_SugarNode__WEBPACK_IMPORTED_MODULE_9__.isElement(destination)) {
        return;
    }
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_10__.each(styles, (style)=>{
        transferOne(source, destination, style);
    });
};



}),
"../sugar/src/main/ts/ephox/sugar/api/search/PredicateFilter.ts": 
/*!**********************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/search/PredicateFilter.ts ***!
  \**********************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  all: () => (all),
  ancestors: () => (ancestors),
  children: () => (children),
  descendants: () => (descendants),
  siblings: () => (siblings)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _node_SugarBody__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/SugarBody */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarBody.ts");
/* ESM import */var _Traverse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Traverse */ "../sugar/src/main/ts/ephox/sugar/api/search/Traverse.ts");



// maybe TraverseWith, similar to traverse but with a predicate?
const all = (predicate)=>descendants(_node_SugarBody__WEBPACK_IMPORTED_MODULE_0__.body(), predicate);
const ancestors = (scope, predicate, isRoot)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.filter(_Traverse__WEBPACK_IMPORTED_MODULE_2__.parents(scope, isRoot), predicate);
const siblings = (scope, predicate)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.filter(_Traverse__WEBPACK_IMPORTED_MODULE_2__.siblings(scope), predicate);
const children = (scope, predicate)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.filter(_Traverse__WEBPACK_IMPORTED_MODULE_2__.children(scope), predicate);
const descendants = (scope, predicate)=>{
    let result = [];
    // Recurse.toArray() might help here
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.each(_Traverse__WEBPACK_IMPORTED_MODULE_2__.children(scope), (x)=>{
        if (predicate(x)) {
            result = result.concat([
                x
            ]);
        }
        result = result.concat(descendants(x, predicate));
    });
    return result;
};



}),
"../sugar/src/main/ts/ephox/sugar/api/search/PredicateFind.ts": 
/*!********************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/search/PredicateFind.ts ***!
  \********************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ancestor: () => (ancestor),
  child: () => (child),
  closest: () => (closest),
  descendant: () => (descendant),
  first: () => (first),
  sibling: () => (sibling)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _impl_ClosestOrAncestor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../impl/ClosestOrAncestor */ "../sugar/src/main/ts/ephox/sugar/impl/ClosestOrAncestor.ts");
/* ESM import */var _dom_Compare__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom/Compare */ "../sugar/src/main/ts/ephox/sugar/api/dom/Compare.ts");
/* ESM import */var _node_SugarBody__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/SugarBody */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarBody.ts");
/* ESM import */var _node_SugarElement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../node/SugarElement */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");





const first = (predicate)=>descendant(_node_SugarBody__WEBPACK_IMPORTED_MODULE_0__.body(), predicate);
const ancestor = (scope, predicate, isRoot)=>{
    let element = scope.dom;
    const stop = _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.isFunction(isRoot) ? isRoot : _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.never;
    while(element.parentNode){
        element = element.parentNode;
        const el = _node_SugarElement__WEBPACK_IMPORTED_MODULE_3__.SugarElement.fromDom(element);
        if (predicate(el)) {
            return _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.Optional.some(el);
        } else if (stop(el)) {
            break;
        }
    }
    return _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.Optional.none();
};
const closest = (scope, predicate, isRoot)=>{
    // This is required to avoid ClosestOrAncestor passing the predicate to itself
    const is = (s, test)=>test(s);
    return (0,_impl_ClosestOrAncestor__WEBPACK_IMPORTED_MODULE_5__["default"])(is, ancestor, scope, predicate, isRoot);
};
const sibling = (scope, predicate)=>{
    const element = scope.dom;
    if (!element.parentNode) {
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.Optional.none();
    }
    return child(_node_SugarElement__WEBPACK_IMPORTED_MODULE_3__.SugarElement.fromDom(element.parentNode), (x)=>!_dom_Compare__WEBPACK_IMPORTED_MODULE_6__.eq(scope, x) && predicate(x));
};
const child = (scope, predicate)=>{
    const pred = (node)=>predicate(_node_SugarElement__WEBPACK_IMPORTED_MODULE_3__.SugarElement.fromDom(node));
    const result = _ephox_katamari__WEBPACK_IMPORTED_MODULE_7__.find(scope.dom.childNodes, pred);
    return result.map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_3__.SugarElement.fromDom);
};
const descendant = (scope, predicate)=>{
    const descend = (node)=>{
        // tslint:disable-next-line:prefer-for-of
        for(let i = 0; i < node.childNodes.length; i++){
            const child = _node_SugarElement__WEBPACK_IMPORTED_MODULE_3__.SugarElement.fromDom(node.childNodes[i]);
            if (predicate(child)) {
                return _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.Optional.some(child);
            }
            const res = descend(node.childNodes[i]);
            if (res.isSome()) {
                return res;
            }
        }
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.Optional.none();
    };
    return descend(scope.dom);
};



}),
"../sugar/src/main/ts/ephox/sugar/api/search/SelectorFilter.ts": 
/*!*********************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/search/SelectorFilter.ts ***!
  \*********************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  all: () => (all),
  ancestors: () => (ancestors),
  children: () => (children),
  descendants: () => (descendants),
  siblings: () => (siblings)
});
/* ESM import */var _PredicateFilter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PredicateFilter */ "../sugar/src/main/ts/ephox/sugar/api/search/PredicateFilter.ts");
/* ESM import */var _Selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Selectors */ "../sugar/src/main/ts/ephox/sugar/api/search/Selectors.ts");


const all = (selector)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.all(selector);
// For all of the following:
//
// jQuery does siblings of firstChild. IE9+ supports scope.dom.children (similar to Traverse.children but elements only).
// Traverse should also do this (but probably not by default).
//
const ancestors = (scope, selector, isRoot)=>// It may surprise you to learn this is exactly what JQuery does
    // TODO: Avoid all this wrapping and unwrapping
    _PredicateFilter__WEBPACK_IMPORTED_MODULE_1__.ancestors(scope, (e)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.is(e, selector), isRoot);
const siblings = (scope, selector)=>// It may surprise you to learn this is exactly what JQuery does
    // TODO: Avoid all the wrapping and unwrapping
    _PredicateFilter__WEBPACK_IMPORTED_MODULE_1__.siblings(scope, (e)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.is(e, selector));
const children = (scope, selector)=>// It may surprise you to learn this is exactly what JQuery does
    // TODO: Avoid all the wrapping and unwrapping
    _PredicateFilter__WEBPACK_IMPORTED_MODULE_1__.children(scope, (e)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.is(e, selector));
const descendants = (scope, selector)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.all(selector, scope);



}),
"../sugar/src/main/ts/ephox/sugar/api/search/SelectorFind.ts": 
/*!*******************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/search/SelectorFind.ts ***!
  \*******************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  ancestor: () => (ancestor),
  child: () => (child),
  closest: () => (closest),
  descendant: () => (descendant),
  first: () => (first),
  sibling: () => (sibling)
});
/* ESM import */var _impl_ClosestOrAncestor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../impl/ClosestOrAncestor */ "../sugar/src/main/ts/ephox/sugar/impl/ClosestOrAncestor.ts");
/* ESM import */var _PredicateFind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PredicateFind */ "../sugar/src/main/ts/ephox/sugar/api/search/PredicateFind.ts");
/* ESM import */var _Selectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Selectors */ "../sugar/src/main/ts/ephox/sugar/api/search/Selectors.ts");



// TODO: An internal SelectorFilter module that doesn't SugarElement.fromDom() everything
const first = (selector)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.one(selector);
const ancestor = (scope, selector, isRoot)=>_PredicateFind__WEBPACK_IMPORTED_MODULE_1__.ancestor(scope, (e)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.is(e, selector), isRoot);
const sibling = (scope, selector)=>_PredicateFind__WEBPACK_IMPORTED_MODULE_1__.sibling(scope, (e)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.is(e, selector));
const child = (scope, selector)=>_PredicateFind__WEBPACK_IMPORTED_MODULE_1__.child(scope, (e)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.is(e, selector));
const descendant = (scope, selector)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.one(selector, scope);
// Returns Some(closest ancestor element (sugared)) matching 'selector' up to isRoot, or None() otherwise
const closest = (scope, selector, isRoot)=>{
    const is = (element, selector)=>_Selectors__WEBPACK_IMPORTED_MODULE_0__.is(element, selector);
    return (0,_impl_ClosestOrAncestor__WEBPACK_IMPORTED_MODULE_2__["default"])(is, ancestor, scope, selector, isRoot);
};



}),
"../sugar/src/main/ts/ephox/sugar/api/search/Selectors.ts": 
/*!****************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/search/Selectors.ts ***!
  \****************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  all: () => (all),
  is: () => (is),
  one: () => (one)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _node_NodeTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/NodeTypes */ "../sugar/src/main/ts/ephox/sugar/api/node/NodeTypes.ts");
/* ESM import */var _node_SugarElement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node/SugarElement */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");



const is = (element, selector)=>{
    const dom = element.dom;
    if (dom.nodeType !== _node_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.ELEMENT) {
        return false;
    } else {
        const elem = dom;
        if (elem.matches !== undefined) {
            return elem.matches(selector);
        } else if (elem.msMatchesSelector !== undefined) {
            return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== undefined) {
            return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== undefined) {
            // cast to any as mozMatchesSelector doesn't exist in TS DOM lib
            return elem.mozMatchesSelector(selector);
        } else {
            throw new Error('Browser lacks native selectors');
        } // unfortunately we can't throw this on startup :(
    }
};
const bypassSelector = (dom)=>// Only elements, documents and shadow roots support querySelector
    // shadow root element type is DOCUMENT_FRAGMENT
    dom.nodeType !== _node_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.ELEMENT && dom.nodeType !== _node_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT && dom.nodeType !== _node_NodeTypes__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT_FRAGMENT || // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
    dom.childElementCount === 0;
const all = (selector, scope)=>{
    const base = scope === undefined ? document : scope.dom;
    return bypassSelector(base) ? [] : _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.map(base.querySelectorAll(selector), _node_SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom);
};
const one = (selector, scope)=>{
    const base = scope === undefined ? document : scope.dom;
    return bypassSelector(base) ? _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.Optional.none() : _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.Optional.from(base.querySelector(selector)).map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_2__.SugarElement.fromDom);
};



}),
"../sugar/src/main/ts/ephox/sugar/api/search/Traverse.ts": 
/*!***************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/api/search/Traverse.ts ***!
  \***************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  child: () => (child),
  childNodesCount: () => (childNodesCount),
  children: () => (children),
  defaultView: () => (defaultView),
  documentElement: () => (documentElement),
  documentOrOwner: () => (documentOrOwner),
  findIndex: () => (findIndex),
  firstChild: () => (firstChild),
  hasChildNodes: () => (hasChildNodes),
  lastChild: () => (lastChild),
  leaf: () => (leaf),
  nextSibling: () => (nextSibling),
  nextSiblings: () => (nextSiblings),
  offsetParent: () => (offsetParent),
  owner: () => (owner),
  parent: () => (parent),
  parentElement: () => (parentElement),
  parentNode: () => (parentNode),
  parents: () => (parents),
  prevSibling: () => (prevSibling),
  prevSiblings: () => (prevSiblings),
  siblings: () => (siblings)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Fun.ts");
/* ESM import */var _alien_Recurse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../alien/Recurse */ "../sugar/src/main/ts/ephox/sugar/alien/Recurse.ts");
/* ESM import */var _dom_Compare__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom/Compare */ "../sugar/src/main/ts/ephox/sugar/api/dom/Compare.ts");
/* ESM import */var _node_SugarElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/SugarElement */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");
/* ESM import */var _node_SugarNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/SugarNode */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarNode.ts");





/**
 * The document associated with the current element
 * NOTE: this will throw if the owner is null.
 */ const owner = (element)=>_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom(element.dom.ownerDocument);
/**
 * If the element is a document, return it. Otherwise, return its ownerDocument.
 * @param dos
 */ const documentOrOwner = (dos)=>_node_SugarNode__WEBPACK_IMPORTED_MODULE_1__.isDocument(dos) ? dos : owner(dos);
const documentElement = (element)=>_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
/**
 * The window element associated with the element
 * NOTE: this will throw if the defaultView is null.
 */ const defaultView = (element)=>_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
const parent = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.Optional.from(element.dom.parentNode).map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom);
// Cast down to just be SugarElement<Node>
const parentNode = (element)=>parent(element);
const parentElement = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.Optional.from(element.dom.parentElement).map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom);
const findIndex = (element)=>parent(element).bind((p)=>{
        // TODO: Refactor out children so we can avoid the constant unwrapping
        const kin = children(p);
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.findIndex(kin, (elem)=>_dom_Compare__WEBPACK_IMPORTED_MODULE_4__.eq(element, elem));
    });
const parents = (element, isRoot)=>{
    const stop = _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__.isFunction(isRoot) ? isRoot : _ephox_katamari__WEBPACK_IMPORTED_MODULE_6__.never;
    // This is used a *lot* so it needs to be performant, not recursive
    let dom = element.dom;
    const ret = [];
    while(dom.parentNode !== null && dom.parentNode !== undefined){
        const rawParent = dom.parentNode;
        const p = _node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop(p) === true) {
            break;
        } else {
            dom = rawParent;
        }
    }
    return ret;
};
const siblings = (element)=>{
    // TODO: Refactor out children so we can just not add self instead of filtering afterwards
    const filterSelf = (elements)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.filter(elements, (x)=>!_dom_Compare__WEBPACK_IMPORTED_MODULE_4__.eq(element, x));
    return parent(element).map(children).map(filterSelf).getOr([]);
};
const offsetParent = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.Optional.from(element.dom.offsetParent).map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom);
const prevSibling = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.Optional.from(element.dom.previousSibling).map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom);
const nextSibling = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.Optional.from(element.dom.nextSibling).map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom);
// This one needs to be reversed, so they're still in DOM order
const prevSiblings = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.reverse(_alien_Recurse__WEBPACK_IMPORTED_MODULE_7__.toArray(element, prevSibling));
const nextSiblings = (element)=>_alien_Recurse__WEBPACK_IMPORTED_MODULE_7__.toArray(element, nextSibling);
const children = (element)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.map(element.dom.childNodes, _node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom);
const child = (element, index)=>{
    const cs = element.dom.childNodes;
    return _ephox_katamari__WEBPACK_IMPORTED_MODULE_2__.Optional.from(cs[index]).map(_node_SugarElement__WEBPACK_IMPORTED_MODULE_0__.SugarElement.fromDom);
};
const firstChild = (element)=>child(element, 0);
const lastChild = (element)=>child(element, element.dom.childNodes.length - 1);
const childNodesCount = (element)=>element.dom.childNodes.length;
const hasChildNodes = (element)=>element.dom.hasChildNodes();
const spot = (element, offset)=>({
        element,
        offset
    });
const leaf = (element, offset)=>{
    const cs = children(element);
    return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);
};



}),
"../sugar/src/main/ts/ephox/sugar/impl/ClosestOrAncestor.ts": 
/*!******************************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/impl/ClosestOrAncestor.ts ***!
  \******************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");

/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((is, ancestor, scope, a, isRoot)=>{
    if (is(scope, a)) {
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.Optional.some(scope);
    } else if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.isFunction(isRoot) && isRoot(scope)) {
        return _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.Optional.none();
    } else {
        return ancestor(scope, a, isRoot);
    }
});


}),
"../sugar/src/main/ts/ephox/sugar/impl/NodeValue.ts": 
/*!**********************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/impl/NodeValue.ts ***!
  \**********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  NodeValue: () => (NodeValue)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");

const NodeValue = (is, name)=>{
    const get = (element)=>{
        if (!is(element)) {
            throw new Error('Can only get ' + name + ' value of a ' + name + ' node');
        }
        return getOption(element).getOr('');
    };
    const getOption = (element)=>is(element) ? _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.Optional.from(element.dom.nodeValue) : _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.Optional.none();
    const set = (element, value)=>{
        if (!is(element)) {
            throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');
        }
        element.dom.nodeValue = value;
    };
    return {
        get,
        getOption,
        set
    };
};


}),
"../sugar/src/main/ts/ephox/sugar/impl/Style.ts": 
/*!******************************************************!*\
  !*** ../sugar/src/main/ts/ephox/sugar/impl/Style.ts ***!
  \******************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  isSupported: () => (isSupported)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");

// some elements, such as mathml, don't have style attributes
// others, such as angular elements, have style attributes that aren't a CSSStyleDeclaration
const isSupported = (dom)=>dom.style !== undefined && _ephox_katamari__WEBPACK_IMPORTED_MODULE_0__.isFunction(dom.style.getPropertyValue);



}),
"./src/plugins/accordion/main/ts/Plugin.ts": 
/*!*************************************************!*\
  !*** ./src/plugins/accordion/main/ts/Plugin.ts ***!
  \*************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__WEBPACK_DEFAULT_EXPORT__)
});
/* ESM import */var tinymce_core_api_PluginManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinymce/core/api/PluginManager */ "./lib/globals/tinymce/core/api/PluginManager.js");
/* ESM import */var _api_Commands__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api/Commands */ "./src/plugins/accordion/main/ts/api/Commands.ts");
/* ESM import */var _core_content_FilterContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/content/FilterContent */ "./src/plugins/accordion/main/ts/core/content/FilterContent.ts");
/* ESM import */var _core_Keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/Keyboard */ "./src/plugins/accordion/main/ts/core/Keyboard.ts");
/* ESM import */var _core_Quirks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/Quirks */ "./src/plugins/accordion/main/ts/core/Quirks.ts");
/* ESM import */var _ui_Buttons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui/Buttons */ "./src/plugins/accordion/main/ts/ui/Buttons.ts");






/* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = (()=>{
    tinymce_core_api_PluginManager__WEBPACK_IMPORTED_MODULE_0__["default"].add('accordion', (editor)=>{
        _ui_Buttons__WEBPACK_IMPORTED_MODULE_5__.register(editor);
        _api_Commands__WEBPACK_IMPORTED_MODULE_1__.register(editor);
        _core_Keyboard__WEBPACK_IMPORTED_MODULE_3__.setup(editor);
        _core_content_FilterContent__WEBPACK_IMPORTED_MODULE_2__.setup(editor);
        _core_Quirks__WEBPACK_IMPORTED_MODULE_4__.setup(editor);
    });
});


}),
"./src/plugins/accordion/main/ts/api/Commands.ts": 
/*!*******************************************************!*\
  !*** ./src/plugins/accordion/main/ts/api/Commands.ts ***!
  \*******************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  register: () => (register)
});
/* ESM import */var _core_Actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Actions */ "./src/plugins/accordion/main/ts/core/Actions.ts");

const register = (editor)=>{
    editor.addCommand('InsertAccordion', ()=>_core_Actions__WEBPACK_IMPORTED_MODULE_0__.insertAccordion(editor));
    editor.addCommand('ToggleAccordion', (_ui, value)=>_core_Actions__WEBPACK_IMPORTED_MODULE_0__.toggleAccordion(editor, value));
    editor.addCommand('ToggleAllAccordions', (_ui, value)=>_core_Actions__WEBPACK_IMPORTED_MODULE_0__.toggleAllAccordions(editor, value));
    editor.addCommand('RemoveAccordion', ()=>_core_Actions__WEBPACK_IMPORTED_MODULE_0__.removeAccordion(editor));
};



}),
"./src/plugins/accordion/main/ts/api/Events.ts": 
/*!*****************************************************!*\
  !*** ./src/plugins/accordion/main/ts/api/Events.ts ***!
  \*****************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  fireToggleAccordionEvent: () => (fireToggleAccordionEvent),
  fireToggleAllAccordionsEvent: () => (fireToggleAllAccordionsEvent)
});
const fireToggleAccordionEvent = (editor, element, state)=>editor.dispatch('ToggledAccordion', {
        element,
        state
    });
const fireToggleAllAccordionsEvent = (editor, elements, state)=>editor.dispatch('ToggledAllAccordions', {
        elements,
        state
    });


}),
"./src/plugins/accordion/main/ts/api/Options.ts": 
/*!******************************************************!*\
  !*** ./src/plugins/accordion/main/ts/api/Options.ts ***!
  \******************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  isDisabled: () => (isDisabled)
});
const option = (name)=>(editor)=>editor.options.get(name);
const isDisabled = option('disabled');



}),
"./src/plugins/accordion/main/ts/core/Actions.ts": 
/*!*******************************************************!*\
  !*** ./src/plugins/accordion/main/ts/core/Actions.ts ***!
  \*******************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  insertAccordion: () => (insertAccordion),
  removeAccordion: () => (removeAccordion),
  toggleAccordion: () => (toggleAccordion),
  toggleAllAccordions: () => (toggleAllAccordions)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Id.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _ephox_phoenix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ephox/phoenix */ "../phoenix/src/main/ts/ephox/phoenix/api/dom/DomDescent.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/node/SugarElement.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/search/SelectorFind.ts");
/* ESM import */var _ephox_sugar__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ephox/sugar */ "../sugar/src/main/ts/ephox/sugar/api/properties/Attribute.ts");
/* ESM import */var _api_Events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api/Events */ "./src/plugins/accordion/main/ts/api/Events.ts");
/* ESM import */var _api_Options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../api/Options */ "./src/plugins/accordion/main/ts/api/Options.ts");
/* ESM import */var _Identifiers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Identifiers */ "./src/plugins/accordion/main/ts/core/Identifiers.ts");
/* ESM import */var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ "./src/plugins/accordion/main/ts/core/Utils.ts");







const insertAccordion = (editor)=>{
    if (!_Utils__WEBPACK_IMPORTED_MODULE_3__.isInsertAllowed(editor)) {
        return;
    }
    const editorBody = _ephox_sugar__WEBPACK_IMPORTED_MODULE_4__.SugarElement.fromDom(editor.getBody());
    const uid = _ephox_katamari__WEBPACK_IMPORTED_MODULE_5__.generate('acc');
    const summaryText = editor.dom.encode(editor.selection.getRng().toString() || editor.translate('Accordion summary...'));
    const bodyText = editor.dom.encode(editor.translate('Accordion body...'));
    const accordionSummaryHtml = `<summary class="${_Identifiers__WEBPACK_IMPORTED_MODULE_2__.accordionSummaryClass}">${summaryText}</summary>`;
    const accordionBodyHtml = `<${_Identifiers__WEBPACK_IMPORTED_MODULE_2__.accordionBodyWrapperTag} class="${_Identifiers__WEBPACK_IMPORTED_MODULE_2__.accordionBodyWrapperClass}"><p>${bodyText}</p></${_Identifiers__WEBPACK_IMPORTED_MODULE_2__.accordionBodyWrapperTag}>`;
    editor.undoManager.transact(()=>{
        editor.insertContent([
            `<details data-mce-id="${uid}" class="${_Identifiers__WEBPACK_IMPORTED_MODULE_2__.accordionDetailsClass}" open="open">`,
            accordionSummaryHtml,
            accordionBodyHtml,
            `</details>`
        ].join(''));
        _ephox_sugar__WEBPACK_IMPORTED_MODULE_6__.descendant(editorBody, `[data-mce-id="${uid}"]`).each((detailsElm)=>{
            _ephox_sugar__WEBPACK_IMPORTED_MODULE_7__.remove(detailsElm, 'data-mce-id');
            _ephox_sugar__WEBPACK_IMPORTED_MODULE_6__.descendant(detailsElm, `summary`).each((summaryElm)=>{
                // Set the cursor location to be at the end of the summary text
                const rng = editor.dom.createRng();
                const des = _ephox_phoenix__WEBPACK_IMPORTED_MODULE_8__.freefallRtl(summaryElm);
                rng.setStart(des.element.dom, des.offset);
                rng.setEnd(des.element.dom, des.offset);
                editor.selection.setRng(rng);
            });
        });
    });
};
const toggleDetailsElement = (isReadonly, details, state)=>{
    const shouldOpen = state ?? !_Utils__WEBPACK_IMPORTED_MODULE_3__.isOpen(details);
    if (!isReadonly) {
        details.setAttribute(_Identifiers__WEBPACK_IMPORTED_MODULE_2__.accordionReadonlyCompensationAttribute, shouldOpen ? 'open' : 'closed');
    }
    if (shouldOpen) {
        details.setAttribute('open', 'open');
    } else {
        details.removeAttribute('open');
    }
    return shouldOpen;
};
const toggleAccordion = (editor, state)=>{
    if (_api_Options__WEBPACK_IMPORTED_MODULE_1__.isDisabled(editor)) {
        return;
    }
    _Utils__WEBPACK_IMPORTED_MODULE_3__.getSelectedDetails(editor).each((details)=>{
        _api_Events__WEBPACK_IMPORTED_MODULE_0__.fireToggleAccordionEvent(editor, details, toggleDetailsElement(editor.readonly, details, state));
    });
};
const removeAccordion = (editor)=>{
    if (!editor.mode.isReadOnly()) {
        _Utils__WEBPACK_IMPORTED_MODULE_3__.getSelectedDetails(editor).each((details)=>{
            const { nextSibling } = details;
            if (nextSibling) {
                editor.selection.select(nextSibling, true);
                editor.selection.collapse(true);
            } else {
                _Utils__WEBPACK_IMPORTED_MODULE_3__.insertAndSelectParagraphAfter(editor, details);
            }
            details.remove();
        });
    }
};
const toggleAllAccordions = (editor, state)=>{
    const accordions = Array.from(editor.getBody().querySelectorAll('details'));
    if (accordions.length === 0) {
        return;
    }
    _ephox_katamari__WEBPACK_IMPORTED_MODULE_9__.each(accordions, (accordion)=>toggleDetailsElement(editor.readonly, accordion, state ?? !_Utils__WEBPACK_IMPORTED_MODULE_3__.isOpen(accordion)));
    _api_Events__WEBPACK_IMPORTED_MODULE_0__.fireToggleAllAccordionsEvent(editor, accordions, state);
};



}),
"./src/plugins/accordion/main/ts/core/Identifiers.ts": 
/*!***********************************************************!*\
  !*** ./src/plugins/accordion/main/ts/core/Identifiers.ts ***!
  \***********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  accordionBodyWrapperClass: () => (accordionBodyWrapperClass),
  accordionBodyWrapperTag: () => (accordionBodyWrapperTag),
  accordionDetailsClass: () => (accordionDetailsClass),
  accordionReadonlyCompensationAttribute: () => (accordionReadonlyCompensationAttribute),
  accordionSummaryClass: () => (accordionSummaryClass),
  accordionTag: () => (accordionTag)
});
const accordionTag = 'details';
const accordionDetailsClass = 'mce-accordion';
const accordionSummaryClass = 'mce-accordion-summary';
const accordionBodyWrapperClass = 'mce-accordion-body';
const accordionBodyWrapperTag = 'div';
const accordionReadonlyCompensationAttribute = 'data-mce-accordion-open';



}),
"./src/plugins/accordion/main/ts/core/Keyboard.ts": 
/*!********************************************************!*\
  !*** ./src/plugins/accordion/main/ts/core/Keyboard.ts ***!
  \********************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  setup: () => (setup)
});
/* ESM import */var tinymce_core_api_util_VK__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinymce/core/api/util/VK */ "./lib/globals/tinymce/core/api/util/VK.js");
/* ESM import */var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./src/plugins/accordion/main/ts/core/Utils.ts");


const setupEnterKeyInSummary = (editor)=>{
    editor.on('keydown', (event)=>{
        if (!event.shiftKey && event.keyCode === tinymce_core_api_util_VK__WEBPACK_IMPORTED_MODULE_0__["default"].ENTER && _Utils__WEBPACK_IMPORTED_MODULE_1__.isInSummary(editor) || _Utils__WEBPACK_IMPORTED_MODULE_1__.isAtDetailsStart(editor)) {
            event.preventDefault();
            editor.execCommand('ToggleAccordion');
        }
    });
};
const setup = (editor)=>{
    setupEnterKeyInSummary(editor);
    editor.on('ExecCommand', (e)=>{
        const cmd = e.command.toLowerCase();
        if ((cmd === 'delete' || cmd === 'forwarddelete') && _Utils__WEBPACK_IMPORTED_MODULE_1__.isDetailsSelected(editor)) {
            _Utils__WEBPACK_IMPORTED_MODULE_1__.normalizeDetails(editor);
        }
    });
};



}),
"./src/plugins/accordion/main/ts/core/Quirks.ts": 
/*!******************************************************!*\
  !*** ./src/plugins/accordion/main/ts/core/Quirks.ts ***!
  \******************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  setup: () => (setup)
});
/* ESM import */var tinymce_core_api_Env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinymce/core/api/Env */ "./lib/globals/tinymce/core/api/Env.js");
/* ESM import */var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./src/plugins/accordion/main/ts/core/Utils.ts");


const setup = (editor)=>{
    // TINY-10177: On Safari, clicking on the expand arrow of the `details` element sets the selection before the `summary`,
    // so we override the selection to the beginning of `summary` content
    if (tinymce_core_api_Env__WEBPACK_IMPORTED_MODULE_0__["default"].browser.isSafari()) {
        editor.on('click', (e)=>{
            if (_Utils__WEBPACK_IMPORTED_MODULE_1__.isSummary(e.target)) {
                const summary = e.target;
                const rng = editor.selection.getRng();
                if (rng.collapsed && rng.startContainer === summary.parentNode && rng.startOffset === 0) {
                    editor.selection.setCursorLocation(summary, 0);
                }
            }
        });
    }
};



}),
"./src/plugins/accordion/main/ts/core/Utils.ts": 
/*!*****************************************************!*\
  !*** ./src/plugins/accordion/main/ts/core/Utils.ts ***!
  \*****************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  createParagraph: () => (createParagraph),
  createSummary: () => (createSummary),
  getSelectedDetails: () => (getSelectedDetails),
  insertAndSelectParagraphAfter: () => (insertAndSelectParagraphAfter),
  insertBogus: () => (insertBogus),
  isAtDetailsStart: () => (isAtDetailsStart),
  isDetails: () => (isDetails),
  isDetailsSelected: () => (isDetailsSelected),
  isInSummary: () => (isInSummary),
  isInsertAllowed: () => (isInsertAllowed),
  isOpen: () => (isOpen),
  isSummary: () => (isSummary),
  normalizeAccordion: () => (normalizeAccordion),
  normalizeContent: () => (normalizeContent),
  normalizeDetails: () => (normalizeDetails),
  normalizeSummary: () => (normalizeSummary)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Optional.ts");
/* ESM import */var tinymce_core_api_util_Tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinymce/core/api/util/Tools */ "./lib/globals/tinymce/core/api/util/Tools.js");


const isSummary = (node)=>node?.nodeName === 'SUMMARY';
const isDetails = (node)=>node?.nodeName === 'DETAILS';
const isOpen = (details)=>details.hasAttribute('open');
const isInSummary = (editor)=>{
    const node = editor.selection.getNode();
    return isSummary(node) || Boolean(editor.dom.getParent(node, isSummary));
};
const isAtDetailsStart = (editor)=>{
    const rng = editor.selection.getRng();
    return isDetails(rng.startContainer) && rng.collapsed && rng.startOffset === 0;
};
const isInsertAllowed = (editor)=>!isInSummary(editor) && editor.dom.isEditable(editor.selection.getNode()) && !editor.mode.isReadOnly();
const getSelectedDetails = (editor)=>_ephox_katamari__WEBPACK_IMPORTED_MODULE_1__.Optional.from(editor.dom.getParent(editor.selection.getNode(), isDetails));
const isDetailsSelected = (editor)=>getSelectedDetails(editor).isSome();
const insertBogus = (element)=>{
    element.innerHTML = '<br data-mce-bogus="1" />';
    return element;
};
const createParagraph = (editor)=>insertBogus(editor.dom.create('p'));
const createSummary = (editor)=>insertBogus(editor.dom.create('summary'));
const insertAndSelectParagraphAfter = (editor, target)=>{
    const paragraph = createParagraph(editor);
    target.insertAdjacentElement('afterend', paragraph);
    editor.selection.setCursorLocation(paragraph, 0);
};
const normalizeContent = (editor, accordion)=>{
    if (isSummary(accordion?.lastChild)) {
        const paragraph = createParagraph(editor);
        accordion.appendChild(paragraph);
        editor.selection.setCursorLocation(paragraph, 0);
    }
};
const normalizeSummary = (editor, accordion)=>{
    if (!isSummary(accordion?.firstChild)) {
        const summary = createSummary(editor);
        accordion.prepend(summary);
        editor.selection.setCursorLocation(summary, 0);
    }
};
const normalizeAccordion = (editor)=>(accordion)=>{
        normalizeContent(editor, accordion);
        normalizeSummary(editor, accordion);
    };
const normalizeDetails = (editor)=>{
    tinymce_core_api_util_Tools__WEBPACK_IMPORTED_MODULE_0__["default"].each(tinymce_core_api_util_Tools__WEBPACK_IMPORTED_MODULE_0__["default"].grep(editor.dom.select('details', editor.getBody())), normalizeAccordion(editor));
};


}),
"./src/plugins/accordion/main/ts/core/content/FilterContent.ts": 
/*!*********************************************************************!*\
  !*** ./src/plugins/accordion/main/ts/core/content/FilterContent.ts ***!
  \*********************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  setup: () => (setup)
});
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Arr.ts");
/* ESM import */var _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ephox/katamari */ "../katamari/src/main/ts/ephox/katamari/api/Type.ts");
/* ESM import */var tinymce_core_api_html_Node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tinymce/core/api/html/Node */ "./lib/globals/tinymce/core/api/html/Node.js");
/* ESM import */var _Identifiers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Identifiers */ "./src/plugins/accordion/main/ts/core/Identifiers.ts");
/* ESM import */var _Normalize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Normalize */ "./src/plugins/accordion/main/ts/core/content/Normalize.ts");




const getClassList = (node)=>node.attr('class')?.split(' ') ?? [];
const addClasses = (node, classes)=>{
    const classListSet = new Set([
        ...getClassList(node),
        ...classes
    ]);
    const newClassList = Array.from(classListSet);
    if (newClassList.length > 0) {
        node.attr('class', newClassList.join(' '));
    }
};
const removeClasses = (node, classes)=>{
    const newClassList = _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.filter(getClassList(node), (clazz)=>!classes.has(clazz));
    node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);
};
const isAccordionDetailsNode = (node)=>node.name === _Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionTag && _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.contains(getClassList(node), _Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionDetailsClass);
const isAccordionBodyWrapperNode = (node)=>node.name === _Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionBodyWrapperTag && _ephox_katamari__WEBPACK_IMPORTED_MODULE_3__.contains(getClassList(node), _Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionBodyWrapperClass);
const getAccordionChildren = (accordionNode)=>{
    const children = accordionNode.children();
    let summaryNode;
    let wrapperNode;
    const otherNodes = [];
    for(let i = 0; i < children.length; i++){
        const child = children[i];
        // Only want to get the first summary element
        if (child.name === 'summary' && _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNullable(summaryNode)) {
            summaryNode = child;
        } else if (isAccordionBodyWrapperNode(child) && _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNullable(wrapperNode)) {
            wrapperNode = child;
        } else {
            otherNodes.push(child);
        }
    }
    return {
        summaryNode,
        wrapperNode,
        otherNodes
    };
};
const padInputNode = (node)=>{
    // Add br to node to ensure the cursor can be placed inside the node
    // Mark as bogus so that it is converted to an nbsp on serialization
    const br = new tinymce_core_api_html_Node__WEBPACK_IMPORTED_MODULE_0__["default"]('br', 1);
    br.attr('data-mce-bogus', '1');
    node.empty();
    node.append(br);
};
const setup = (editor)=>{
    editor.on('PreInit', ()=>{
        const { serializer, parser } = editor;
        // Purpose:
        // - add mce-accordion-summary class to summary node
        // - wrap details body in div and add mce-accordion-body class (TINY-9959 assists with Chrome selection issue)
        // - Normalize accordion 'open' attribute value to open="open"
        parser.addNodeFilter(_Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionTag, (nodes)=>{
            // Using a traditional for loop here as we may have to iterate over many nodes and it is the most performant way of doing so
            for(let i = 0; i < nodes.length; i++){
                const node = nodes[i];
                _Normalize__WEBPACK_IMPORTED_MODULE_2__.normalizeOpenAttribute(node);
                if (isAccordionDetailsNode(node)) {
                    const accordionNode = node;
                    accordionNode.attr(_Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionReadonlyCompensationAttribute, accordionNode.attr('open') === 'open' ? 'open' : 'closed');
                    const { summaryNode, wrapperNode, otherNodes } = getAccordionChildren(accordionNode);
                    const hasSummaryNode = _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNonNullable(summaryNode);
                    const newSummaryNode = hasSummaryNode ? summaryNode : new tinymce_core_api_html_Node__WEBPACK_IMPORTED_MODULE_0__["default"]('summary', 1);
                    // If there is nothing in the summary, pad it with a br
                    // so the cursor can be put inside the accordion summary
                    if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNullable(newSummaryNode.firstChild)) {
                        padInputNode(newSummaryNode);
                    }
                    addClasses(newSummaryNode, [
                        _Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionSummaryClass
                    ]);
                    if (!hasSummaryNode) {
                        if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNonNullable(accordionNode.firstChild)) {
                            accordionNode.insert(newSummaryNode, accordionNode.firstChild, true);
                        } else {
                            accordionNode.append(newSummaryNode);
                        }
                    }
                    const hasWrapperNode = _ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNonNullable(wrapperNode);
                    const newWrapperNode = hasWrapperNode ? wrapperNode : new tinymce_core_api_html_Node__WEBPACK_IMPORTED_MODULE_0__["default"](_Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionBodyWrapperTag, 1);
                    newWrapperNode.attr('data-mce-bogus', '1');
                    addClasses(newWrapperNode, [
                        _Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionBodyWrapperClass
                    ]);
                    if (otherNodes.length > 0) {
                        for(let j = 0; j < otherNodes.length; j++){
                            const otherNode = otherNodes[j];
                            newWrapperNode.append(otherNode);
                        }
                    }
                    // If there is nothing in the wrapper, append a placeholder p tag
                    // so the cursor can be put inside the accordion body
                    if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNullable(newWrapperNode.firstChild)) {
                        const pNode = new tinymce_core_api_html_Node__WEBPACK_IMPORTED_MODULE_0__["default"]('p', 1);
                        padInputNode(pNode);
                        newWrapperNode.append(pNode);
                    }
                    if (!hasWrapperNode) {
                        accordionNode.append(newWrapperNode);
                    }
                }
            }
        });
        // Purpose:
        // - remove div wrapping details content as it is only required during editor (see TINY-9959 for details)
        // - remove mce-accordion-summary class on the summary node
        serializer.addNodeFilter(_Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionTag, (nodes)=>{
            const summaryClassRemoveSet = new Set([
                _Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionSummaryClass
            ]);
            // Using a traditional for loop here as we may have to iterate over many nodes and it is the most performant way of doing so
            for(let i = 0; i < nodes.length; i++){
                const node = nodes[i];
                if (isAccordionDetailsNode(node)) {
                    const accordionNode = node;
                    accordionNode.attr('open', accordionNode.attr(_Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionReadonlyCompensationAttribute) === 'open' ? 'open' : null);
                    accordionNode.attr(_Identifiers__WEBPACK_IMPORTED_MODULE_1__.accordionReadonlyCompensationAttribute, null);
                    const { summaryNode, wrapperNode } = getAccordionChildren(accordionNode);
                    if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNonNullable(summaryNode)) {
                        removeClasses(summaryNode, summaryClassRemoveSet);
                    }
                    if (_ephox_katamari__WEBPACK_IMPORTED_MODULE_4__.isNonNullable(wrapperNode)) {
                        wrapperNode.unwrap();
                    }
                }
            }
        });
    });
};



}),
"./src/plugins/accordion/main/ts/core/content/Normalize.ts": 
/*!*****************************************************************!*\
  !*** ./src/plugins/accordion/main/ts/core/content/Normalize.ts ***!
  \*****************************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  normalizeOpenAttribute: () => (normalizeOpenAttribute)
});
const normalizeOpenAttribute = (node)=>{
    if (hasAttribute(node, 'open')) {
        setAttribute(node, 'open', 'open');
    }
};
const hasAttribute = (node, attribute)=>node.attr(attribute) !== undefined;
const setAttribute = (node, attribute, value)=>{
    node.attr(attribute, value);
};



}),
"./src/plugins/accordion/main/ts/ui/Buttons.ts": 
/*!*****************************************************!*\
  !*** ./src/plugins/accordion/main/ts/ui/Buttons.ts ***!
  \*****************************************************/
(function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  register: () => (register)
});
/* ESM import */var _core_Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Utils */ "./src/plugins/accordion/main/ts/core/Utils.ts");

const onSetup = (editor)=>(buttonApi)=>{
        const onNodeChange = ()=>buttonApi.setEnabled(_core_Utils__WEBPACK_IMPORTED_MODULE_0__.isInsertAllowed(editor));
        editor.on('NodeChange', onNodeChange);
        return ()=>editor.off('NodeChange', onNodeChange);
    };
const register = (editor)=>{
    const onAction = ()=>editor.execCommand('InsertAccordion');
    editor.ui.registry.addButton('accordion', {
        icon: 'accordion',
        tooltip: 'Insert accordion',
        onSetup: onSetup(editor),
        onAction
    });
    editor.ui.registry.addMenuItem('accordion', {
        icon: 'accordion',
        text: 'Accordion',
        onSetup: onSetup(editor),
        onAction
    });
    editor.ui.registry.addToggleButton('accordiontoggle', {
        icon: 'accordion-toggle',
        tooltip: 'Toggle accordion',
        onAction: ()=>editor.execCommand('ToggleAccordion'),
        context: 'any'
    });
    editor.ui.registry.addToggleButton('accordionremove', {
        icon: 'remove',
        tooltip: 'Delete accordion',
        onAction: ()=>editor.execCommand('RemoveAccordion')
    });
    editor.ui.registry.addContextToolbar('accordion', {
        predicate: (accordion)=>editor.dom.is(accordion, 'details') && editor.getBody().contains(accordion) && editor.dom.isEditable(accordion.parentNode),
        items: 'accordiontoggle accordionremove',
        scope: 'node',
        position: 'node'
    });
};



}),
"../../node_modules/@ephox/dispute/lib/main/ts/api/Eq.js": 
/*!***************************************************************!*\
  !*** ../../node_modules/@ephox/dispute/lib/main/ts/api/Eq.js ***!
  \***************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  contramap: () => (contramap),
  eq: () => (eq),
  eqAny: () => (eqAny),
  eqArray: () => (eqArray),
  eqBoolean: () => (eqBoolean),
  eqNull: () => (eqNull),
  eqNumber: () => (eqNumber),
  eqRecord: () => (eqRecord),
  eqString: () => (eqString),
  eqUndefined: () => (eqUndefined),
  tripleEq: () => (tripleEq)
});
/* ESM import */var _core_Type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Type */ "../../node_modules/@ephox/dispute/lib/main/ts/core/Type.js");
/* ESM import */var _core_ArrayUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ArrayUtil */ "../../node_modules/@ephox/dispute/lib/main/ts/core/ArrayUtil.js");


var contramap = function (eqa, f) {
    return eq(function (x, y) { return eqa.eq(f(x), f(y)); });
};
var eq = function (f) {
    return ({ eq: f });
};
var tripleEq = eq(function (x, y) { return x === y; });
var eqString = tripleEq;
var eqBoolean = tripleEq;
var eqNumber = tripleEq;
var eqUndefined = tripleEq;
var eqNull = tripleEq;
var eqArray = function (eqa) { return eq(function (x, y) {
    if (x.length !== y.length) {
        return false;
    }
    var len = x.length;
    for (var i = 0; i < len; i++) {
        if (!eqa.eq(x[i], y[i])) {
            return false;
        }
    }
    return true;
}); };
// TODO: Make an Ord typeclass
var eqSortedArray = function (eqa, compareFn) {
    return contramap(eqArray(eqa), function (xs) { return _core_ArrayUtil__WEBPACK_IMPORTED_MODULE_0__.sort(xs, compareFn); });
};
var eqRecord = function (eqa) { return eq(function (x, y) {
    var kx = Object.keys(x);
    var ky = Object.keys(y);
    if (!eqSortedArray(eqString).eq(kx, ky)) {
        return false;
    }
    var len = kx.length;
    for (var i = 0; i < len; i++) {
        var q = kx[i];
        if (!eqa.eq(x[q], y[q])) {
            return false;
        }
    }
    return true;
}); };
var eqAny = eq(function (x, y) {
    if (x === y) {
        return true;
    }
    var tx = _core_Type__WEBPACK_IMPORTED_MODULE_1__.typeOf(x);
    var ty = _core_Type__WEBPACK_IMPORTED_MODULE_1__.typeOf(y);
    if (tx !== ty) {
        return false;
    }
    if (_core_Type__WEBPACK_IMPORTED_MODULE_1__.isEquatableType(tx)) {
        return x === y;
    }
    else if (tx === 'array') {
        return eqArray(eqAny).eq(x, y);
    }
    else if (tx === 'object') {
        return eqRecord(eqAny).eq(x, y);
    }
    return false;
});


}),
"../../node_modules/@ephox/dispute/lib/main/ts/core/ArrayUtil.js": 
/*!***********************************************************************!*\
  !*** ../../node_modules/@ephox/dispute/lib/main/ts/core/ArrayUtil.js ***!
  \***********************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  map: () => (map),
  mapDelimit: () => (mapDelimit),
  sort: () => (sort)
});
var map = function (xs, f) {
    var len = xs.length;
    var r = new Array(len);
    for (var i = 0; i < len; i++) {
        var x = xs[i];
        r[i] = f(x);
    }
    return r;
};
/** map a function over an array, then map another function over every item except the last */
var mapDelimit = function (xs, f, delimit) {
    var len = xs.length;
    var r = new Array(len);
    for (var i = 0; i < len - 1; i++) {
        var x = xs[i];
        r[i] = delimit(f(x));
    }
    if (len > 0) {
        r[len - 1] = (f(xs[len - 1]));
    }
    return r;
};
var sort = function (xs, compareFn) {
    var clone = Array.prototype.slice.call(xs);
    return clone.sort(compareFn);
};


}),
"../../node_modules/@ephox/dispute/lib/main/ts/core/Type.js": 
/*!******************************************************************!*\
  !*** ../../node_modules/@ephox/dispute/lib/main/ts/core/Type.js ***!
  \******************************************************************/
(function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  isArray: () => (isArray),
  isBoolean: () => (isBoolean),
  isEquatableType: () => (isEquatableType),
  isFunction: () => (isFunction),
  isNull: () => (isNull),
  isNumber: () => (isNumber),
  isObject: () => (isObject),
  isString: () => (isString),
  isUndefined: () => (isUndefined),
  typeOf: () => (typeOf)
});
var typeOf = function (x) {
    if (x === null) {
        return 'null';
    }
    if (x === undefined) {
        return 'undefined';
    }
    var t = typeof x;
    if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {
        return 'array';
    }
    if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {
        return 'string';
    }
    return t;
};
var isType = function (type) { return function (value) { return typeOf(value) === type; }; };
var isString = isType('string');
var isObject = isType('object');
var isArray = isType('array');
var isNull = isType('null');
var isBoolean = isType('boolean');
var isUndefined = isType('undefined');
var isFunction = isType('function');
var isNumber = isType('number');
var isEquatableType = function (x) {
    return ['undefined', 'boolean', 'number', 'string', 'function', 'xml', 'null'].indexOf(x) !== -1;
};


}),

});
/************************************************************************/
// The module cache
var __webpack_module_cache__ = {};

// The require function
function __webpack_require__(moduleId) {

// Check if module is in cache
var cachedModule = __webpack_module_cache__[moduleId];
if (cachedModule !== undefined) {
return cachedModule.exports;
}
// Create a new module (and put it into the cache)
var module = (__webpack_module_cache__[moduleId] = {
exports: {}
});
// Execute the module function
__webpack_modules__[moduleId](module, module.exports, __webpack_require__);

// Return the exports of the module
return module.exports;

}

/************************************************************************/
// webpack/runtime/define_property_getters
(() => {
__webpack_require__.d = (exports, definition) => {
	for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        }
    }
};
})();
// webpack/runtime/has_own_property
(() => {
__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
})();
// webpack/runtime/make_namespace_object
(() => {
// define __esModule on exports
__webpack_require__.r = (exports) => {
	if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
		Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
	}
	Object.defineProperty(exports, '__esModule', { value: true });
};
})();
// webpack/runtime/rspack_version
(() => {
__webpack_require__.rv = () => ("1.5.2")
})();
// webpack/runtime/rspack_unique_id
(() => {
__webpack_require__.ruid = "bundler=rspack@1.5.2";

})();
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {

/*!***********************************************!*\
  !*** ./src/plugins/accordion/main/ts/Main.ts ***!
  \***********************************************/
__webpack_require__.r(__webpack_exports__);
/* ESM import */var _Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Plugin */ "./src/plugins/accordion/main/ts/Plugin.ts");

(0,_Plugin__WEBPACK_IMPORTED_MODULE_0__["default"])(); /** *****
 * DO NOT EXPORT ANYTHING
 *
 * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE
 *******/ 

})();

})()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMvdGlueW1jZS9wbHVnaW5zL2FjY29yZGlvbi9wbHVnaW4uanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW55bWNlLy4vbGliL2dsb2JhbHMvdGlueW1jZS9jb3JlL2FwaS9FbnYuanMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL2xpYi9nbG9iYWxzL3RpbnltY2UvY29yZS9hcGkvUGx1Z2luTWFuYWdlci5qcyIsIndlYnBhY2s6Ly90aW55bWNlLy4vbGliL2dsb2JhbHMvdGlueW1jZS9jb3JlL2FwaS9odG1sL05vZGUuanMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL2xpYi9nbG9iYWxzL3RpbnltY2UvY29yZS9hcGkvdXRpbC9Ub29scy5qcyIsIndlYnBhY2s6Ly90aW55bWNlLy4vbGliL2dsb2JhbHMvdGlueW1jZS9jb3JlL2FwaS91dGlsL1ZLLmpzIiwid2VicGFjazovL3RpbnltY2UvLi4vYm9zcy9zcmMvbWFpbi90cy9lcGhveC9ib3NzL2FwaS9Eb21Vbml2ZXJzZS50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL2Jvc3Mvc3JjL21haW4vdHMvZXBob3gvYm9zcy9jb21tb24vVGFnQm91bmRhcmllcy50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL2thdGFtYXJpL3NyYy9tYWluL3RzL2VwaG94L2thdGFtYXJpL2FwaS9BcnIudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9rYXRhbWFyaS9zcmMvbWFpbi90cy9lcGhveC9rYXRhbWFyaS9hcGkvRnVuLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4va2F0YW1hcmkvc3JjL21haW4vdHMvZXBob3gva2F0YW1hcmkvYXBpL0dsb2JhbC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL2thdGFtYXJpL3NyYy9tYWluL3RzL2VwaG94L2thdGFtYXJpL2FwaS9JZC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL2thdGFtYXJpL3NyYy9tYWluL3RzL2VwaG94L2thdGFtYXJpL2FwaS9OdW0udHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9rYXRhbWFyaS9zcmMvbWFpbi90cy9lcGhveC9rYXRhbWFyaS9hcGkvT2JqLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4va2F0YW1hcmkvc3JjL21haW4vdHMvZXBob3gva2F0YW1hcmkvYXBpL09wdGlvbmFsLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4va2F0YW1hcmkvc3JjL21haW4vdHMvZXBob3gva2F0YW1hcmkvYXBpL09wdGlvbmFscy50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL2thdGFtYXJpL3NyYy9tYWluL3RzL2VwaG94L2thdGFtYXJpL2FwaS9SZXNvbHZlLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4va2F0YW1hcmkvc3JjL21haW4vdHMvZXBob3gva2F0YW1hcmkvYXBpL1N0cmluZ3MudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9rYXRhbWFyaS9zcmMvbWFpbi90cy9lcGhveC9rYXRhbWFyaS9hcGkvVHlwZS50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL2thdGFtYXJpL3NyYy9tYWluL3RzL2VwaG94L2thdGFtYXJpL3N0ci9TdHJBcHBlbmQudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9rYXRhbWFyaS9zcmMvbWFpbi90cy9lcGhveC9rYXRhbWFyaS91dGlsL0lkVXRpbHMudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9waG9lbml4L3NyYy9tYWluL3RzL2VwaG94L3Bob2VuaXgvYXBpL2RhdGEvU3BvdC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3Bob2VuaXgvc3JjL21haW4vdHMvZXBob3gvcGhvZW5peC9hcGkvZG9tL0RvbURlc2NlbnQudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9waG9lbml4L3NyYy9tYWluL3RzL2VwaG94L3Bob2VuaXgvYXBpL2dlbmVyYWwvRGVzY2VudC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3Bob2VuaXgvc3JjL21haW4vdHMvZXBob3gvcGhvZW5peC93cmFwL05hdmlnYXRpb24udHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zYW5kL3NyYy9tYWluL3RzL2VwaG94L3NhbmQvYXBpL1NhbmRIVE1MRWxlbWVudC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3NhbmQvc3JjL21haW4vdHMvZXBob3gvc2FuZC91dGlsL0dsb2JhbC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2FsaWVuL1JlY3Vyc2UudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvZG9tL0NvbXBhcmUudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvZG9tL0luc2VydC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2FwaS9kb20vSW5zZXJ0QWxsLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4vc3VnYXIvc3JjL21haW4vdHMvZXBob3gvc3VnYXIvYXBpL2RvbS9SZW1vdmUudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvbm9kZS9Ob2RlVHlwZXMudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvbm9kZS9TdWdhckJvZHkudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvbm9kZS9TdWdhckVsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvbm9kZS9TdWdhckhlYWQudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvbm9kZS9TdWdhck5vZGUudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvbm9kZS9TdWdhclNoYWRvd0RvbS50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2FwaS9ub2RlL1N1Z2FyVGV4dC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2FwaS9wcm9wZXJ0aWVzL0F0dHJpYnV0ZS50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2FwaS9wcm9wZXJ0aWVzL0Nzcy50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2FwaS9zZWFyY2gvUHJlZGljYXRlRmlsdGVyLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4vc3VnYXIvc3JjL21haW4vdHMvZXBob3gvc3VnYXIvYXBpL3NlYXJjaC9QcmVkaWNhdGVGaW5kLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4vc3VnYXIvc3JjL21haW4vdHMvZXBob3gvc3VnYXIvYXBpL3NlYXJjaC9TZWxlY3RvckZpbHRlci50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2FwaS9zZWFyY2gvU2VsZWN0b3JGaW5kLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4vc3VnYXIvc3JjL21haW4vdHMvZXBob3gvc3VnYXIvYXBpL3NlYXJjaC9TZWxlY3RvcnMudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi9zdWdhci9zcmMvbWFpbi90cy9lcGhveC9zdWdhci9hcGkvc2VhcmNoL1RyYXZlcnNlLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4vc3VnYXIvc3JjL21haW4vdHMvZXBob3gvc3VnYXIvaW1wbC9DbG9zZXN0T3JBbmNlc3Rvci50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uL3N1Z2FyL3NyYy9tYWluL3RzL2VwaG94L3N1Z2FyL2ltcGwvTm9kZVZhbHVlLnRzIiwid2VicGFjazovL3RpbnltY2UvLi4vc3VnYXIvc3JjL21haW4vdHMvZXBob3gvc3VnYXIvaW1wbC9TdHlsZS50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4vc3JjL3BsdWdpbnMvYWNjb3JkaW9uL21haW4vdHMvUGx1Z2luLnRzIiwid2VicGFjazovL3RpbnltY2UvLi9zcmMvcGx1Z2lucy9hY2NvcmRpb24vbWFpbi90cy9hcGkvQ29tbWFuZHMudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL3NyYy9wbHVnaW5zL2FjY29yZGlvbi9tYWluL3RzL2FwaS9FdmVudHMudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL3NyYy9wbHVnaW5zL2FjY29yZGlvbi9tYWluL3RzL2FwaS9PcHRpb25zLnRzIiwid2VicGFjazovL3RpbnltY2UvLi9zcmMvcGx1Z2lucy9hY2NvcmRpb24vbWFpbi90cy9jb3JlL0FjdGlvbnMudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL3NyYy9wbHVnaW5zL2FjY29yZGlvbi9tYWluL3RzL2NvcmUvSWRlbnRpZmllcnMudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL3NyYy9wbHVnaW5zL2FjY29yZGlvbi9tYWluL3RzL2NvcmUvS2V5Ym9hcmQudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL3NyYy9wbHVnaW5zL2FjY29yZGlvbi9tYWluL3RzL2NvcmUvUXVpcmtzLnRzIiwid2VicGFjazovL3RpbnltY2UvLi9zcmMvcGx1Z2lucy9hY2NvcmRpb24vbWFpbi90cy9jb3JlL1V0aWxzLnRzIiwid2VicGFjazovL3RpbnltY2UvLi9zcmMvcGx1Z2lucy9hY2NvcmRpb24vbWFpbi90cy9jb3JlL2NvbnRlbnQvRmlsdGVyQ29udGVudC50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4vc3JjL3BsdWdpbnMvYWNjb3JkaW9uL21haW4vdHMvY29yZS9jb250ZW50L05vcm1hbGl6ZS50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4vc3JjL3BsdWdpbnMvYWNjb3JkaW9uL21haW4vdHMvdWkvQnV0dG9ucy50cyIsIndlYnBhY2s6Ly90aW55bWNlLy4uLy4uL25vZGVfbW9kdWxlcy9AZXBob3gvZGlzcHV0ZS9zcmMvbWFpbi90cy9hcGkvRXEudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi8uLi9ub2RlX21vZHVsZXMvQGVwaG94L2Rpc3B1dGUvc3JjL21haW4vdHMvY29yZS9BcnJheVV0aWwudHMiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uLi8uLi9ub2RlX21vZHVsZXMvQGVwaG94L2Rpc3B1dGUvc3JjL21haW4vdHMvY29yZS9UeXBlLnRzIiwid2VicGFjazovL3RpbnltY2Uvd2VicGFjay9ydW50aW1lL2RlZmluZV9wcm9wZXJ0eV9nZXR0ZXJzIiwid2VicGFjazovL3RpbnltY2Uvd2VicGFjay9ydW50aW1lL2hhc19vd25fcHJvcGVydHkiLCJ3ZWJwYWNrOi8vdGlueW1jZS93ZWJwYWNrL3J1bnRpbWUvbWFrZV9uYW1lc3BhY2Vfb2JqZWN0Iiwid2VicGFjazovL3RpbnltY2Uvd2VicGFjay9ydW50aW1lL3JzcGFja192ZXJzaW9uIiwid2VicGFjazovL3RpbnltY2Uvd2VicGFjay9ydW50aW1lL3JzcGFja191bmlxdWVfaWQiLCJ3ZWJwYWNrOi8vdGlueW1jZS8uL3NyYy9wbHVnaW5zL2FjY29yZGlvbi9tYWluL3RzL01haW4udHMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHRpbnltY2UudXRpbC5Ub29scy5yZXNvbHZlKCd0aW55bWNlLkVudicpO1xuXG5leHBvcnQgZGVmYXVsdCBnbG9iYWw7XG5leHBvcnQgdmFyIEVudiA9IGdsb2JhbDtcbiIsInZhciBnbG9iYWwgPSB0aW55bWNlLnV0aWwuVG9vbHMucmVzb2x2ZSgndGlueW1jZS5QbHVnaW5NYW5hZ2VyJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbDtcbmV4cG9ydCB2YXIgUGx1Z2luTWFuYWdlciA9IGdsb2JhbDtcbiIsInZhciBnbG9iYWwgPSB0aW55bWNlLnV0aWwuVG9vbHMucmVzb2x2ZSgndGlueW1jZS5odG1sLk5vZGUnKTtcblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFsO1xuZXhwb3J0IHZhciBOb2RlID0gZ2xvYmFsO1xuIiwidmFyIGdsb2JhbCA9IHRpbnltY2UudXRpbC5Ub29scy5yZXNvbHZlKCd0aW55bWNlLnV0aWwuVG9vbHMnKTtcblxuZXhwb3J0IGRlZmF1bHQgZ2xvYmFsO1xuZXhwb3J0IHZhciBUb29scyA9IGdsb2JhbDtcbiIsInZhciBnbG9iYWwgPSB0aW55bWNlLnV0aWwuVG9vbHMucmVzb2x2ZSgndGlueW1jZS51dGlsLlZLJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGdsb2JhbDtcbmV4cG9ydCB2YXIgVksgPSBnbG9iYWw7XG4iLCJpbXBvcnQgeyBBcnIsIEZ1biwgT3B0aW9uYWwgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuaW1wb3J0IHtcbiAgQXR0cmlidXRlLCBDb21wYXJlLCBDc3MsIEluc2VydCwgSW5zZXJ0QWxsLCBQcmVkaWNhdGVGaWx0ZXIsIFByZWRpY2F0ZUZpbmQsIFJlbW92ZSwgU2VsZWN0b3JGaWx0ZXIsIFNlbGVjdG9yRmluZCwgU3VnYXJFbGVtZW50LCBTdWdhck5vZGUsXG4gIFN1Z2FyVGV4dCwgVHJhdmVyc2Vcbn0gZnJvbSAnQGVwaG94L3N1Z2FyJztcblxuaW1wb3J0IFRhZ0JvdW5kYXJpZXMgZnJvbSAnLi4vY29tbW9uL1RhZ0JvdW5kYXJpZXMnO1xuXG5pbXBvcnQgdHlwZSB7IFVuaXZlcnNlIH0gZnJvbSAnLi9Vbml2ZXJzZSc7XG5cbmV4cG9ydCBkZWZhdWx0ICgpOiBVbml2ZXJzZTxTdWdhckVsZW1lbnQsIERvY3VtZW50PiA9PiB7XG4gIGNvbnN0IGNsb25lID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4ge1xuICAgIHJldHVybiBTdWdhckVsZW1lbnQuZnJvbURvbShlbGVtZW50LmRvbS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgfTtcblxuICBjb25zdCBkb2N1bWVudCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IFRyYXZlcnNlLmRvY3VtZW50T3JPd25lcihlbGVtZW50KS5kb207XG5cbiAgY29uc3QgaXNCb3VuZGFyeSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQpID0+IHtcbiAgICBpZiAoIVN1Z2FyTm9kZS5pc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKFN1Z2FyTm9kZS5uYW1lKGVsZW1lbnQpID09PSAnYm9keScpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gQXJyLmNvbnRhaW5zKFRhZ0JvdW5kYXJpZXMsIFN1Z2FyTm9kZS5uYW1lKGVsZW1lbnQpKTtcbiAgfTtcblxuICBjb25zdCBpc0VtcHR5VGFnID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudCkgPT4ge1xuICAgIGlmICghU3VnYXJOb2RlLmlzRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gQXJyLmNvbnRhaW5zKFsgJ2JyJywgJ2ltZycsICdocicsICdpbnB1dCcgXSwgU3VnYXJOb2RlLm5hbWUoZWxlbWVudCkpO1xuICB9O1xuXG4gIGNvbnN0IGlzTm9uRWRpdGFibGUgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50KSA9PiBTdWdhck5vZGUuaXNFbGVtZW50KGVsZW1lbnQpICYmIEF0dHJpYnV0ZS5nZXQoZWxlbWVudCwgJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnO1xuXG4gIGNvbnN0IGNvbXBhcmVQb3NpdGlvbiA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIG90aGVyOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IHtcbiAgICByZXR1cm4gZWxlbWVudC5kb20uY29tcGFyZURvY3VtZW50UG9zaXRpb24ob3RoZXIuZG9tKTtcbiAgfTtcblxuICBjb25zdCBjb3B5QXR0cmlidXRlc1RvID0gKHNvdXJjZTogU3VnYXJFbGVtZW50LCBkZXN0aW5hdGlvbjogU3VnYXJFbGVtZW50KSA9PiB7XG4gICAgY29uc3QgYXMgPSBBdHRyaWJ1dGUuY2xvbmUoc291cmNlKTtcbiAgICBBdHRyaWJ1dGUuc2V0QWxsKGRlc3RpbmF0aW9uLCBhcyk7XG4gIH07XG5cbiAgY29uc3QgaXNTcGVjaWFsID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4ge1xuICAgIGNvbnN0IHRhZyA9IFN1Z2FyTm9kZS5uYW1lKGVsZW1lbnQpO1xuICAgIHJldHVybiBBcnIuY29udGFpbnMoW1xuICAgICAgJ3NjcmlwdCcsICdub3NjcmlwdCcsICdpZnJhbWUnLCAnbm9mcmFtZXMnLCAnbm9lbWJlZCcsICd0aXRsZScsICdzdHlsZScsICd0ZXh0YXJlYScsICd4bXAnXG4gICAgXSwgdGFnKTtcbiAgfTtcblxuICBjb25zdCBnZXRMYW5ndWFnZSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBPcHRpb25hbDxzdHJpbmc+ID0+XG4gICAgU3VnYXJOb2RlLmlzRWxlbWVudChlbGVtZW50KSA/IEF0dHJpYnV0ZS5nZXRPcHQoZWxlbWVudCwgJ2xhbmcnKSA6IE9wdGlvbmFsLm5vbmUoKTtcblxuICByZXR1cm4ge1xuICAgIHVwOiBGdW4uY29uc3RhbnQoe1xuICAgICAgc2VsZWN0b3I6IFNlbGVjdG9yRmluZC5hbmNlc3RvcixcbiAgICAgIGNsb3Nlc3Q6IFNlbGVjdG9yRmluZC5jbG9zZXN0LFxuICAgICAgcHJlZGljYXRlOiBQcmVkaWNhdGVGaW5kLmFuY2VzdG9yLFxuICAgICAgYWxsOiBUcmF2ZXJzZS5wYXJlbnRzXG4gICAgfSksXG4gICAgZG93bjogRnVuLmNvbnN0YW50KHtcbiAgICAgIHNlbGVjdG9yOiBTZWxlY3RvckZpbHRlci5kZXNjZW5kYW50cyxcbiAgICAgIHByZWRpY2F0ZTogUHJlZGljYXRlRmlsdGVyLmRlc2NlbmRhbnRzXG4gICAgfSksXG4gICAgc3R5bGVzOiBGdW4uY29uc3RhbnQoe1xuICAgICAgZ2V0OiBDc3MuZ2V0LFxuICAgICAgZ2V0UmF3OiBDc3MuZ2V0UmF3LFxuICAgICAgc2V0OiBDc3Muc2V0LFxuICAgICAgcmVtb3ZlOiBDc3MucmVtb3ZlXG4gICAgfSksXG4gICAgYXR0cnM6IEZ1bi5jb25zdGFudCh7XG4gICAgICBnZXQ6IEF0dHJpYnV0ZS5nZXQsXG4gICAgICBzZXQ6IEF0dHJpYnV0ZS5zZXQsXG4gICAgICByZW1vdmU6IEF0dHJpYnV0ZS5yZW1vdmUsXG4gICAgICBjb3B5VG86IGNvcHlBdHRyaWJ1dGVzVG9cbiAgICB9KSxcbiAgICBpbnNlcnQ6IEZ1bi5jb25zdGFudCh7XG4gICAgICBiZWZvcmU6IEluc2VydC5iZWZvcmUsXG4gICAgICBhZnRlcjogSW5zZXJ0LmFmdGVyLFxuICAgICAgYWZ0ZXJBbGw6IEluc2VydEFsbC5hZnRlcixcbiAgICAgIGFwcGVuZDogSW5zZXJ0LmFwcGVuZCxcbiAgICAgIGFwcGVuZEFsbDogSW5zZXJ0QWxsLmFwcGVuZCxcbiAgICAgIHByZXBlbmQ6IEluc2VydC5wcmVwZW5kLFxuICAgICAgd3JhcDogSW5zZXJ0LndyYXBcbiAgICB9KSxcbiAgICByZW1vdmU6IEZ1bi5jb25zdGFudCh7XG4gICAgICB1bndyYXA6IFJlbW92ZS51bndyYXAsXG4gICAgICByZW1vdmU6IFJlbW92ZS5yZW1vdmVcbiAgICB9KSxcbiAgICBjcmVhdGU6IEZ1bi5jb25zdGFudCh7XG4gICAgICBudTogU3VnYXJFbGVtZW50LmZyb21UYWcsXG4gICAgICBjbG9uZSxcbiAgICAgIHRleHQ6IFN1Z2FyRWxlbWVudC5mcm9tVGV4dFxuICAgIH0pLFxuICAgIHF1ZXJ5OiBGdW4uY29uc3RhbnQoe1xuICAgICAgY29tcGFyZVBvc2l0aW9uLFxuICAgICAgcHJldlNpYmxpbmc6IFRyYXZlcnNlLnByZXZTaWJsaW5nLFxuICAgICAgbmV4dFNpYmxpbmc6IFRyYXZlcnNlLm5leHRTaWJsaW5nXG4gICAgfSksXG4gICAgcHJvcGVydHk6IEZ1bi5jb25zdGFudCh7XG4gICAgICBjaGlsZHJlbjogVHJhdmVyc2UuY2hpbGRyZW4sXG4gICAgICBuYW1lOiBTdWdhck5vZGUubmFtZSxcbiAgICAgIHBhcmVudDogVHJhdmVyc2UucGFyZW50LFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBpc1RleHQ6IFN1Z2FyTm9kZS5pc1RleHQsXG4gICAgICBpc0NvbW1lbnQ6IFN1Z2FyTm9kZS5pc0NvbW1lbnQsXG4gICAgICBpc0VsZW1lbnQ6IFN1Z2FyTm9kZS5pc0VsZW1lbnQsXG4gICAgICBpc1NwZWNpYWwsXG4gICAgICBnZXRMYW5ndWFnZSxcbiAgICAgIGdldFRleHQ6IFN1Z2FyVGV4dC5nZXQsXG4gICAgICBzZXRUZXh0OiBTdWdhclRleHQuc2V0LFxuICAgICAgaXNCb3VuZGFyeSxcbiAgICAgIGlzRW1wdHlUYWcsXG4gICAgICBpc05vbkVkaXRhYmxlXG4gICAgfSksXG4gICAgZXE6IENvbXBhcmUuZXEsXG4gICAgaXM6IENvbXBhcmUuaXNcbiAgfTtcbn07XG4iLCJcbmV4cG9ydCBkZWZhdWx0IFtcbiAgJ2JvZHknLFxuICAncCcsXG4gICdkaXYnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdmaWdjYXB0aW9uJyxcbiAgJ2ZpZ3VyZScsXG4gICdmb290ZXInLFxuICAnaGVhZGVyJyxcbiAgJ25hdicsXG4gICdzZWN0aW9uJyxcbiAgJ29sJyxcbiAgJ3VsJyxcbiAgJ2xpJyxcbiAgJ3RhYmxlJyxcbiAgJ3RoZWFkJyxcbiAgJ3Rib2R5JyxcbiAgJ3Rmb290JyxcbiAgJ2NhcHRpb24nLFxuICAndHInLFxuICAndGQnLFxuICAndGgnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnYmxvY2txdW90ZScsXG4gICdwcmUnLFxuICAnYWRkcmVzcydcbl07XG4iLCJpbXBvcnQgeyBFcSB9IGZyb20gJ0BlcGhveC9kaXNwdXRlJztcblxuaW1wb3J0ICogYXMgRnVuIGZyb20gJy4vRnVuJztcbmltcG9ydCB7IE9wdGlvbmFsIH0gZnJvbSAnLi9PcHRpb25hbCc7XG5pbXBvcnQgKiBhcyBUeXBlIGZyb20gJy4vVHlwZSc7XG5cbnR5cGUgQXJyYXlNb3JwaGlzbTxULCBVPiA9ICh4OiBULCBpOiBudW1iZXIpID0+IFU7XG50eXBlIEFycmF5R3VhcmRQcmVkaWNhdGU8VCwgVSBleHRlbmRzIFQ+ID0gKHg6IFQsIGk6IG51bWJlcikgPT4geCBpcyBVO1xudHlwZSBBcnJheVByZWRpY2F0ZTxUPiA9IEFycmF5TW9ycGhpc208VCwgYm9vbGVhbj47XG50eXBlIENvbXBhcmF0b3I8VD4gPSAoYTogVCwgYjogVCkgPT4gbnVtYmVyO1xuXG5jb25zdCBuYXRpdmVTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbmNvbnN0IG5hdGl2ZUluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbmNvbnN0IG5hdGl2ZVB1c2ggPSBBcnJheS5wcm90b3R5cGUucHVzaDtcblxuY29uc3QgcmF3SW5kZXhPZiA9IDxUPiAodHM6IEFycmF5TGlrZTxUPiwgdDogVCk6IG51bWJlciA9PlxuICBuYXRpdmVJbmRleE9mLmNhbGwodHMsIHQpO1xuXG5leHBvcnQgY29uc3QgaW5kZXhPZiA9IDxUID0gYW55Pih4czogQXJyYXlMaWtlPFQ+LCB4OiBUKTogT3B0aW9uYWw8bnVtYmVyPiA9PiB7XG4gIC8vIFRoZSByYXdJbmRleE9mIG1ldGhvZCBkb2VzIG5vdCB3cmFwIHVwIGluIGFuIG9wdGlvbi4gVGhpcyBpcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgY29uc3QgciA9IHJhd0luZGV4T2YoeHMsIHgpO1xuICByZXR1cm4gciA9PT0gLTEgPyBPcHRpb25hbC5ub25lKCkgOiBPcHRpb25hbC5zb21lKHIpO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvbnRhaW5zID0gPFQ+KHhzOiBBcnJheUxpa2U8VD4sIHg6IFQpOiBib29sZWFuID0+IHJhd0luZGV4T2YoeHMsIHgpID4gLTE7XG5cbmV4cG9ydCBjb25zdCBleGlzdHMgPSA8VCA9IGFueT4oeHM6IEFycmF5TGlrZTxUPiwgcHJlZDogQXJyYXlQcmVkaWNhdGU8VD4pOiBib29sZWFuID0+IHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgeCA9IHhzW2ldO1xuICAgIGlmIChwcmVkKHgsIGkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY29uc3QgcmFuZ2UgPSA8VD4obnVtOiBudW1iZXIsIGY6IChhOiBudW1iZXIpID0+IFQpOiBUW10gPT4ge1xuICBjb25zdCByOiBUW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgIHIucHVzaChmKGkpKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8vIEl0J3MgYSB0b3RhbCBtaWNybyBvcHRpbWlzYXRpb24sIGJ1dCB0aGVzZSBkbyBtYWtlIHNvbWUgZGlmZmVyZW5jZS5cbi8vIFBhcnRpY3VsYXJseSBmb3IgYnJvd3NlcnMgb3RoZXIgdGhhbiBDaHJvbWUuXG4vLyAtIGxlbmd0aCBjYWNoaW5nXG4vLyBodHRwOi8vanNwZXJmLmNvbS9icm93c2VyLWRpZXQtanF1ZXJ5LWVhY2gtdnMtZm9yLWxvb3AvNjlcbi8vIC0gbm90IHVzaW5nIHB1c2hcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5LWRpcmVjdC1hc3NpZ25tZW50LXZzLXB1c2gvMlxuXG5leHBvcnQgY29uc3QgY2h1bmsgPSA8VD4oYXJyYXk6IEFycmF5TGlrZTxUPiwgc2l6ZTogbnVtYmVyKTogVFtdW10gPT4ge1xuICBjb25zdCByOiBUW11bXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBzaXplKSB7XG4gICAgY29uc3QgczogVFtdID0gbmF0aXZlU2xpY2UuY2FsbChhcnJheSwgaSwgaSArIHNpemUpO1xuICAgIHIucHVzaChzKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXAgPSA8VCA9IGFueSwgVSA9IGFueT4oeHM6IEFycmF5TGlrZTxUPiwgZjogQXJyYXlNb3JwaGlzbTxULCBVPik6IFVbXSA9PiB7XG4gIC8vIHByZS1hbGxvY2F0aW5nIGFycmF5IHNpemUgd2hlbiBpdCdzIGd1YXJhbnRlZWQgdG8gYmUga25vd25cbiAgLy8gaHR0cDovL2pzcGVyZi5jb20vcHVzaC1hbGxvY2F0ZWQtdnMtZHluYW1pYy8yMlxuICBjb25zdCBsZW4gPSB4cy5sZW5ndGg7XG4gIGNvbnN0IHIgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICByW2ldID0gZih4LCBpKTtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8vIFVud291bmQgaW1wbGVtZW50aW5nIG90aGVyIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBlYWNoLlxuLy8gVGhlIGNvZGUgc2l6ZSBpcyByb3VnaGx5IHRoZSBzYW1lLCBhbmQgaXQgc2hvdWxkIGFsbG93IGZvciBiZXR0ZXIgb3B0aW1pc2F0aW9uLlxuLy8gY29uc3QgZWFjaCA9IGZ1bmN0aW9uPFQsIFU+KHhzOiBUW10sIGY6ICh4OiBULCBpPzogbnVtYmVyLCB4cz86IFRbXSkgPT4gdm9pZCk6IHZvaWQge1xuZXhwb3J0IGNvbnN0IGVhY2ggPSA8VCA9IGFueT4oeHM6IEFycmF5TGlrZTxUPiwgZjogQXJyYXlNb3JwaGlzbTxULCB2b2lkPik6IHZvaWQgPT4ge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCB4ID0geHNbaV07XG4gICAgZih4LCBpKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGVhY2hyID0gPFQ+KHhzOiBBcnJheUxpa2U8VD4sIGY6IEFycmF5TW9ycGhpc208VCwgdm9pZD4pOiB2b2lkID0+IHtcbiAgZm9yIChsZXQgaSA9IHhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgeCA9IHhzW2ldO1xuICAgIGYoeCwgaSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJ0aXRpb24gPSA8VCA9IGFueT4oeHM6IEFycmF5TGlrZTxUPiwgcHJlZDogQXJyYXlQcmVkaWNhdGU8VD4pOiB7IHBhc3M6IFRbXTsgZmFpbDogVFtdIH0gPT4ge1xuICBjb25zdCBwYXNzOiBUW10gPSBbXTtcbiAgY29uc3QgZmFpbDogVFtdID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICBjb25zdCBhcnIgPSBwcmVkKHgsIGkpID8gcGFzcyA6IGZhaWw7XG4gICAgYXJyLnB1c2goeCk7XG4gIH1cbiAgcmV0dXJuIHsgcGFzcywgZmFpbCB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbHRlcjoge1xuICA8VCwgVSBleHRlbmRzIFQ+KHhzOiBBcnJheUxpa2U8VD4sIHByZWQ6IEFycmF5R3VhcmRQcmVkaWNhdGU8VCwgVT4pOiBVW107XG4gIDxUPih4czogQXJyYXlMaWtlPFQ+LCBwcmVkOiBBcnJheVByZWRpY2F0ZTxUPik6IFRbXTtcbn0gPSA8VD4oeHM6IEFycmF5TGlrZTxUPiwgcHJlZDogQXJyYXlQcmVkaWNhdGU8VD4pOiBUW10gPT4ge1xuICBjb25zdCByOiBUW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgeCA9IHhzW2ldO1xuICAgIGlmIChwcmVkKHgsIGkpKSB7XG4gICAgICByLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLypcbiAqIEdyb3VwcyBhbiBhcnJheSBpbnRvIGNvbnRpZ3VvdXMgYXJyYXlzIG9mIGxpa2UgZWxlbWVudHMuIFdoZXRoZXIgYW4gZWxlbWVudCBpcyBsaWtlIG9yIG5vdCBkZXBlbmRzIG9uIGYuXG4gKlxuICogZiBpcyBhIGZ1bmN0aW9uIHRoYXQgZGVyaXZlcyBhIHZhbHVlIGZyb20gYW4gZWxlbWVudCAtIGUuZy4gdHJ1ZSBvciBmYWxzZSwgb3IgYSBzdHJpbmcuXG4gKiBFbGVtZW50cyBhcmUgbGlrZSBpZiB0aGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyB0aGUgc2FtZSB2YWx1ZSBmb3IgdGhlbSAoYWNjb3JkaW5nIHRvID09PSkuXG4gKlxuICpcbiAqIE9yZGVyIG9mIHRoZSBlbGVtZW50cyBpcyBwcmVzZXJ2ZWQuIEFyci5mbGF0dGVuKCkgb24gdGhlIHJlc3VsdCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgbGlzdCwgYXMgd2l0aCBIYXNrZWxsIGdyb3VwQnkgZnVuY3Rpb24uXG4gKiAgRm9yIGEgZ29vZCBleHBsYW5hdGlvbiwgc2VlIHRoZSBncm91cCBmdW5jdGlvbiAod2hpY2ggaXMgYSBzcGVjaWFsIGNhc2Ugb2YgZ3JvdXBCeSlcbiAqICBodHRwOi8vaGFja2FnZS5oYXNrZWxsLm9yZy9wYWNrYWdlL2Jhc2UtNC43LjAuMC9kb2NzL0RhdGEtTGlzdC5odG1sI3Y6Z3JvdXBcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwQnkgPSA8VD4oeHM6IEFycmF5TGlrZTxUPiwgZjogKGE6IFQpID0+IGFueSk6IFRbXVtdID0+IHtcbiAgaWYgKHhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgd2FzVHlwZSA9IGYoeHNbMF0pOyAvLyBpbml0aWFsIGNhc2UgZm9yIG1hdGNoaW5nXG4gICAgY29uc3QgcjogVFtdW10gPSBbXTtcbiAgICBsZXQgZ3JvdXA6IFRbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB4ID0geHNbaV07XG4gICAgICBjb25zdCB0eXBlID0gZih4KTtcbiAgICAgIGlmICh0eXBlICE9PSB3YXNUeXBlKSB7XG4gICAgICAgIHIucHVzaChncm91cCk7XG4gICAgICAgIGdyb3VwID0gW107XG4gICAgICB9XG4gICAgICB3YXNUeXBlID0gdHlwZTtcbiAgICAgIGdyb3VwLnB1c2goeCk7XG4gICAgfVxuICAgIGlmIChncm91cC5sZW5ndGggIT09IDApIHtcbiAgICAgIHIucHVzaChncm91cCk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZm9sZHIgPSA8VCwgVT4oeHM6IEFycmF5TGlrZTxUPiwgZjogKGFjYzogVSwgeDogVCwgaTogbnVtYmVyKSA9PiBVLCBhY2M6IFUpOiBVID0+IHtcbiAgZWFjaHIoeHMsICh4LCBpKSA9PiB7XG4gICAgYWNjID0gZihhY2MsIHgsIGkpO1xuICB9KTtcbiAgcmV0dXJuIGFjYztcbn07XG5cbmV4cG9ydCBjb25zdCBmb2xkbCA9IDxUID0gYW55LCBVID0gYW55Pih4czogQXJyYXlMaWtlPFQ+LCBmOiAoYWNjOiBVLCB4OiBULCBpOiBudW1iZXIpID0+IFUsIGFjYzogVSk6IFUgPT4ge1xuICBlYWNoKHhzLCAoeCwgaSkgPT4ge1xuICAgIGFjYyA9IGYoYWNjLCB4LCBpKTtcbiAgfSk7XG4gIHJldHVybiBhY2M7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZFVudGlsOiB7XG4gIDxULCBVIGV4dGVuZHMgVD4oeHM6IEFycmF5TGlrZTxUPiwgcHJlZDogQXJyYXlHdWFyZFByZWRpY2F0ZTxULCBVPiwgdW50aWw6IEFycmF5UHJlZGljYXRlPFQ+KTogT3B0aW9uYWw8VT47XG4gIDxUID0gYW55Pih4czogQXJyYXlMaWtlPFQ+LCBwcmVkOiBBcnJheVByZWRpY2F0ZTxUPiwgdW50aWw6IEFycmF5UHJlZGljYXRlPFQ+KTogT3B0aW9uYWw8VD47XG59ID0gPFQ+KHhzOiBBcnJheUxpa2U8VD4sIHByZWQ6IEFycmF5UHJlZGljYXRlPFQ+LCB1bnRpbDogQXJyYXlQcmVkaWNhdGU8VD4pOiBPcHRpb25hbDxUPiA9PiB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICBpZiAocHJlZCh4LCBpKSkge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoeCk7XG4gICAgfSBlbHNlIGlmICh1bnRpbCh4LCBpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZDoge1xuICA8VCwgVSBleHRlbmRzIFQ+KHhzOiBBcnJheUxpa2U8VD4sIHByZWQ6IEFycmF5R3VhcmRQcmVkaWNhdGU8VCwgVT4pOiBPcHRpb25hbDxVPjtcbiAgPFQgPSBhbnk+KHhzOiBBcnJheUxpa2U8VD4sIHByZWQ6IEFycmF5UHJlZGljYXRlPFQ+KTogT3B0aW9uYWw8VD47XG59ID0gPFQ+KHhzOiBBcnJheUxpa2U8VD4sIHByZWQ6IEFycmF5UHJlZGljYXRlPFQ+KTogT3B0aW9uYWw8VD4gPT4ge1xuICByZXR1cm4gZmluZFVudGlsKHhzLCBwcmVkLCBGdW4ubmV2ZXIpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbmRJbmRleCA9IDxUPih4czogQXJyYXlMaWtlPFQ+LCBwcmVkOiBBcnJheVByZWRpY2F0ZTxUPik6IE9wdGlvbmFsPG51bWJlcj4gPT4ge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCB4ID0geHNbaV07XG4gICAgaWYgKHByZWQoeCwgaSkpIHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZExhc3RJbmRleCA9IDxUPihhcnI6IEFycmF5TGlrZTxUPiwgcHJlZDogQXJyYXlQcmVkaWNhdGU8VD4pOiBPcHRpb25hbDxudW1iZXI+ID0+IHtcbiAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChwcmVkKGFycltpXSwgaSkpIHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG59O1xuXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IDxUPih4czogQXJyYXlMaWtlPFRbXT4pOiBUW10gPT4ge1xuICAvLyBOb3RlLCB0aGlzIGlzIHBvc3NpYmxlIGJlY2F1c2UgcHVzaCBzdXBwb3J0cyBtdWx0aXBsZSBhcmd1bWVudHM6XG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2NvbmNhdC1wdXNoLzZcbiAgLy8gTm90ZSB0aGF0IGluIHRoZSBwYXN0LCBjb25jYXQoKSB3b3VsZCBzaWxlbnRseSB3b3JrICh2ZXJ5IHNsb3dseSkgZm9yIGFycmF5LWxpa2Ugb2JqZWN0cy5cbiAgLy8gV2l0aCB0aGlzIGNoYW5nZSBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuICBjb25zdCByOiBUW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgZWFjaCB2YWx1ZSBpcyBhbiBhcnJheSBpdHNlbGZcbiAgICBpZiAoIVR5cGUuaXNBcnJheSh4c1tpXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXJyLmZsYXR0ZW4gaXRlbSAnICsgaSArICcgd2FzIG5vdCBhbiBhcnJheSwgaW5wdXQ6ICcgKyB4cyk7XG4gICAgfVxuICAgIG5hdGl2ZVB1c2guYXBwbHkociwgeHNbaV0pO1xuICB9XG4gIHJldHVybiByO1xufTtcblxuZXhwb3J0IGNvbnN0IGJpbmQgPSA8VCA9IGFueSwgVSA9IGFueT4oeHM6IEFycmF5TGlrZTxUPiwgZjogQXJyYXlNb3JwaGlzbTxULCBVW10+KTogVVtdID0+XG4gIGZsYXR0ZW4obWFwKHhzLCBmKSk7XG5cbmV4cG9ydCBjb25zdCBmb3JhbGwgPSA8VD4oeHM6IEFycmF5TGlrZTxUPiwgcHJlZDogQXJyYXlQcmVkaWNhdGU8VD4pOiBib29sZWFuID0+IHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHhzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgeCA9IHhzW2ldO1xuICAgIGlmIChwcmVkKHgsIGkpICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsID0gPFQ+KGExOiBBcnJheUxpa2U8VD4sIGEyOiBBcnJheUxpa2U8VD4sIGVxOiBFcS5FcTxUPiA9IEVxLmVxQW55KTogYm9vbGVhbiA9PlxuICBFcS5lcUFycmF5KGVxKS5lcShhMSwgYTIpO1xuXG5leHBvcnQgY29uc3QgcmV2ZXJzZSA9IDxUPih4czogQXJyYXlMaWtlPFQ+KTogVFtdID0+IHtcbiAgY29uc3QgcjogVFtdID0gbmF0aXZlU2xpY2UuY2FsbCh4cywgMCk7XG4gIHIucmV2ZXJzZSgpO1xuICByZXR1cm4gcjtcbn07XG5cbmV4cG9ydCBjb25zdCBkaWZmZXJlbmNlID0gPFQ+KGExOiBBcnJheUxpa2U8VD4sIGEyOiBBcnJheUxpa2U8VD4pOiBUW10gPT4gZmlsdGVyKGExLCAoeCkgPT4gIWNvbnRhaW5zKGEyLCB4KSk7XG5cbmV4cG9ydCBjb25zdCBtYXBUb09iamVjdDoge1xuICA8VCBleHRlbmRzIHN0cmluZywgVT4oeHM6IEFycmF5TGlrZTxUPiwgZjogKHg6IFQsIGk6IG51bWJlcikgPT4gVSk6IFJlY29yZDxULCBVPjtcbiAgPFQsIFIgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+Pih4czogQXJyYXlMaWtlPFQ+LCBmOiAoeDogVCwgaTogbnVtYmVyKSA9PiBSW2tleW9mIFJdKTogUjtcbn0gPSA8VCwgUiBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KHhzOiBBcnJheUxpa2U8VD4sIGY6ICh4OiBULCBpOiBudW1iZXIpID0+IFJba2V5b2YgUl0pOiBSID0+IHtcbiAgY29uc3QgciA9IHt9IGFzIFI7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSB4cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICByW1N0cmluZyh4KSBhcyBrZXlvZiBSXSA9IGYoeCwgaSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG5leHBvcnQgY29uc3QgcHVyZSA9IDxUPih4OiBUKTogVFtdID0+IFsgeCBdO1xuXG5leHBvcnQgY29uc3Qgc29ydCA9IDxUPih4czogQXJyYXlMaWtlPFQ+LCBjb21wYXJhdG9yPzogQ29tcGFyYXRvcjxUPik6IFRbXSA9PiB7XG4gIGNvbnN0IGNvcHk6IFRbXSA9IG5hdGl2ZVNsaWNlLmNhbGwoeHMsIDApO1xuICBjb3B5LnNvcnQoY29tcGFyYXRvcik7XG4gIHJldHVybiBjb3B5O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldCA9IDxUPih4czogQXJyYXlMaWtlPFQ+LCBpOiBudW1iZXIpOiBPcHRpb25hbDxUPiA9PiBpID49IDAgJiYgaSA8IHhzLmxlbmd0aCA/IE9wdGlvbmFsLnNvbWUoeHNbaV0pIDogT3B0aW9uYWwubm9uZSgpO1xuXG5leHBvcnQgY29uc3QgaGVhZCA9IDxUPih4czogQXJyYXlMaWtlPFQ+KTogT3B0aW9uYWw8VD4gPT4gZ2V0KHhzLCAwKTtcblxuZXhwb3J0IGNvbnN0IGxhc3QgPSA8VD4oeHM6IEFycmF5TGlrZTxUPik6IE9wdGlvbmFsPFQ+ID0+IGdldCh4cywgeHMubGVuZ3RoIC0gMSk7XG5cbmV4cG9ydCBjb25zdCBmcm9tOiA8VD4oeDogQXJyYXlMaWtlPFQ+KSA9PiBUW10gPSBUeXBlLmlzRnVuY3Rpb24oQXJyYXkuZnJvbSkgPyBBcnJheS5mcm9tIDogKHgpID0+IG5hdGl2ZVNsaWNlLmNhbGwoeCk7XG5cbmV4cG9ydCBjb25zdCBmaW5kTWFwID0gPEEsIEI+KGFycjogQXJyYXlMaWtlPEE+LCBmOiAoYTogQSwgaW5kZXg6IG51bWJlcikgPT4gT3B0aW9uYWw8Qj4pOiBPcHRpb25hbDxCPiA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgciA9IGYoYXJyW2ldLCBpKTtcbiAgICBpZiAoci5pc1NvbWUoKSkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICB9XG4gIHJldHVybiBPcHRpb25hbC5ub25lPEI+KCk7XG59O1xuXG5leHBvcnQgY29uc3QgdW5pcXVlID0gPFQ+KHhzOiBBcnJheUxpa2U8VD4sIGNvbXBhcmF0b3I/OiAoYTogVCwgYjogVCkgPT4gYm9vbGVhbik6IFRbXSA9PiB7XG4gIGNvbnN0IHI6IFRbXSA9IFtdO1xuXG4gIGNvbnN0IGlzRHVwbGljYXRlZCA9IFR5cGUuaXNGdW5jdGlvbihjb21wYXJhdG9yKSA/XG4gICAgKHg6IFQpID0+IGV4aXN0cyhyLCAoaSkgPT4gY29tcGFyYXRvcihpLCB4KSkgOlxuICAgICh4OiBUKSA9PiBjb250YWlucyhyLCB4KTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0geHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCB4ID0geHNbaV07XG4gICAgaWYgKCFpc0R1cGxpY2F0ZWQoeCkpIHtcbiAgICAgIHIucHVzaCh4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG4iLCJpbXBvcnQgKiBhcyBUeXBlIGZyb20gJy4vVHlwZSc7XG5cbmNvbnN0IG5vb3A6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZFxuPSAoKSA9PiB7IH07XG5cbmNvbnN0IG5vYXJnOiA8VD4oZjogKCkgPT4gVCkgPT4gKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkXG49IChmKSA9PiAoKSA9PiBmKCk7XG5cbi8qKiBDb21wb3NlIGEgdW5hcnkgZnVuY3Rpb24gd2l0aCBhbiBuLWFyeSBmdW5jdGlvbiAqL1xuY29uc3QgY29tcG9zZSA9IDxUIGV4dGVuZHMgYW55W10sIFUsIFY+KGZhOiAodjogVSkgPT4gViwgZmI6ICguLi54OiBUKSA9PiBVKTogKC4uLng6IFQpID0+IFYgPT4ge1xuICByZXR1cm4gKC4uLmFyZ3M6IFQpID0+IHtcbiAgICByZXR1cm4gZmEoZmIuYXBwbHkobnVsbCwgYXJncykpO1xuICB9O1xufTtcblxuLyoqIENvbXBvc2UgdHdvIHVuYXJ5IGZ1bmN0aW9ucy4gU2ltaWxhciB0byBjb21wb3NlLCBidXQgYXZvaWRzIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS4gKi9cbmNvbnN0IGNvbXBvc2UxID0gPEEsIEIsIEM+IChmYmM6IChiOiBCKSA9PiBDLCBmYWI6IChhOiBBKSA9PiBCKSA9PiAoYTogQSk6IEMgPT5cbiAgZmJjKGZhYihhKSk7XG5cbmNvbnN0IGNvbnN0YW50ID0gPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufTtcblxuY29uc3QgaWRlbnRpdHkgPSA8VCA9IGFueT4oeDogVCk6IFQgPT4ge1xuICByZXR1cm4geDtcbn07XG5cbmNvbnN0IHRyaXBsZUVxdWFscyA9IDxUPihhOiBULCBiOiBUKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuZnVuY3Rpb24gY3VycnkgPFJFU1QgZXh0ZW5kcyBhbnlbXSwgT1VUPihmbjogKC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQpOiAoLi4ucmVzdEFyZ3M6IFJFU1QpID0+IE9VVDtcbmZ1bmN0aW9uIGN1cnJ5IDxBLCBSRVNUIGV4dGVuZHMgYW55W10sIE9VVD4oZm46IChhOiBBLCAuLi5yZXN0QXJnczogUkVTVCkgPT4gT1VULCBhOiBBKTogKC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQ7XG5mdW5jdGlvbiBjdXJyeSA8QSwgQiwgUkVTVCBleHRlbmRzIGFueVtdLCBPVVQ+KGZuOiAoYTogQSwgYjogQiwgLi4ucmVzdEFyZ3M6IFJFU1QpID0+IE9VVCwgYTogQSwgYjogQik6ICguLi5yZXN0QXJnczogUkVTVCkgPT4gT1VUO1xuZnVuY3Rpb24gY3VycnkgPEEsIEIsIEMsIFJFU1QgZXh0ZW5kcyBhbnlbXSwgT1VUPihmbjogKGE6IEEsIGI6IEIsIGM6IEMsIC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQsIGE6IEEsIGI6IEIsIGM6IEMpOiAoLi4ucmVzdEFyZ3M6IFJFU1QpID0+IE9VVDtcbmZ1bmN0aW9uIGN1cnJ5IDxBLCBCLCBDLCBELCBSRVNUIGV4dGVuZHMgYW55W10sIE9VVD4oZm46IChhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCAuLi5yZXN0QXJnczogUkVTVCkgPT4gT1VULCBhOiBBLCBiOiBCLCBjOiBDLCBkOiBEKTogKC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQ7XG5mdW5jdGlvbiBjdXJyeSA8QSwgQiwgQywgRCwgRSwgUkVTVCBleHRlbmRzIGFueVtdLCBPVVQ+KGZuOiAoYTogQSwgYjogQiwgYzogQywgZDogRCwgZTogRSwgLi4ucmVzdEFyZ3M6IFJFU1QpID0+IE9VVCwgYTogQSwgYjogQiwgYzogQywgZDogRCwgZTogRSk6ICguLi5yZXN0QXJnczogUkVTVCkgPT4gT1VUO1xuZnVuY3Rpb24gY3VycnkgPEEsIEIsIEMsIEQsIEUsIEYsIFJFU1QgZXh0ZW5kcyBhbnlbXSwgT1VUPihmbjogKGE6IEEsIGI6IEIsIGM6IEMsIGQ6IEQsIGU6IEUsIGY6IEYsIC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQsIGE6IEEsIGI6IEIsIGM6IEMsIGQ6IEQsIGU6IEUsIGY6IEYpOiAoLi4ucmVzdEFyZ3M6IFJFU1QpID0+IE9VVDtcbmZ1bmN0aW9uIGN1cnJ5IDxBLCBCLCBDLCBELCBFLCBGLCBHLCBSRVNUIGV4dGVuZHMgYW55W10sIE9VVD4oZm46IChhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCBlOiBFLCBmOiBGLCBnOiBHLCAuLi5yZXN0QXJnczogUkVTVCkgPT4gT1VULCBhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCBlOiBFLCBmOiBGLCBnOiBHKTogKC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQ7XG5mdW5jdGlvbiBjdXJyeSA8QSwgQiwgQywgRCwgRSwgRiwgRywgSCwgUkVTVCBleHRlbmRzIGFueVtdLCBPVVQ+KGZuOiAoYTogQSwgYjogQiwgYzogQywgZDogRCwgZTogRSwgZjogRiwgZzogRywgaDogSCwgLi4ucmVzdEFyZ3M6IFJFU1QpID0+IE9VVCwgYTogQSwgYjogQiwgYzogQywgZDogRCwgZTogRSwgZjogRiwgZzogRywgaDogSCk6ICguLi5yZXN0QXJnczogUkVTVCkgPT4gT1VUO1xuZnVuY3Rpb24gY3VycnkgPEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgsIEksIFJFU1QgZXh0ZW5kcyBhbnlbXSwgT1VUPihmbjogKGE6IEEsIGI6IEIsIGM6IEMsIGQ6IEQsIGU6IEUsIGY6IEYsIGc6IEcsIGg6IEgsIGk6IEksIC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQsIGE6IEEsIGI6IEIsIGM6IEMsIGQ6IEQsIGU6IEUsIGY6IEYsIGc6IEcsIGg6IEgsIGk6IEkpOiAoLi4ucmVzdEFyZ3M6IFJFU1QpID0+IE9VVDtcbmZ1bmN0aW9uIGN1cnJ5IDxBLCBCLCBDLCBELCBFLCBGLCBHLCBILCBJLCBKLCBSRVNUIGV4dGVuZHMgYW55W10sIE9VVD4oZm46IChhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCBlOiBFLCBmOiBGLCBnOiBHLCBoOiBILCBpOiBJLCBqOiBKLCAuLi5yZXN0QXJnczogUkVTVCkgPT4gT1VULCBhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCBlOiBFLCBmOiBGLCBnOiBHLCBoOiBILCBpOiBJLCBqOiBKKTogKC4uLnJlc3RBcmdzOiBSRVNUKSA9PiBPVVQ7XG5mdW5jdGlvbiBjdXJyeSA8T1VUPihmbjogKC4uLmFsbEFyZ3M6IGFueVtdKSA9PiBPVVQsIC4uLmluaXRpYWxBcmdzOiBhbnlbXSk6ICguLi5yZXN0QXJnczogYW55W10pID0+IE9VVCB7XG4gIHJldHVybiAoLi4ucmVzdEFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3QgYWxsID0gaW5pdGlhbEFyZ3MuY29uY2F0KHJlc3RBcmdzKTtcbiAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYWxsKTtcbiAgfTtcbn1cblxuY29uc3Qgbm90ID0gPFQ+KGY6ICh0OiBUKSA9PiBib29sZWFuKSA9PiAodDogVCk6IGJvb2xlYW4gPT5cbiAgIWYodCk7XG5cbmNvbnN0IGRpZSA9IChtc2c6IHN0cmluZykgPT4ge1xuICByZXR1cm4gKCk6IG5ldmVyID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfTtcbn07XG5cbmNvbnN0IGFwcGx5ID0gPFQ+KGY6ICgpID0+IFQpOiBUID0+IHtcbiAgcmV0dXJuIGYoKTtcbn07XG5cbmNvbnN0IGNhbGwgPSAoZjogKCkgPT4gYW55KTogdm9pZCA9PiB7XG4gIGYoKTtcbn07XG5cbmNvbnN0IG5ldmVyOiAoLi4uYXJnczogYW55W10pID0+IGZhbHNlID0gY29uc3RhbnQ8ZmFsc2U+KGZhbHNlKTtcbmNvbnN0IGFsd2F5czogKC4uLmFyZ3M6IGFueVtdKSA9PiB0cnVlID0gY29uc3RhbnQ8dHJ1ZT4odHJ1ZSk7XG5cbi8qIFVzZWQgdG8gd2Vha2VuIHR5cGVzICovXG5jb25zdCB3ZWFrZW4gPSA8QSwgQiBleHRlbmRzIEE+KGI6IEIpOiBBID0+IGI7XG5cbnR5cGUgRnVuPFgsIFk+ID0gKHg6IFgpID0+IFk7XG5jb25zdCBwaXBlOiB7XG4gIDxBLCBCPihhOiBBLCBhYjogRnVuPEEsIEI+KTogQjtcbiAgPEEsIEIsIEM+KGE6IEEsIGFiOiBGdW48QSwgQj4sIGJjOiBGdW48QiwgQz4pOiBDO1xuICA8QSwgQiwgQywgRD4oYTogQSwgYWI6IEZ1bjxBLCBCPiwgYmM6IEZ1bjxCLCBDPiwgY2Q6IEZ1bjxDLCBEPik6IEQ7XG4gIDxBLCBCLCBDLCBELCBFPihhOiBBLCBhYjogRnVuPEEsIEI+LCBiYzogRnVuPEIsIEM+LCBjZDogRnVuPEMsIEQ+LCBkZTogRnVuPEQsIEU+KTogRTtcbiAgPEEsIEIsIEMsIEQsIEUsIEY+KGE6IEEsIGFiOiBGdW48QSwgQj4sIGJjOiBGdW48QiwgQz4sIGNkOiBGdW48QywgRD4sIGRlOiBGdW48RCwgRT4sIGVmOiBGdW48RSwgRj4pOiBGO1xuICA8QSwgQiwgQywgRCwgRSwgRiwgRz4oYTogQSwgYWI6IEZ1bjxBLCBCPiwgYmM6IEZ1bjxCLCBDPiwgY2Q6IEZ1bjxDLCBEPiwgZGU6IEZ1bjxELCBFPiwgZWY6IEZ1bjxFLCBGPiwgZmc6IEZ1bjxGLCBHPik6IEc7XG4gIDxBLCBCLCBDLCBELCBFLCBGLCBHLCBIPihhOiBBLCBhYjogRnVuPEEsIEI+LCBiYzogRnVuPEIsIEM+LCBjZDogRnVuPEMsIEQ+LCBkZTogRnVuPEQsIEU+LCBlZjogRnVuPEUsIEY+LCBmZzogRnVuPEYsIEc+LCBnaDogRnVuPEcsIEg+KTogSDtcbn0gPVxuICA8QSwgQiwgQywgRCwgRSwgRiwgRywgSD4oYTogQSwgYWI6IEZ1bjxBLCBCPiwgYmM/OiBGdW48QiwgQz4sIGNkPzogRnVuPEMsIEQ+LCBkZT86IEZ1bjxELCBFPiwgZWY/OiBGdW48RSwgRj4sIGZnPzogRnVuPEYsIEc+LCBnaD86IEZ1bjxHLCBIPik6IEIgfCBDIHwgRCB8IEUgfCBGIHwgRyB8IEggPT4ge1xuICAgIGNvbnN0IGIgPSBhYihhKTtcbiAgICBpZiAoVHlwZS5pc051bGxhYmxlKGJjKSkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuXG4gICAgY29uc3QgYyA9IGJjKGIpO1xuICAgIGlmIChUeXBlLmlzTnVsbGFibGUoY2QpKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBjb25zdCBkID0gY2QoYyk7XG4gICAgaWYgKFR5cGUuaXNOdWxsYWJsZShkZSkpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGNvbnN0IGUgPSBkZShkKTtcbiAgICBpZiAoVHlwZS5pc051bGxhYmxlKGVmKSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuXG4gICAgY29uc3QgZiA9IGVmKGUpO1xuICAgIGlmIChUeXBlLmlzTnVsbGFibGUoZmcpKSB7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICBjb25zdCBnID0gZmcoZik7XG4gICAgaWYgKFR5cGUuaXNOdWxsYWJsZShnaCkpIHtcbiAgICAgIHJldHVybiBnO1xuICAgIH1cblxuICAgIHJldHVybiBnaChnKTtcbiAgfTtcblxuZXhwb3J0IHtcbiAgbm9vcCxcbiAgbm9hcmcsXG4gIGNvbXBvc2UsXG4gIGNvbXBvc2UxLFxuICBjb25zdGFudCxcbiAgaWRlbnRpdHksXG4gIHRyaXBsZUVxdWFscyxcbiAgY3VycnksXG4gIG5vdCxcbiAgZGllLFxuICBhcHBseSxcbiAgY2FsbCxcbiAgbmV2ZXIsXG4gIGFsd2F5cyxcbiAgd2Vha2VuLFxuICBwaXBlXG59O1xuIiwiLy8gVXNlIHdpbmRvdyBvYmplY3QgYXMgdGhlIGdsb2JhbCBpZiBpdCdzIGF2YWlsYWJsZSBzaW5jZSBDU1Agd2lsbCBibG9jayBzY3JpcHQgZXZhbHNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXG5leHBvcnQgY29uc3QgR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBGdW5jdGlvbigncmV0dXJuIHRoaXM7JykoKTtcbiIsImltcG9ydCAqIGFzIElkVXRpbHMgZnJvbSAnLi4vdXRpbC9JZFV0aWxzJztcblxuaW1wb3J0ICogYXMgTnVtIGZyb20gJy4vTnVtJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLlxuICpcbiAqIFRoZSB1bmlxdWUgcG9ydGlvbiBvZiB0aGUgaWRlbnRpZmllciBvbmx5IGNvbnRhaW5zIGFuIHVuZGVyc2NvcmVcbiAqIGFuZCBkaWdpdHMsIHNvIHRoYXQgaXQgbWF5IHNhZmVseSBiZSB1c2VkIHdpdGhpbiBIVE1MIGF0dHJpYnV0ZXMuXG4gKlxuICogVGhlIGNoYW5jZSBvZiBnZW5lcmF0aW5nIGEgbm9uLXVuaXF1ZSBpZGVudGlmaWVyIGhhcyBiZWVuIG1pbmltaXplZFxuICogYnkgY29tYmluaW5nIHRoZSBjdXJyZW50IHRpbWUsIGEgcmFuZG9tIG51bWJlciBhbmQgYSBvbmUtdXAgY291bnRlci5cbiAqXG4gKiBnZW5lcmF0ZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gKi9cbmxldCB1bmlxdWUgPSAwO1xuXG5jb25zdCBnZW5lcmF0ZSA9IChwcmVmaXg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICBjb25zdCB0aW1lID0gZGF0ZS5nZXRUaW1lKCk7XG4gIGNvbnN0IHJhbmRvbSA9IE1hdGguZmxvb3IoTnVtLnJhbmRvbSgpICogMTAwMDAwMDAwMCk7XG5cbiAgdW5pcXVlKys7XG5cbiAgcmV0dXJuIHByZWZpeCArICdfJyArIHJhbmRvbSArIHVuaXF1ZSArIFN0cmluZyh0aW1lKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1dWlkdjQgc3RyaW5nXG4gKiBJbiBhY2NvcmRhbmNlIHdpdGggUkZDIDQxMjIgKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDEyMilcbiAqL1xuY29uc3QgdXVpZFY0ID0gKCk6IGAke3N0cmluZ30tJHtzdHJpbmd9LSR7c3RyaW5nfS0ke3N0cmluZ30tJHtzdHJpbmd9YCA9PiB7XG5cbiAgaWYgKHdpbmRvdy5pc1NlY3VyZUNvbnRleHQpIHtcbiAgICByZXR1cm4gd2luZG93LmNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIElkVXRpbHMudXVpZFY0U3RyaW5nKCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7XG4gIGdlbmVyYXRlLFxuICB1dWlkVjRcbn07XG4iLCIvKipcbiAqIEFkZHMgdHdvIG51bWJlcnMsIGFuZCB3cmFwIHRvIGEgcmFuZ2UuXG4gKiBJZiB0aGUgcmVzdWx0IG92ZXJmbG93cyB0byB0aGUgcmlnaHQsIHNuYXAgdG8gdGhlIGxlZnQuXG4gKiBJZiB0aGUgcmVzdWx0IG92ZXJmbG93cyB0byB0aGUgbGVmdCwgc25hcCB0byB0aGUgcmlnaHQuXG4gKi9cbmV4cG9ydCBjb25zdCBjeWNsZUJ5ID0gKHZhbHVlOiBudW1iZXIsIGRlbHRhOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcik6IG51bWJlciA9PiB7XG4gIGNvbnN0IHIgPSB2YWx1ZSArIGRlbHRhO1xuICBpZiAociA+IG1heCkge1xuICAgIHJldHVybiBtaW47XG4gIH0gZWxzZSBpZiAociA8IG1pbikge1xuICAgIHJldHVybiBtYXg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHI7XG4gIH1cbn07XG5cbi8vIEFTU1VNUFRJT046IE1heCB3aWxsIGFsd2F5cyBiZSBsYXJnZXIgdGhhbiBtaW5cbmV4cG9ydCBjb25zdCBjbGFtcCA9ICh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIgPT5cbiAgTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG5cbi8vIHRoZSBkaXZpc2lvbiBpcyBtZWFudCB0byBnZXQgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIGZvciBtb3JlIGluZm9ybWF0aW9uIGNoZWNrIHRoaXMgZGlzY3Vzc2lvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTgyODU5NDEvaG93LXRvLXJlcGxhY2UtbWF0aC1yYW5kb20td2l0aC1jcnlwdG8tZ2V0cmFuZG9tdmFsdWVzLWFuZC1rZWVwLXNhbWUtcmVzdWx0XG5leHBvcnQgY29uc3QgcmFuZG9tID0gKCk6IG51bWJlciA9PiB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdIC8gNDI5NDk2NzI5NTtcbiIsImltcG9ydCB7IEVxIH0gZnJvbSAnQGVwaG94L2Rpc3B1dGUnO1xuXG5pbXBvcnQgKiBhcyBGdW4gZnJvbSAnLi9GdW4nO1xuaW1wb3J0IHsgT3B0aW9uYWwgfSBmcm9tICcuL09wdGlvbmFsJztcblxudHlwZSBPYmpLZXlzPFQgZXh0ZW5kcyB7fT4gPSBFeHRyYWN0PGtleW9mIFQsIHN0cmluZz47XG50eXBlIE9iakNhbGxiYWNrPFQgZXh0ZW5kcyB7fT4gPSAodmFsdWU6IFRba2V5b2YgVF0sIGtleTogT2JqS2V5czxUPikgPT4gdm9pZDtcbnR5cGUgT2JqTW9ycGhpc208VCBleHRlbmRzIHt9LCBSPiA9ICh2YWx1ZTogVFtrZXlvZiBUXSwga2V5OiBPYmpLZXlzPFQ+KSA9PiBSO1xudHlwZSBPYmpHdWFyZFByZWRpY2F0ZTxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyBUW2tleW9mIFRdPiA9ICh2YWx1ZTogVFtrZXlvZiBUXSwga2V5OiBPYmpLZXlzPFQ+KSA9PiB2YWx1ZSBpcyBVO1xudHlwZSBPYmpQcmVkaWNhdGU8VCBleHRlbmRzIHt9PiA9ICh2YWx1ZTogVFtrZXlvZiBUXSwga2V5OiBPYmpLZXlzPFQ+KSA9PiBib29sZWFuO1xuXG4vLyBUaGVyZSBhcmUgbWFueSB2YXJpYXRpb25zIG9mIE9iamVjdCBpdGVyYXRpb24gdGhhdCBhcmUgZmFzdGVyIHRoYW4gdGhlICdmb3ItaW4nIHN0eWxlOlxuLy8gaHR0cDovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtaXRlcmF0aW9uLzEwN1xuLy9cbi8vIFVzZSB0aGUgbmF0aXZlIGtleXMgaWYgaXQgaXMgYXZhaWxhYmxlIChJRTkrKSwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byBtYW51YWxseSBmaWx0ZXJpbmdcbmV4cG9ydCBjb25zdCBrZXlzID0gT2JqZWN0LmtleXM7XG5cbmV4cG9ydCBjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblxuZXhwb3J0IGNvbnN0IGVhY2ggPSA8VCBleHRlbmRzIHt9PihvYmo6IFQsIGY6IE9iakNhbGxiYWNrPFQ+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHByb3BzID0ga2V5cyhvYmopIGFzIEFycmF5PE9iaktleXM8VD4+O1xuICBmb3IgKGxldCBrID0gMCwgbGVuID0gcHJvcHMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICBjb25zdCBpID0gcHJvcHNba107XG4gICAgY29uc3QgeCA9IG9ialtpXTtcbiAgICBmKHgsIGkpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWFwID0gPFQgZXh0ZW5kcyB7fSwgUj4ob2JqOiBULCBmOiBPYmpNb3JwaGlzbTxULCBSPik6IHsgW2sgaW4ga2V5b2YgVF06IFIgfSA9PiB7XG4gIHJldHVybiB0dXBsZU1hcDx7IFtrIGluIGtleW9mIFRdOiBSIH0sIFQ+KG9iaiwgKHgsIGkpID0+ICh7XG4gICAgazogaSxcbiAgICB2OiBmKHgsIGkpXG4gIH0pKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0dXBsZU1hcCA9IDxSIGV4dGVuZHMge30sIFQgZXh0ZW5kcyB7fT4ob2JqOiBULCBmOiBPYmpNb3JwaGlzbTxULCB7IGs6IGtleW9mIFI7IHY6IFJba2V5b2YgUl0gfT4pOiBSID0+IHtcbiAgY29uc3QgciA9IHt9IGFzIFI7XG4gIGVhY2gob2JqLCAoeCwgaSkgPT4ge1xuICAgIGNvbnN0IHR1cGxlID0gZih4LCBpKTtcbiAgICByW3R1cGxlLmtdID0gdHVwbGUudjtcbiAgfSk7XG4gIHJldHVybiByO1xufTtcblxuY29uc3Qgb2JqQWNjID0gPFQgZXh0ZW5kcyB7fT4ocjogVCkgPT4gKHg6IFRba2V5b2YgVF0sIGk6IGtleW9mIFQpOiB2b2lkID0+IHtcbiAgcltpXSA9IHg7XG59O1xuXG5jb25zdCBpbnRlcm5hbEZpbHRlciA9IDxUIGV4dGVuZHMge30+KG9iajogVCwgcHJlZDogT2JqUHJlZGljYXRlPFQ+LCBvblRydWU6IE9iakNhbGxiYWNrPFQ+LCBvbkZhbHNlOiBPYmpDYWxsYmFjazxUPikgPT4ge1xuICBlYWNoKG9iaiwgKHgsIGkpID0+IHtcbiAgICAocHJlZCh4LCBpKSA/IG9uVHJ1ZSA6IG9uRmFsc2UpKHgsIGkpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBiaWZpbHRlciA9IDxUIGV4dGVuZHMge30+KG9iajogVCwgcHJlZDogT2JqUHJlZGljYXRlPFQ+KTogeyB0OiBSZWNvcmQ8c3RyaW5nLCBUW2tleW9mIFRdPjsgZjogUmVjb3JkPHN0cmluZywgVFtrZXlvZiBUXT4gfSA9PiB7XG4gIGNvbnN0IHQ6IFJlY29yZDxzdHJpbmcsIFRba2V5b2YgVF0+ID0ge307XG4gIGNvbnN0IGY6IFJlY29yZDxzdHJpbmcsIFRba2V5b2YgVF0+ID0ge307XG4gIGludGVybmFsRmlsdGVyKG9iaiwgcHJlZCwgb2JqQWNjKHQpLCBvYmpBY2MoZikpO1xuICByZXR1cm4geyB0LCBmIH07XG59O1xuXG5leHBvcnQgY29uc3QgZmlsdGVyOiB7XG4gIDxUIGV4dGVuZHMge30sIFUgZXh0ZW5kcyBUW2tleW9mIFRdPihvYmo6IFQsIHByZWQ6IE9iakd1YXJkUHJlZGljYXRlPFQsIFU+KTogUmVjb3JkPHN0cmluZywgVT47XG4gIDxUIGV4dGVuZHMge30+KG9iajogVCwgcHJlZDogT2JqUHJlZGljYXRlPFQ+KTogUmVjb3JkPHN0cmluZywgVFtrZXlvZiBUXT47XG59ID0gPFQgZXh0ZW5kcyB7fT4ob2JqOiBULCBwcmVkOiBPYmpQcmVkaWNhdGU8VD4pOiBSZWNvcmQ8c3RyaW5nLCBUW2tleW9mIFRdPiA9PiB7XG4gIGNvbnN0IHQ6IFJlY29yZDxzdHJpbmcsIFRba2V5b2YgVF0+ID0ge307XG4gIGludGVybmFsRmlsdGVyKG9iaiwgcHJlZCwgb2JqQWNjKHQpLCBGdW4ubm9vcCk7XG4gIHJldHVybiB0O1xufTtcblxuZXhwb3J0IGNvbnN0IG1hcFRvQXJyYXkgPSA8VCBleHRlbmRzIHt9LCBSPihvYmo6IFQsIGY6IE9iak1vcnBoaXNtPFQsIFI+KTogUltdID0+IHtcbiAgY29uc3QgcjogUltdID0gW107XG4gIGVhY2gob2JqLCAodmFsdWUsIG5hbWUpID0+IHtcbiAgICByLnB1c2goZih2YWx1ZSwgbmFtZSkpO1xuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xuXG5leHBvcnQgY29uc3QgZmluZCA9IDxUIGV4dGVuZHMge30+KG9iajogVCwgcHJlZDogKHZhbHVlOiBUW2tleW9mIFRdLCBrZXk6IE9iaktleXM8VD4sIG9iajogVCkgPT4gYm9vbGVhbik6IE9wdGlvbmFsPFRba2V5b2YgVF0+ID0+IHtcbiAgY29uc3QgcHJvcHMgPSBrZXlzKG9iaikgYXMgQXJyYXk8T2JqS2V5czxUPj47XG4gIGZvciAobGV0IGsgPSAwLCBsZW4gPSBwcm9wcy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgIGNvbnN0IGkgPSBwcm9wc1trXTtcbiAgICBjb25zdCB4ID0gb2JqW2ldO1xuICAgIGlmIChwcmVkKHgsIGksIG9iaikpIHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT3B0aW9uYWwubm9uZSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IHZhbHVlcyA9IDxUIGV4dGVuZHMge30+KG9iajogVCk6IEFycmF5PFRba2V5b2YgVF0+ID0+IHtcbiAgcmV0dXJuIG1hcFRvQXJyYXkob2JqLCBGdW4uaWRlbnRpdHkpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNpemUgPSAob2JqOiB7fSk6IG51bWJlciA9PiB7XG4gIHJldHVybiBrZXlzKG9iaikubGVuZ3RoO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldCA9IDxUIGV4dGVuZHMge30sIEsgZXh0ZW5kcyBrZXlvZiBUPihvYmo6IFQsIGtleTogSyk6IE9wdGlvbmFsPE5vbk51bGxhYmxlPFRbS10+PiA9PiB7XG4gIHJldHVybiBoYXMob2JqLCBrZXkpID8gT3B0aW9uYWwuZnJvbShvYmpba2V5XSBhcyBOb25OdWxsYWJsZTxUW0tdPikgOiBPcHRpb25hbC5ub25lKCk7XG59O1xuXG5leHBvcnQgY29uc3QgaGFzID0gPFQgZXh0ZW5kcyB7fSwgSyBleHRlbmRzIGtleW9mIFQ+KG9iajogVCwga2V5OiBLKTogYm9vbGVhbiA9PlxuICBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcblxuZXhwb3J0IGNvbnN0IGhhc05vbk51bGxhYmxlS2V5ID0gPFQgZXh0ZW5kcyB7fSwgSyBleHRlbmRzIGtleW9mIFQ+KG9iajogVCwga2V5OiBLKTogb2JqIGlzIFQgJiBSZWNvcmQ8SywgTm9uTnVsbGFibGU8VFtLXT4+ID0+XG4gIGhhcyhvYmosIGtleSkgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCAmJiBvYmpba2V5XSAhPT0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IGlzRW1wdHkgPSAocjogUmVjb3JkPGFueSwgYW55Pik6IHIgaXMge30gPT4ge1xuICBmb3IgKGNvbnN0IHggaW4gcikge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIHgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGNvbnN0IGVxdWFsID0gPFQ+KGExOiBSZWNvcmQ8c3RyaW5nLCBUPiwgYTI6IFJlY29yZDxzdHJpbmcsIFQ+LCBlcTogRXEuRXE8VD4gPSBFcS5lcUFueSk6IGJvb2xlYW4gPT5cbiAgRXEuZXFSZWNvcmQoZXEpLmVxKGExLCBhMik7XG4iLCJpbXBvcnQgKiBhcyBUeXBlIGZyb20gJy4vVHlwZSc7XG5cbi8qKlxuICogVGhlIGBPcHRpb25hbGAgdHlwZSByZXByZXNlbnRzIGEgdmFsdWUgKG9mIGFueSB0eXBlKSB0aGF0IHBvdGVudGlhbGx5IGRvZXNcbiAqIG5vdCBleGlzdC4gQW55IGBPcHRpb25hbDxUPmAgY2FuIGVpdGhlciBiZSBhIGBTb21lPFQ+YCAoaW4gd2hpY2ggY2FzZSB0aGVcbiAqIHZhbHVlIGRvZXMgZXhpc3QpIG9yIGEgYE5vbmVgIChpbiB3aGljaCBjYXNlIHRoZSB2YWx1ZSBkb2VzIG5vdCBleGlzdCkuIFRoaXNcbiAqIG1vZHVsZSBkZWZpbmVzIGEgd2hvbGUgbG90IG9mIEZQLWluc3BpcmVkIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBkZWFsaW5nIHdpdGhcbiAqIGBPcHRpb25hbGAgb2JqZWN0cy5cbiAqXG4gKiBDb21wYXJpc29uIHdpdGggbnVsbCBvciB1bmRlZmluZWQ6XG4gKiAtIFdlIGRvbid0IGdldCBmYW5jeSBudWxsIGNvYWxlc2Npbmcgb3BlcmF0b3JzIHdpdGggYE9wdGlvbmFsYFxuICogLSBXZSBkbyBnZXQgZmFuY3kgaGVscGVyIGZ1bmN0aW9ucyB3aXRoIGBPcHRpb25hbGBcbiAqIC0gYE9wdGlvbmFsYCBzdXBwb3J0IG5lc3RpbmcsIGFuZCBhbGxvdyBmb3IgdGhlIHR5cGUgdG8gc3RpbGwgYmUgbnVsbGFibGUgKG9yXG4gKiBhbm90aGVyIGBPcHRpb25hbGApXG4gKiAtIFRoZXJlIGlzIG5vIG9wdGlvbiB0byB0dXJuIG9mZiBzdHJpY3Qtb3B0aW9uYWwtY2hlY2tzIGxpa2UgdGhlcmUgaXMgZm9yXG4gKiBzdHJpY3QtbnVsbC1jaGVja3NcbiAqL1xuZXhwb3J0IGNsYXNzIE9wdGlvbmFsPFQ+IHtcbiAgcHJpdmF0ZSByZWFkb25seSB0YWc6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgdmFsdWU/OiBUO1xuXG4gIC8vIFNuZWFreSBvcHRpbWlzYXRpb246IGV2ZXJ5IGluc3RhbmNlIG9mIE9wdGlvbmFsLm5vbmUgaXMgaWRlbnRpY2FsLCBzbyBqdXN0XG4gIC8vIHJldXNlIHRoZSBzYW1lIG9iamVjdFxuICBwcml2YXRlIHN0YXRpYyBzaW5nbGV0b25Ob25lID0gbmV3IE9wdGlvbmFsPGFueT4oZmFsc2UpO1xuXG4gIC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBoYXMgYSBgdGFnYCBhbmQgYSBgdmFsdWVgLCBidXQgYm90aCBhcmVcbiAgLy8gcHJpdmF0ZTogYWJsZSB0byBiZSBjb25zb2xlLmxvZ2dlZCwgYnV0IG5vdCBhYmxlIHRvIGJlIGFjY2Vzc2VkIGJ5IGNvZGVcbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcih0YWc6IGJvb2xlYW4sIHZhbHVlPzogVCkge1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8vIC0tLSBJZGVudGl0aWVzIC0tLVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBPcHRpb25hbDxUPmAgdGhhdCAqKmRvZXMqKiBjb250YWluIGEgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNvbWU8VD4odGhpczogdm9pZCwgdmFsdWU6IFQpOiBPcHRpb25hbDxUPiB7XG4gICAgcmV0dXJuIG5ldyBPcHRpb25hbCh0cnVlLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBPcHRpb25hbDxUPmAgdGhhdCAqKmRvZXMgbm90KiogY29udGFpbiBhIHZhbHVlLiBgVGAgY2FuIGJlXG4gICAqIGFueSB0eXBlIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBhIGBUYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgbm9uZTxUID0gbmV2ZXI+KHRoaXM6IHZvaWQpOiBPcHRpb25hbDxUPiB7XG4gICAgcmV0dXJuIE9wdGlvbmFsLnNpbmdsZXRvbk5vbmU7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIHRyYW5zZm9ybSBvbiBhbiBgT3B0aW9uYWxgIHR5cGUuIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzXG4gICAqIGBPcHRpb25hbGAgY29udGFpbnMgYSB2YWx1ZSBvciBub3QsIGBmb2xkYCB3aWxsIHJldHVybiBhIHZhbHVlIG9mIHR5cGUgYFVgLlxuICAgKiBJZiB0aGlzIGBPcHRpb25hbGAgZG9lcyBub3QgY29udGFpbiBhIHZhbHVlLCB0aGUgYFVgIHdpbGwgYmUgY3JlYXRlZCBieVxuICAgKiBjYWxsaW5nIGBvbk5vbmVgLiBJZiB0aGlzIGBPcHRpb25hbGAgZG9lcyBjb250YWluIGEgdmFsdWUsIHRoZSBgVWAgd2lsbCBiZVxuICAgKiBjcmVhdGVkIGJ5IGNhbGxpbmcgYG9uU29tZWAuXG4gICAqXG4gICAqIEZvciB0aGUgRlAgZW50aHVzaWFzdHMgaW4gdGhlIHJvb20sIHRoaXMgZnVuY3Rpb246XG4gICAqIDEuIENvdWxkIGJlIHVzZWQgdG8gaW1wbGVtZW50IGFsbCBvZiB0aGUgZnVuY3Rpb25zIGJlbG93XG4gICAqIDIuIEZvcm1zIGEgY2F0YW1vcnBoaXNtXG4gICAqL1xuICBwdWJsaWMgZm9sZDxVPihvbk5vbmU6ICgpID0+IFUsIG9uU29tZTogKHZhbHVlOiBUKSA9PiBVKTogVSB7XG4gICAgaWYgKHRoaXMudGFnKSB7XG4gICAgICByZXR1cm4gb25Tb21lKHRoaXMudmFsdWUgYXMgVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvbk5vbmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoaXMgYE9wdGlvbmFsYCBvYmplY3QgY29udGFpbnMgYSB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBpc1NvbWUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudGFnO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB0aGlzIGBPcHRpb25hbGAgb2JqZWN0ICoqZG9lcyBub3QqKiBjb250YWluIGEgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgaXNOb25lKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy50YWc7XG4gIH1cblxuICAvLyAtLS0gRnVuY3RvciAobmFtZSBzdG9sZW4gZnJvbSBIYXNrZWxsIC8gbWF0aHMpIC0tLVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgdHJhbnNmb3JtIG9uIGFuIGBPcHRpb25hbGAgb2JqZWN0LCAqKmlmKiogdGhlcmUgaXMgYSB2YWx1ZS4gSWZcbiAgICogeW91IHByb3ZpZGUgYSBmdW5jdGlvbiB0byB0dXJuIGEgVCBpbnRvIGEgVSwgdGhpcyBpcyB0aGUgZnVuY3Rpb24geW91IHVzZVxuICAgKiB0byB0dXJuIGFuIGBPcHRpb25hbDxUPmAgaW50byBhbiBgT3B0aW9uYWw8VT5gLiBJZiB0aGlzICoqZG9lcyoqIGNvbnRhaW5cbiAgICogYSB2YWx1ZSB0aGVuIHRoZSBvdXRwdXQgd2lsbCBhbHNvIGNvbnRhaW4gYSB2YWx1ZSAodGhhdCB2YWx1ZSBiZWluZyB0aGVcbiAgICogb3V0cHV0IG9mIGBtYXBwZXIodGhpcy52YWx1ZSlgKSwgYW5kIGlmIHRoaXMgKipkb2VzIG5vdCoqIGNvbnRhaW4gYSB2YWx1ZVxuICAgKiB0aGVuIG5laXRoZXIgd2lsbCB0aGUgb3V0cHV0LlxuICAgKi9cbiAgcHVibGljIG1hcDxVPihtYXBwZXI6ICh2YWx1ZTogVCkgPT4gVSk6IE9wdGlvbmFsPFU+IHtcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHJldHVybiBPcHRpb25hbC5zb21lKG1hcHBlcih0aGlzLnZhbHVlIGFzIFQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0gTW9uYWQgKG5hbWUgc3RvbGVuIGZyb20gSGFza2VsbCAvIG1hdGhzKSAtLS1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIHRyYW5zZm9ybSBvbiBhbiBgT3B0aW9uYWxgIG9iamVjdCwgKippZioqIHRoZXJlIGlzIGEgdmFsdWUuXG4gICAqIFVubGlrZSBgbWFwYCwgaGVyZSB0aGUgdHJhbnNmb3JtIGl0c2VsZiBhbHNvIHJldHVybnMgYW4gYE9wdGlvbmFsYC5cbiAgICovXG4gIHB1YmxpYyBiaW5kPFU+KGJpbmRlcjogKHZhbHVlOiBUKSA9PiBPcHRpb25hbDxVPik6IE9wdGlvbmFsPFU+IHtcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHJldHVybiBiaW5kZXIodGhpcy52YWx1ZSBhcyBUKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0gVHJhdmVyc2FibGUgKG5hbWUgc3RvbGVuIGZyb20gSGFza2VsbCAvIG1hdGhzKSAtLS1cblxuICAvKipcbiAgICogRm9yIGEgZ2l2ZW4gcHJlZGljYXRlLCB0aGlzIGZ1bmN0aW9uIGZpbmRzIG91dCBpZiB0aGVyZSAqKmV4aXN0cyoqIGEgdmFsdWVcbiAgICogaW5zaWRlIHRoaXMgYE9wdGlvbmFsYCBvYmplY3QgdGhhdCBtZWV0cyB0aGUgcHJlZGljYXRlLiBJbiBwcmFjdGljZSwgdGhpc1xuICAgKiBtZWFucyB0aGF0IGZvciBgT3B0aW9uYWxgcyB0aGF0IGRvIG5vdCBjb250YWluIGEgdmFsdWUgaXQgcmV0dXJucyBmYWxzZSAoYXNcbiAgICogbm8gcHJlZGljYXRlLW1lZXRpbmcgdmFsdWUgZXhpc3RzKS5cbiAgICovXG4gIHB1YmxpYyBleGlzdHMocHJlZGljYXRlOiAodmFsdWU6IFQpID0+IGJvb2xlYW4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy50YWcgJiYgcHJlZGljYXRlKHRoaXMudmFsdWUgYXMgVCk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGEgZ2l2ZW4gcHJlZGljYXRlLCB0aGlzIGZ1bmN0aW9uIGZpbmRzIG91dCBpZiAqKmFsbCoqIHRoZSB2YWx1ZXMgaW5zaWRlXG4gICAqIHRoaXMgYE9wdGlvbmFsYCBvYmplY3QgbWVldCB0aGUgcHJlZGljYXRlLiBJbiBwcmFjdGljZSwgdGhpcyBtZWFucyB0aGF0XG4gICAqIGZvciBgT3B0aW9uYWxgcyB0aGF0IGRvIG5vdCBjb250YWluIGEgdmFsdWUgaXQgcmV0dXJucyB0cnVlIChhcyBhbGwgMFxuICAgKiBvYmplY3RzIGRvIG1lZXQgdGhlIHByZWRpY2F0ZSkuXG4gICAqL1xuICBwdWJsaWMgZm9yYWxsKHByZWRpY2F0ZTogKHZhbHVlOiBUKSA9PiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLnRhZyB8fCBwcmVkaWNhdGUodGhpcy52YWx1ZSBhcyBUKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBnaXZlbiBwcmVkaWNhdGUsIGNyZWF0ZSBhIG5ldyBgT3B0aW9uYWxgIG9iamVjdCB0aGF0IHdpbGwgcmV0YWluXG4gICAqIGFsbCB0aGUgdmFsdWVzIGluc2lkZSB0aGUgb2xkIGBPcHRpb25hbGAgb2JqZWN0IHRoYXQgbWVldCB0aGUgcHJlZGljYXRlLlxuICAgKiBJbiBwcmFjdGljZSwgdGhlIGBPcHRpb25hbGAgb2JqZWN0IGNvbnRhaW5zIGVpdGhlciAwIG9yIDEgb2JqZWN0cywgYW5kXG4gICAqIHRoZSBvdXRwdXQgd2lsbCBrZWVwIHRoZSAoc2luZ2xlKSBpbnB1dCBvYmplY3QgKGlmIGl0IGV4aXN0cykgYXMgbG9uZyBhc1xuICAgKiBpdCBwYXNzZXMgdGhlIHByZWRpY2F0ZS5cbiAgICovXG4gIHB1YmxpYyBmaWx0ZXI8VSBleHRlbmRzIFQ+KHByZWRpY2F0ZTogKHZhbHVlOiBUKSA9PiB2YWx1ZSBpcyBVKTogT3B0aW9uYWw8VT47XG4gIHB1YmxpYyBmaWx0ZXIocHJlZGljYXRlOiAodmFsdWU6IFQpID0+IGJvb2xlYW4pOiBPcHRpb25hbDxUPjtcbiAgcHVibGljIGZpbHRlcihwcmVkaWNhdGU6ICh2YWx1ZTogVCkgPT4gYm9vbGVhbik6IE9wdGlvbmFsPFQ+IHtcbiAgICBpZiAoIXRoaXMudGFnIHx8IHByZWRpY2F0ZSh0aGlzLnZhbHVlIGFzIFQpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmUoKTtcbiAgICB9XG4gIH1cblxuICAvLyAtLS0gR2V0dGVycyAtLS1cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvdXQgb2YgdGhlIGluc2lkZSBvZiB0aGUgYE9wdGlvbmFsYCBvYmplY3QsIHVzaW5nIGEgZGVmYXVsdFxuICAgKiBgcmVwbGFjZW1lbnRgIHZhbHVlIGlmIHRoZSBwcm92aWRlZCBgT3B0aW9uYWxgIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFcbiAgICogdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0T3I8VSA9IFQ+KHJlcGxhY2VtZW50OiBVKTogVCB8IFUge1xuICAgIHJldHVybiB0aGlzLnRhZyA/IHRoaXMudmFsdWUgYXMgVCA6IHJlcGxhY2VtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSBpbnNpZGUgb2YgdGhlIGBPcHRpb25hbGAgb2JqZWN0LCB1c2luZyBhIGRlZmF1bHRcbiAgICogYHJlcGxhY2VtZW50YCB2YWx1ZSBpZiB0aGUgcHJvdmlkZWQgYE9wdGlvbmFsYCBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhXG4gICAqIHZhbHVlLiAgVW5saWtlIGBnZXRPcmAsIGluIHRoaXMgbWV0aG9kIHRoZSBgcmVwbGFjZW1lbnRgIG9iamVjdCBpcyBhbHNvXG4gICAqIGBPcHRpb25hbGAgLSBtZWFuaW5nIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCBhbHdheXMgcmV0dXJuIGFuIGBPcHRpb25hbGAuXG4gICAqL1xuICBwdWJsaWMgb3I8VSA9IFQ+KHJlcGxhY2VtZW50OiBPcHRpb25hbDxVPik6IE9wdGlvbmFsPFQgfCBVPiB7XG4gICAgcmV0dXJuIHRoaXMudGFnID8gdGhpcyA6IHJlcGxhY2VtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWUgb3V0IG9mIHRoZSBpbnNpZGUgb2YgdGhlIGBPcHRpb25hbGAgb2JqZWN0LCB1c2luZyBhIGRlZmF1bHRcbiAgICogYHJlcGxhY2VtZW50YCB2YWx1ZSBpZiB0aGUgcHJvdmlkZWQgYE9wdGlvbmFsYCBvYmplY3QgZG9lcyBub3QgY29udGFpbiBhXG4gICAqIHZhbHVlLiBVbmxpa2UgYGdldE9yYCwgaW4gdGhpcyBtZXRob2QgdGhlIGByZXBsYWNlbWVudGAgdmFsdWUgaXNcbiAgICogXCJ0aHVua2VkXCIgLSB0aGF0IGlzIHRvIHNheSB0aGF0IHlvdSBkb24ndCBwYXNzIGEgdmFsdWUgdG8gYGdldE9yVGh1bmtgLCB5b3VcbiAgICogcGFzcyBhIGZ1bmN0aW9uIHdoaWNoIChpZiBjYWxsZWQpIHdpbGwgKipyZXR1cm4qKiB0aGUgYHZhbHVlYCB5b3Ugd2FudCB0b1xuICAgKiB1c2UuXG4gICAqL1xuICBwdWJsaWMgZ2V0T3JUaHVuazxVID0gVD4odGh1bms6ICgpID0+IFUpOiBUIHwgVSB7XG4gICAgcmV0dXJuIHRoaXMudGFnID8gdGhpcy52YWx1ZSBhcyBUIDogdGh1bmsoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG91dCBvZiB0aGUgaW5zaWRlIG9mIHRoZSBgT3B0aW9uYWxgIG9iamVjdCwgdXNpbmcgYSBkZWZhdWx0XG4gICAqIGByZXBsYWNlbWVudGAgdmFsdWUgaWYgdGhlIHByb3ZpZGVkIE9wdGlvbmFsIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGFcbiAgICogdmFsdWUuXG4gICAqXG4gICAqIFVubGlrZSBgb3JgLCBpbiB0aGlzIG1ldGhvZCB0aGUgYHJlcGxhY2VtZW50YCB2YWx1ZSBpcyBcInRodW5rZWRcIiAtIHRoYXQgaXNcbiAgICogdG8gc2F5IHRoYXQgeW91IGRvbid0IHBhc3MgYSB2YWx1ZSB0byBgb3JUaHVua2AsIHlvdSBwYXNzIGEgZnVuY3Rpb24gd2hpY2hcbiAgICogKGlmIGNhbGxlZCkgd2lsbCAqKnJldHVybioqIHRoZSBgdmFsdWVgIHlvdSB3YW50IHRvIHVzZS5cbiAgICpcbiAgICogVW5saWtlIGBnZXRPclRodW5rYCwgaW4gdGhpcyBtZXRob2QgdGhlIGByZXBsYWNlbWVudGAgdmFsdWUgaXMgYWxzb1xuICAgKiBgT3B0aW9uYWxgLCBtZWFuaW5nIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCBhbHdheXMgcmV0dXJuIGFuIGBPcHRpb25hbGAuXG4gICAqL1xuICBwdWJsaWMgb3JUaHVuazxVID0gVD4odGh1bms6ICgpID0+IE9wdGlvbmFsPFU+KTogT3B0aW9uYWw8VCB8IFU+IHtcbiAgICByZXR1cm4gdGhpcy50YWcgPyB0aGlzIDogdGh1bmsoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG91dCBvZiB0aGUgaW5zaWRlIG9mIHRoZSBgT3B0aW9uYWxgIG9iamVjdCwgdGhyb3dpbmcgYW5cbiAgICogZXhjZXB0aW9uIGlmIHRoZSBwcm92aWRlZCBgT3B0aW9uYWxgIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGEgdmFsdWUuXG4gICAqXG4gICAqIFdBUk5JTkc6XG4gICAqIFlvdSBzaG91bGQgb25seSBiZSB1c2luZyB0aGlzIGZ1bmN0aW9uIGlmIHlvdSBrbm93IHRoYXQgdGhlIGBPcHRpb25hbGBcbiAgICogb2JqZWN0ICoqaXMgbm90KiogZW1wdHkgKG90aGVyd2lzZSB5b3UncmUgdGhyb3dpbmcgZXhjZXB0aW9ucyBpbiBwcm9kdWN0aW9uXG4gICAqIGNvZGUsIHdoaWNoIGlzIGJhZCkuXG4gICAqXG4gICAqIEluIHRlc3RzIHRoaXMgaXMgbW9yZSBhY2NlcHRhYmxlLlxuICAgKlxuICAgKiBQcmVmZXIgb3RoZXIgbWV0aG9kcyB0byB0aGlzLCBzdWNoIGFzIGAuZWFjaGAuXG4gICAqL1xuICBwdWJsaWMgZ2V0T3JEaWUobWVzc2FnZT86IHN0cmluZyk6IFQge1xuICAgIGlmICghdGhpcy50YWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlID8/ICdDYWxsZWQgZ2V0T3JEaWUgb24gTm9uZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZSBhcyBUO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLSBJbnRlcm9wIHdpdGggbnVsbCBhbmQgdW5kZWZpbmVkIC0tLVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGBPcHRpb25hbGAgdmFsdWUgZnJvbSBhIG51bGxhYmxlIChvciB1bmRlZmluZWQtYWJsZSkgaW5wdXQuXG4gICAqIE51bGwsIG9yIHVuZGVmaW5lZCwgaXMgY29udmVydGVkIHRvIGBOb25lYCwgYW5kIGFueXRoaW5nIGVsc2UgaXMgY29udmVydGVkXG4gICAqIHRvIGBTb21lYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbTxUPih0aGlzOiB2b2lkLCB2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBPcHRpb25hbDxOb25OdWxsYWJsZTxUPj4ge1xuICAgIHJldHVybiBUeXBlLmlzTm9uTnVsbGFibGUodmFsdWUpID8gT3B0aW9uYWwuc29tZSh2YWx1ZSkgOiBPcHRpb25hbC5ub25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gYE9wdGlvbmFsYCB0byBhIG51bGxhYmxlIHR5cGUsIGJ5IGdldHRpbmcgdGhlIHZhbHVlIGlmIGl0XG4gICAqIGV4aXN0cywgb3IgcmV0dXJuaW5nIGBudWxsYCBpZiBpdCBkb2VzIG5vdC5cbiAgICovXG4gIHB1YmxpYyBnZXRPck51bGwoKTogVCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnRhZyA/IHRoaXMudmFsdWUgYXMgVCA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gYE9wdGlvbmFsYCB0byBhbiB1bmRlZmluZWQtYWJsZSB0eXBlLCBieSBnZXR0aW5nIHRoZSB2YWx1ZSBpZlxuICAgKiBpdCBleGlzdHMsIG9yIHJldHVybmluZyBgdW5kZWZpbmVkYCBpZiBpdCBkb2VzIG5vdC5cbiAgICovXG4gIHB1YmxpYyBnZXRPclVuZGVmaW5lZCgpOiBUIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIC8vIC0tLSBVdGlsaXRpZXMgLS0tXG5cbiAgLyoqXG4gICAqIElmIHRoZSBgT3B0aW9uYWxgIGNvbnRhaW5zIGEgdmFsdWUsIHBlcmZvcm0gYW4gYWN0aW9uIG9uIHRoYXQgdmFsdWUuXG4gICAqIFVubGlrZSB0aGUgcmVzdCBvZiB0aGUgbWV0aG9kcyBvbiB0aGlzIHR5cGUsIGAuZWFjaGAgaGFzIHNpZGUtZWZmZWN0cy4gSWZcbiAgICogeW91IHdhbnQgdG8gdHJhbnNmb3JtIGFuIGBPcHRpb25hbDxUPmAgKippbnRvKiogc29tZXRoaW5nLCB0aGVuIHRoaXMgaXMgbm90XG4gICAqIHRoZSBtZXRob2QgZm9yIHlvdS4gSWYgeW91IHdhbnQgdG8gdXNlIGFuIGBPcHRpb25hbDxUPmAgdG8gKipkbyoqXG4gICAqIHNvbWV0aGluZywgdGhlbiB0aGlzIGlzIHRoZSBtZXRob2QgZm9yIHlvdSAtIHByb3ZpZGVkIHlvdSdyZSBva2F5IHdpdGggbm90XG4gICAqIGRvaW5nIGFueXRoaW5nIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBgT3B0aW9uYWxgIGRvZXNuJ3QgaGF2ZSBhIHZhbHVlIGluc2lkZVxuICAgKiBpdC4gSWYgeW91J3JlIG5vdCBzdXJlIHdoZXRoZXIgeW91ciB1c2UtY2FzZSBmaXRzIGludG8gdHJhbnNmb3JtaW5nXG4gICAqICoqaW50byoqIHNvbWV0aGluZyBvciAqKmRvaW5nKiogc29tZXRoaW5nLCBjaGVjayB3aGV0aGVyIGl0IGhhcyBhIHJldHVyblxuICAgKiB2YWx1ZS4gSWYgaXQgZG9lcywgeW91IHNob3VsZCBiZSBwZXJmb3JtaW5nIGEgdHJhbnNmb3JtLlxuICAgKi9cbiAgcHVibGljIGVhY2god29ya2VyOiAodmFsdWU6IFQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy50YWcpIHtcbiAgICAgIHdvcmtlcih0aGlzLnZhbHVlIGFzIFQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIHRoZSBgT3B0aW9uYWxgIG9iamVjdCBpbnRvIGFuIGFycmF5IHRoYXQgY29udGFpbnMgYWxsIG9mIHRoZSB2YWx1ZXNcbiAgICogc3RvcmVkIGluc2lkZSB0aGUgYE9wdGlvbmFsYC4gSW4gcHJhY3RpY2UsIHRoaXMgbWVhbnMgdGhlIG91dHB1dCB3aWxsIGhhdmVcbiAgICogZWl0aGVyIDAgb3IgMSBlbGVtZW50cy5cbiAgICovXG4gIHB1YmxpYyB0b0FycmF5KCk6IFRbXSB7XG4gICAgcmV0dXJuIHRoaXMudGFnID8gWyB0aGlzLnZhbHVlIGFzIFQgXSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFR1cm4gdGhlIGBPcHRpb25hbGAgb2JqZWN0IGludG8gYSBzdHJpbmcgZm9yIGRlYnVnZ2luZyBvciBwcmludGluZy4gTm90XG4gICAqIHJlY29tbWVuZGVkIGZvciBwcm9kdWN0aW9uIGNvZGUsIGJ1dCBnb29kIGZvciBkZWJ1Z2dpbmcuIEFsc28gbm90ZSB0aGF0XG4gICAqIHRoZXNlIGRheXMgYW4gYE9wdGlvbmFsYCBvYmplY3QgY2FuIGJlIGxvZ2dlZCB0byB0aGUgY29uc29sZSBkaXJlY3RseSwgYW5kXG4gICAqIGl0cyBpbm5lciB2YWx1ZSAoaWYgaXQgZXhpc3RzKSB3aWxsIGJlIHZpc2libGUuXG4gICAqL1xuICBwdWJsaWMgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50YWcgPyBgc29tZSgke3RoaXMudmFsdWV9KWAgOiAnbm9uZSgpJztcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgQXJyIGZyb20gJy4vQXJyJztcbmltcG9ydCAqIGFzIEZ1biBmcm9tICcuL0Z1bic7XG5pbXBvcnQgeyBPcHRpb25hbCB9IGZyb20gJy4vT3B0aW9uYWwnO1xuXG4vKipcbiAqICoqSXMqKiB0aGUgdmFsdWUgc3RvcmVkIGluc2lkZSB0aGlzIE9wdGlvbmFsIG9iamVjdCBlcXVhbCB0byBgcmhzYD9cbiAqL1xuZXhwb3J0IGNvbnN0IGlzID0gPFQ+KGxoczogT3B0aW9uYWw8VD4sIHJoczogVCwgY29tcGFyYXRvcjogKGE6IFQsIGI6IFQpID0+IGJvb2xlYW4gPSBGdW4udHJpcGxlRXF1YWxzKTogYm9vbGVhbiA9PlxuICBsaHMuZXhpc3RzKChsZWZ0KSA9PiBjb21wYXJhdG9yKGxlZnQsIHJocykpO1xuXG4vKipcbiAqIEFyZSB0aGVzZSB0d28gT3B0aW9uYWwgb2JqZWN0cyBlcXVhbD8gRXF1YWxpdHkgaGVyZSBtZWFucyBlaXRoZXIgdGhleSdyZSBib3RoXG4gKiBgU29tZWAgKGFuZCB0aGUgdmFsdWVzIGFyZSBlcXVhbCB1bmRlciB0aGUgY29tcGFyYXRvcikgb3IgdGhleSdyZSBib3RoIGBOb25lYC5cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsczoge1xuICA8QSwgQj4obGhzOiBPcHRpb25hbDxBPiwgcmhzOiBPcHRpb25hbDxCPiwgY29tcGFyYXRvcjogKGE6IEEsIGI6IEIpID0+IGJvb2xlYW4pOiBib29sZWFuO1xuICA8VD4obGhzOiBPcHRpb25hbDxUPiwgcmhzOiBPcHRpb25hbDxUPik6IGJvb2xlYW47XG59ID0gPEEsIEI+KGxoczogT3B0aW9uYWw8QT4sIHJoczogT3B0aW9uYWw8Qj4sIGNvbXBhcmF0b3I6IChhOiBBLCBiOiBCKSA9PiBib29sZWFuID0gRnVuLnRyaXBsZUVxdWFscyBhcyBhbnkpOiBib29sZWFuID0+XG4gIGxpZnQyKGxocywgcmhzLCBjb21wYXJhdG9yKS5nZXRPcihsaHMuaXNOb25lKCkgJiYgcmhzLmlzTm9uZSgpKTtcblxuZXhwb3J0IGNvbnN0IGNhdCA9IDxBPihhcnI6IE9wdGlvbmFsPEE+W10pOiBBW10gPT4ge1xuICBjb25zdCByOiBBW10gPSBbXTtcbiAgY29uc3QgcHVzaCA9ICh4OiBBKSA9PiB7XG4gICAgci5wdXNoKHgpO1xuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGFycltpXS5lYWNoKHB1c2gpO1xuICB9XG4gIHJldHVybiByO1xufTtcblxuZXhwb3J0IGNvbnN0IHNlcXVlbmNlID0gPEE+IChhcnI6IEFycmF5TGlrZTxPcHRpb25hbDxBPj4pOiBPcHRpb25hbDxBcnJheTxBPj4gPT4ge1xuICBjb25zdCByOiBBW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB4ID0gYXJyW2ldO1xuICAgIGlmICh4LmlzU29tZSgpKSB7XG4gICAgICByLnB1c2goeC5nZXRPckRpZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLm5vbmU8QXJyYXk8QT4+KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPcHRpb25hbC5zb21lKHIpO1xufTtcblxuLyoqIEBkZXByZWNhdGVkIFVzZSBBcnIuZmluZE1hcCBpbnN0ZWFkLiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRNYXAgPSBBcnIuZmluZE1hcDtcblxuLyoqIE1hcCBlYWNoIGVsZW1lbnQgb2YgYW4gYXJyYXkgdG8gYW4gT3B0aW9uYWwgYW5kIGNvbGxlY3QgdGhlIHJlc3VsdHMuXG4gKiAgSWYgYWxsIHJlc3VsdHMgYXJlIFwic29tZVwiLCByZXR1cm4gT3B0aW9uYWwuc29tZSBvZiB0aGUgcmVzdWx0cy5cbiAqICBJZiBhbnkgcmVzdWx0IGlzIFwibm9uZVwiLCByZXR1cm4gT3B0aW9uYWwubm9uZVxuICovXG5leHBvcnQgY29uc3QgdHJhdmVyc2UgPSA8QSwgQj4gKGFycjogQXJyYXlMaWtlPEE+LCBmOiAoYTogQSkgPT4gT3B0aW9uYWw8Qj4pOiBPcHRpb25hbDxBcnJheTxCPj4gPT5cbiAgc2VxdWVuY2UoQXJyLm1hcChhcnIsIGYpKTtcblxuLypcbk5vdGVzIG9uIHRoZSBsaWZ0IGZ1bmN0aW9uczpcbi0gV2UgdXNlZCB0byBoYXZlIGEgZ2VuZXJpYyBsaWZ0TiwgYnV0IHdlIHdlcmUgY29uY2VybmVkIGFib3V0IGl0cyB0eXBlLXNhZmV0eSwgYW5kIHRoZSBiZWxvdyB2YXJpYW50cyB3ZXJlIGZhc3RlciBpbiBtaWNyb2JlbmNobWFya3MuXG4tIFRoZSBnZXRPckRpZSBjYWxscyBhcmUgcGFydGlhbCBmdW5jdGlvbnMsIGJ1dCBhcmUgY2hlY2tlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIGZhc3RlciBhbmQgbW9yZSBjb252ZW5pZW50IChidXQgbGVzcyBzYWZlKSB0aGFuIGZvbGRzLlxuLSAmJiBpcyB1c2VkIGluc3RlYWQgb2YgYSBsb29wIGZvciBzaW1wbGljaXR5IGFuZCBwZXJmb3JtYW5jZS5cbiovXG5cbmV4cG9ydCBjb25zdCBsaWZ0MiA9IDxBLCBCLCBDPiAob2E6IE9wdGlvbmFsPEE+LCBvYjogT3B0aW9uYWw8Qj4sIGY6IChhOiBBLCBiOiBCKSA9PiBDKTogT3B0aW9uYWw8Qz4gPT5cbiAgb2EuaXNTb21lKCkgJiYgb2IuaXNTb21lKCkgPyBPcHRpb25hbC5zb21lKGYob2EuZ2V0T3JEaWUoKSwgb2IuZ2V0T3JEaWUoKSkpIDogT3B0aW9uYWwubm9uZTxDPigpO1xuXG5leHBvcnQgY29uc3QgbGlmdDMgPSA8QSwgQiwgQywgRD4gKG9hOiBPcHRpb25hbDxBPiwgb2I6IE9wdGlvbmFsPEI+LCBvYzogT3B0aW9uYWw8Qz4sIGY6IChhOiBBLCBiOiBCLCBjOiBDKSA9PiBEKTogT3B0aW9uYWw8RD4gPT5cbiAgb2EuaXNTb21lKCkgJiYgb2IuaXNTb21lKCkgJiYgb2MuaXNTb21lKCkgPyBPcHRpb25hbC5zb21lKGYob2EuZ2V0T3JEaWUoKSwgb2IuZ2V0T3JEaWUoKSwgb2MuZ2V0T3JEaWUoKSkpIDogT3B0aW9uYWwubm9uZTxEPigpO1xuXG5leHBvcnQgY29uc3QgbGlmdDQgPSA8QSwgQiwgQywgRCwgRT4gKG9hOiBPcHRpb25hbDxBPiwgb2I6IE9wdGlvbmFsPEI+LCBvYzogT3B0aW9uYWw8Qz4sIG9kOiBPcHRpb25hbDxEPiwgZjogKGE6IEEsIGI6IEIsIGM6IEMsIGQ6IEQpID0+IEUpOiBPcHRpb25hbDxFPiA9PlxuICBvYS5pc1NvbWUoKSAmJiBvYi5pc1NvbWUoKSAmJiBvYy5pc1NvbWUoKSAmJiBvZC5pc1NvbWUoKSA/IE9wdGlvbmFsLnNvbWUoZihvYS5nZXRPckRpZSgpLCBvYi5nZXRPckRpZSgpLCBvYy5nZXRPckRpZSgpLCBvZC5nZXRPckRpZSgpKSkgOiBPcHRpb25hbC5ub25lPEU+KCk7XG5cbmV4cG9ydCBjb25zdCBsaWZ0NSA9IDxBLCBCLCBDLCBELCBFLCBGPiAob2E6IE9wdGlvbmFsPEE+LCBvYjogT3B0aW9uYWw8Qj4sIG9jOiBPcHRpb25hbDxDPiwgb2Q6IE9wdGlvbmFsPEQ+LCBvZTogT3B0aW9uYWw8RT4sIGY6IChhOiBBLCBiOiBCLCBjOiBDLCBkOiBELCBlOiBFKSA9PiBGKTogT3B0aW9uYWw8Rj4gPT5cbiAgb2EuaXNTb21lKCkgJiYgb2IuaXNTb21lKCkgJiYgb2MuaXNTb21lKCkgJiYgb2QuaXNTb21lKCkgJiYgb2UuaXNTb21lKCkgPyBPcHRpb25hbC5zb21lKGYob2EuZ2V0T3JEaWUoKSwgb2IuZ2V0T3JEaWUoKSwgb2MuZ2V0T3JEaWUoKSwgb2QuZ2V0T3JEaWUoKSwgb2UuZ2V0T3JEaWUoKSkpIDogT3B0aW9uYWwubm9uZTxGPigpO1xuXG5leHBvcnQgY29uc3QgbWFwRnJvbSA9IDxBLCBCPiAoYTogQSB8IG51bGwgfCB1bmRlZmluZWQsIGY6IChhOiBBKSA9PiBCKTogT3B0aW9uYWw8Qj4gPT5cbiAgKGEgIT09IHVuZGVmaW5lZCAmJiBhICE9PSBudWxsKSA/IE9wdGlvbmFsLnNvbWUoZihhKSkgOiBPcHRpb25hbC5ub25lPEI+KCk7XG5cbmV4cG9ydCBjb25zdCBiaW5kRnJvbSA9IDxBLCBCPiAoYTogQSB8IG51bGwgfCB1bmRlZmluZWQsIGY6IChhOiBBKSA9PiBPcHRpb25hbDxCPik6IE9wdGlvbmFsPEI+ID0+XG4gIChhICE9PSB1bmRlZmluZWQgJiYgYSAhPT0gbnVsbCkgPyBmKGEpIDogT3B0aW9uYWwubm9uZTxCPigpO1xuXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IDxUPiAob290OiBPcHRpb25hbDxPcHRpb25hbDxUPj4pOiBPcHRpb25hbDxUPiA9PiBvb3QuYmluZChGdW4uaWRlbnRpdHkpO1xuXG4vLyBUaGlzIGNhbiBoZWxwIHdpdGggdHlwZSBpbmZlcmVuY2UsIGJ5IHNwZWNpZnlpbmcgdGhlIHR5cGUgcGFyYW0gb24gdGhlIG5vbmUgY2FzZSwgc28gdGhlIGNhbGxlciBkb2Vzbid0IGhhdmUgdG8uXG5leHBvcnQgY29uc3Qgc29tZUlmID0gPEE+IChiOiBib29sZWFuLCBhOiBBKTogT3B0aW9uYWw8QT4gPT5cbiAgYiA/IE9wdGlvbmFsLnNvbWUoYSkgOiBPcHRpb25hbC5ub25lPEE+KCk7XG4iLCJpbXBvcnQgeyBHbG9iYWwgfSBmcm9tICcuL0dsb2JhbCc7XG5cbi8qKiBwYXRoIDo6IChbU3RyaW5nXSwgSnNPYmo/KSAtPiBKc09iaiAqL1xuZXhwb3J0IGNvbnN0IHBhdGggPSA8VD4ocGFydHM6IHN0cmluZ1tdLCBzY29wZT86IHt9KTogVCB8IHVuZGVmaW5lZCA9PiB7XG4gIGxldCBvID0gc2NvcGUgIT09IHVuZGVmaW5lZCAmJiBzY29wZSAhPT0gbnVsbCA/IHNjb3BlIDogR2xvYmFsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAmJiBvICE9PSB1bmRlZmluZWQgJiYgbyAhPT0gbnVsbDsgKytpKSB7XG4gICAgbyA9IG9bcGFydHNbaV1dO1xuICB9XG4gIHJldHVybiBvO1xufTtcblxuLyoqIHJlc29sdmUgOjogKFN0cmluZywgSnNPYmo/KSAtPiBKc09iaiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmUgPSA8VD4ocDogc3RyaW5nLCBzY29wZT86IHt9KTogVCB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IHBhcnRzID0gcC5zcGxpdCgnLicpO1xuICByZXR1cm4gcGF0aChwYXJ0cywgc2NvcGUpO1xufTtcblxuLyoqIHN0ZXAgOjogKEpzT2JqLCBTdHJpbmcpIC0+IEpzT2JqICovXG5leHBvcnQgY29uc3Qgc3RlcCA9IDxUIGV4dGVuZHMge30sIEsgZXh0ZW5kcyBrZXlvZiBUPihvOiBULCBwYXJ0OiBLKTogVFtLXSA9PiB7XG4gIGlmIChvW3BhcnRdID09PSB1bmRlZmluZWQgfHwgb1twYXJ0XSA9PT0gbnVsbCkge1xuICAgIG9bcGFydF0gPSB7fSBhcyBUW0tdO1xuICB9XG4gIHJldHVybiBvW3BhcnRdO1xufTtcblxuLyoqIGZvcmdlIDo6IChbU3RyaW5nXSwgSnNPYmo/KSAtPiBKc09iaiAqL1xuZXhwb3J0IGNvbnN0IGZvcmdlID0gPFQgZXh0ZW5kcyBzdHJpbmdbXT4ocGFydHM6IFQsIHRhcmdldD86IHt9KTogeyBbIEsgaW4gVFtudW1iZXJdXToge319ID0+IHtcbiAgbGV0IG8gPSB0YXJnZXQgIT09IHVuZGVmaW5lZCA/IHRhcmdldCA6IEdsb2JhbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIG8gPSBzdGVwKG8sIHBhcnRzW2ldKTtcbiAgfVxuICByZXR1cm4gbztcbn07XG5cbi8qKiBuYW1lc3BhY2UgOjogKFN0cmluZywgSnNPYmo/KSAtPiBKc09iaiAqL1xuZXhwb3J0IGNvbnN0IG5hbWVzcGFjZSA9IChuYW1lOiBzdHJpbmcsIHRhcmdldD86IHt9KTogeyBba2V5OiBzdHJpbmddOiB7fX0gPT4ge1xuICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZvcmdlKHBhcnRzLCB0YXJnZXQpO1xufTtcbiIsImltcG9ydCAqIGFzIFN0ckFwcGVuZCBmcm9tICcuLi9zdHIvU3RyQXBwZW5kJztcblxuaW1wb3J0IHsgT3B0aW9uYWwgfSBmcm9tICcuL09wdGlvbmFsJztcbmltcG9ydCAqIGFzIFR5cGUgZnJvbSAnLi9UeXBlJztcblxuY29uc3QgY2hlY2tSYW5nZSA9IChzdHI6IHN0cmluZywgc3Vic3RyOiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIpOiBib29sZWFuID0+XG4gIHN1YnN0ciA9PT0gJycgfHwgc3RyLmxlbmd0aCA+PSBzdWJzdHIubGVuZ3RoICYmIHN0ci5zdWJzdHIoc3RhcnQsIHN0YXJ0ICsgc3Vic3RyLmxlbmd0aCkgPT09IHN1YnN0cjtcblxuLyoqIEdpdmVuIGEgc3RyaW5nIGFuZCBvYmplY3QsIHBlcmZvcm0gdGVtcGxhdGUtcmVwbGFjZW1lbnRzIG9uIHRoZSBzdHJpbmcsIGFzIHNwZWNpZmllZCBieSB0aGUgb2JqZWN0LlxuICogQW55IHRlbXBsYXRlIGZpZWxkcyBvZiB0aGUgZm9ybSAke25hbWV9IGFyZSByZXBsYWNlZCBieSB0aGUgc3RyaW5nIG9yIG51bWJlciBzcGVjaWZpZWQgYXMgb2JqW1wibmFtZVwiXVxuICogQmFzZWQgb24gRG91Z2xhcyBDcm9ja2ZvcmQncyAnc3VwcGxhbnQnIG1ldGhvZCBmb3IgdGVtcGxhdGUtcmVwbGFjZSBvZiBzdHJpbmdzLiBVc2VzIGRpZmZlcmVudCB0ZW1wbGF0ZSBmb3JtYXQuXG4gKi9cbmV4cG9ydCBjb25zdCBzdXBwbGFudCA9IChzdHI6IHN0cmluZywgb2JqOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXI+KTogc3RyaW5nID0+IHtcbiAgY29uc3QgaXNTdHJpbmdPck51bWJlciA9IChhOiB1bmtub3duKTogYSBpcyBzdHJpbmcgfCBudW1iZXIgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgYTtcbiAgICByZXR1cm4gdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXCRcXHsoW157fV0qKVxcfS9nLFxuICAgIChmdWxsTWF0Y2g6IHN0cmluZywga2V5OiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICByZXR1cm4gaXNTdHJpbmdPck51bWJlcih2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogZnVsbE1hdGNoO1xuICAgIH1cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZW1vdmVMZWFkaW5nID0gKHN0cjogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzdGFydHNXaXRoKHN0ciwgcHJlZml4KSA/IFN0ckFwcGVuZC5yZW1vdmVGcm9tU3RhcnQoc3RyLCBwcmVmaXgubGVuZ3RoKSA6IHN0cjtcbn07XG5cbmV4cG9ydCBjb25zdCByZW1vdmVUcmFpbGluZyA9IChzdHI6IHN0cmluZywgc3VmZml4OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gZW5kc1dpdGgoc3RyLCBzdWZmaXgpID8gU3RyQXBwZW5kLnJlbW92ZUZyb21FbmQoc3RyLCBzdWZmaXgubGVuZ3RoKSA6IHN0cjtcbn07XG5cbmV4cG9ydCBjb25zdCBlbnN1cmVMZWFkaW5nID0gKHN0cjogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzdGFydHNXaXRoKHN0ciwgcHJlZml4KSA/IHN0ciA6IFN0ckFwcGVuZC5hZGRUb1N0YXJ0KHN0ciwgcHJlZml4KTtcbn07XG5cbmV4cG9ydCBjb25zdCBlbnN1cmVUcmFpbGluZyA9IChzdHI6IHN0cmluZywgc3VmZml4OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gZW5kc1dpdGgoc3RyLCBzdWZmaXgpID8gc3RyIDogU3RyQXBwZW5kLmFkZFRvRW5kKHN0ciwgc3VmZml4KTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb250YWlucyA9IChzdHI6IHN0cmluZywgc3Vic3RyOiBzdHJpbmcsIHN0YXJ0OiBudW1iZXIgPSAwLCBlbmQ/OiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgY29uc3QgaWR4ID0gc3RyLmluZGV4T2Yoc3Vic3RyLCBzdGFydCk7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgcmV0dXJuIFR5cGUuaXNVbmRlZmluZWQoZW5kKSA/IHRydWUgOiBpZHggKyBzdWJzdHIubGVuZ3RoIDw9IGVuZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBjYXBpdGFsaXplID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0ciA9PT0gJycgPyAnJyA6IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKiogRG9lcyAnc3RyJyBzdGFydCB3aXRoICdwcmVmaXgnP1xuICogIE5vdGU6IGFsbCBzdHJpbmdzIHN0YXJ0IHdpdGggdGhlIGVtcHR5IHN0cmluZy5cbiAqICAgICAgICBNb3JlIGZvcm1hbGx5LCBmb3IgYWxsIHN0cmluZ3MgeCwgc3RhcnRzV2l0aCh4LCBcIlwiKS5cbiAqICAgICAgICBUaGlzIGlzIHNvIHRoYXQgZm9yIGFsbCBzdHJpbmdzIHggYW5kIHksIHN0YXJ0c1dpdGgoeSArIHgsIHkpXG4gKi9cbmV4cG9ydCBjb25zdCBzdGFydHNXaXRoID0gKHN0cjogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gY2hlY2tSYW5nZShzdHIsIHByZWZpeCwgMCk7XG59O1xuXG4vKiogRG9lcyAnc3RyJyBlbmQgd2l0aCAnc3VmZml4Jz9cbiAqICBOb3RlOiBhbGwgc3RyaW5ncyBlbmQgd2l0aCB0aGUgZW1wdHkgc3RyaW5nLlxuICogICAgICAgIE1vcmUgZm9ybWFsbHksIGZvciBhbGwgc3RyaW5ncyB4LCBlbmRzV2l0aCh4LCBcIlwiKS5cbiAqICAgICAgICBUaGlzIGlzIHNvIHRoYXQgZm9yIGFsbCBzdHJpbmdzIHggYW5kIHksIGVuZHNXaXRoKHggKyB5LCB5KVxuICovXG5leHBvcnQgY29uc3QgZW5kc1dpdGggPSAoc3RyOiBzdHJpbmcsIHN1ZmZpeDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHJldHVybiBjaGVja1JhbmdlKHN0ciwgc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCk7XG59O1xuXG5jb25zdCBibGFuayA9IChyOiBSZWdFeHApID0+IChzOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgcy5yZXBsYWNlKHIsICcnKTtcblxuLyoqIHJlbW92ZXMgYWxsIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcyAqL1xuZXhwb3J0IGNvbnN0IHRyaW06IChzOiBzdHJpbmcpID0+IHN0cmluZyA9XG4gIGJsYW5rKC9eXFxzK3xcXHMrJC9nKTtcblxuZXhwb3J0IGNvbnN0IGxUcmltOiAoczogc3RyaW5nKSA9PiBzdHJpbmcgPVxuICBibGFuaygvXlxccysvZyk7XG5cbmV4cG9ydCBjb25zdCByVHJpbTogKHM6IHN0cmluZykgPT4gc3RyaW5nID1cbiAgYmxhbmsoL1xccyskL2cpO1xuXG5leHBvcnQgY29uc3QgaXNOb3RFbXB0eSA9IChzOiBzdHJpbmcpOiBib29sZWFuID0+IHMubGVuZ3RoID4gMDtcblxuZXhwb3J0IGNvbnN0IGlzRW1wdHkgPSAoczogc3RyaW5nKTogYm9vbGVhbiA9PiAhaXNOb3RFbXB0eShzKTtcblxuZXhwb3J0IGNvbnN0IHJlcGVhdCA9IChzOiBzdHJpbmcsIGNvdW50OiBudW1iZXIpOiBzdHJpbmcgPT4gY291bnQgPD0gMCA/ICcnIDogbmV3IEFycmF5KGNvdW50ICsgMSkuam9pbihzKTtcblxuZXhwb3J0IGNvbnN0IGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuZXhwb3J0IGNvbnN0IHRvSW50ID0gKHZhbHVlOiBzdHJpbmcsIHJhZGl4OiBudW1iZXIgPSAxMCk6IE9wdGlvbmFsPG51bWJlcj4gPT4ge1xuICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSwgcmFkaXgpO1xuICByZXR1cm4gaXNOYU4obnVtKSA/IE9wdGlvbmFsLm5vbmUoKSA6IE9wdGlvbmFsLnNvbWUobnVtKTtcbn07XG5cbmV4cG9ydCBjb25zdCB0b0Zsb2F0ID0gKHZhbHVlOiBzdHJpbmcpOiBPcHRpb25hbDxudW1iZXI+ID0+IHtcbiAgY29uc3QgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiBpc05hTihudW0pID8gT3B0aW9uYWwubm9uZSgpIDogT3B0aW9uYWwuc29tZShudW0pO1xufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby13cmFwcGVyLW9iamVjdC10eXBlcyAqL1xuY29uc3QgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbmludGVyZmFjZSBDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgT2JqZWN0PiB7XG4gIHJlYWRvbmx5IHByb3RvdHlwZTogVDtcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xufVxuXG5jb25zdCBoYXNQcm90byA9IDxUIGV4dGVuZHMgT2JqZWN0Pih2OiBPYmplY3QsIGNvbnN0cnVjdG9yOiBDb25zdHJ1Y3RvcjxUPiwgcHJlZGljYXRlOiAodjogT2JqZWN0LCBwcm90b3R5cGU6IFQpID0+IGJvb2xlYW4pOiBib29sZWFuID0+IHtcbiAgaWYgKHByZWRpY2F0ZSh2LCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nLWJhc2VkIGZhbGxiYWNrIHRpbWVcbiAgICByZXR1cm4gdi5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gY29uc3RydWN0b3IubmFtZTtcbiAgfVxufTtcblxuY29uc3QgdHlwZU9mID0gKHg6IGFueSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgeDtcbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfSBlbHNlIGlmICh0ID09PSAnb2JqZWN0JyAmJiBoYXNQcm90byh4LCBTdHJpbmcsIChvLCBwcm90bykgPT4gcHJvdG8uaXNQcm90b3R5cGVPZihvKSkpIHtcbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbn07XG5cbmNvbnN0IGlzVHlwZSA9IDxZb2xvPih0eXBlOiBzdHJpbmcpID0+ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgWW9sbyA9PlxuICB0eXBlT2YodmFsdWUpID09PSB0eXBlO1xuXG5jb25zdCBpc1NpbXBsZVR5cGUgPSA8WW9sbz4odHlwZTogc3RyaW5nKSA9PiAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFlvbG8gPT5cbiAgdHlwZW9mIHZhbHVlID09PSB0eXBlO1xuXG5jb25zdCBlcSA9IDxUPiAodDogVCkgPT4gKGE6IGFueSk6IGEgaXMgVCA9PlxuICB0ID09PSBhO1xuXG5leHBvcnQgY29uc3QgaXMgPSA8RSBleHRlbmRzIE9iamVjdD4odmFsdWU6IGFueSwgY29uc3RydWN0b3I6IENvbnN0cnVjdG9yPEU+KTogdmFsdWUgaXMgRSA9PlxuICBpc09iamVjdCh2YWx1ZSkgJiYgaGFzUHJvdG88RT4odmFsdWUsIGNvbnN0cnVjdG9yLCAobywgcHJvdG8pID0+IGdldFByb3RvdHlwZU9mKG8pID09PSBwcm90byk7XG5cbmV4cG9ydCBjb25zdCBpc1N0cmluZzogKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIHN0cmluZyA9XG4gIGlzVHlwZSgnc3RyaW5nJyk7XG5cbmV4cG9ydCBjb25zdCBpc09iamVjdDogKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIE9iamVjdCA9XG4gIGlzVHlwZSgnb2JqZWN0Jyk7XG5cbmV4cG9ydCBjb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgT2JqZWN0ID0+XG4gIGlzKHZhbHVlLCBPYmplY3QpO1xuXG5leHBvcnQgY29uc3QgaXNBcnJheTogKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIEFycmF5PHVua25vd24+ID1cbiAgaXNUeXBlKCdhcnJheScpO1xuXG5leHBvcnQgY29uc3QgaXNOdWxsOiAoYTogYW55KSA9PiBhIGlzIG51bGwgPVxuICBlcShudWxsKTtcblxuZXhwb3J0IGNvbnN0IGlzQm9vbGVhbjogKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIGJvb2xlYW4gPVxuICBpc1NpbXBsZVR5cGU8Ym9vbGVhbj4oJ2Jvb2xlYW4nKTtcblxuZXhwb3J0IGNvbnN0IGlzVW5kZWZpbmVkOiAoYTogYW55KSA9PiBhIGlzIHVuZGVmaW5lZCA9XG4gIGVxKHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBjb25zdCBpc051bGxhYmxlID0gKGE6IGFueSk6IGEgaXMgbnVsbCB8IHVuZGVmaW5lZCA9PlxuICBhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZDtcblxuZXhwb3J0IGNvbnN0IGlzTm9uTnVsbGFibGUgPSA8QT4gKGE6IEEgfCBudWxsIHwgdW5kZWZpbmVkKTogYSBpcyBOb25OdWxsYWJsZTxBPiA9PlxuICAhaXNOdWxsYWJsZShhKTtcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb246ICh2YWx1ZTogYW55KSA9PiB2YWx1ZSBpcyBGdW5jdGlvbiA9XG4gIGlzU2ltcGxlVHlwZTxGdW5jdGlvbj4oJ2Z1bmN0aW9uJyk7XG5cbmV4cG9ydCBjb25zdCBpc051bWJlcjogKHZhbHVlOiBhbnkpID0+IHZhbHVlIGlzIG51bWJlciA9XG4gIGlzU2ltcGxlVHlwZTxudW1iZXI+KCdudW1iZXInKTtcblxuZXhwb3J0IGNvbnN0IGlzQXJyYXlPZiA9IDxFPih2YWx1ZTogYW55LCBwcmVkOiAoeDogYW55KSA9PiB4IGlzIEUpOiB2YWx1ZSBpcyBBcnJheTxFPiA9PiB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKCEocHJlZCh2YWx1ZVtpXSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzUHJvbWlzZUxpa2UgPSAoeDogYW55KTogeCBpcyBQcm9taXNlPHVua25vd24+ID0+XG4gIGlzT2JqZWN0KHgpXG4gICYmIGlzRnVuY3Rpb24oeC50aGVuKVxuICAmJiBpc0Z1bmN0aW9uKHguY2F0Y2gpO1xuIiwiZXhwb3J0IGNvbnN0IGFkZFRvU3RhcnQgPSAoc3RyOiBzdHJpbmcsIHByZWZpeDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHByZWZpeCArIHN0cjtcbn07XG5cbmV4cG9ydCBjb25zdCBhZGRUb0VuZCA9IChzdHI6IHN0cmluZywgc3VmZml4OiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gc3RyICsgc3VmZml4O1xufTtcblxuZXhwb3J0IGNvbnN0IHJlbW92ZUZyb21TdGFydCA9IChzdHI6IHN0cmluZywgbnVtQ2hhcnM6IG51bWJlcik6IHN0cmluZyA9PiB7XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKG51bUNoYXJzKTtcbn07XG5cbmV4cG9ydCBjb25zdCByZW1vdmVGcm9tRW5kID0gKHN0cjogc3RyaW5nLCBudW1DaGFyczogbnVtYmVyKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIG51bUNoYXJzKTtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbmNvbnN0IHV1aWRWNEJ5dGVzID0gKCk6IFVpbnQ4QXJyYXkgPT4ge1xuICBjb25zdCBieXRlcyA9IHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjIjc2VjdGlvbi00LjEuM1xuICAvLyBUaGlzIHdpbGwgZmlyc3QgYml0IG1hc2sgYXdheSB0aGUgbW9zdCBzaWduaWZpY2FudCA0IGJpdHMgKHZlcnNpb24gb2N0ZXQpXG4gIC8vIHRoZW4gbWFzayBpbiB0aGUgdjQgbnVtYmVyIHdlIG9ubHkgY2FyZSBhYm91dCB2NCByYW5kb20gdmVyc2lvbiBhdCB0aGlzIHBvaW50IHNvIChieXRlICYgMGIwMDAwMTExMSB8IDBiMDEwMDAwMDApXG4gIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAxNSB8IDY0O1xuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyI3NlY3Rpb24tNC4xLjFcbiAgLy8gVGhpcyB3aWxsIGZpcnN0IGJpdCBtYXNrIGF3YXkgdGhlIGhpZ2hlc3QgdHdvIGJpdHMgdGhlbiBtYXNrcyBpbiB0aGUgaGlnaGVzdCBiaXQgc28gKGJ5dGUgJiAwYjAwMTExMTExIHwgMGIxMDAwMDAwMClcbiAgLy8gU28gaXQgd2lsbCBzZXQgdGhlIE1zYjA9MSAmIE1zYjE9MCBkZXNjcmliZWQgYnkgdGhlIFwiVGhlIHZhcmlhbnQgc3BlY2lmaWVkIGluIHRoaXMgZG9jdW1lbnQuXCIgcm93IGluIHRoZSB0YWJsZVxuICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgNjMgfCAxMjg7XG5cbiAgcmV0dXJuIGJ5dGVzO1xufTtcblxuY29uc3QgdXVpZFY0U3RyaW5nID0gKCk6IGAke3N0cmluZ30tJHtzdHJpbmd9LSR7c3RyaW5nfS0ke3N0cmluZ30tJHtzdHJpbmd9YCA9PiB7XG4gIGNvbnN0IHV1aWQgPSB1dWlkVjRCeXRlcygpO1xuICBjb25zdCBnZXRIZXhSYW5nZSA9IChzdGFydEluZGV4OiBudW1iZXIsIGVuZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICBsZXQgYnVmZiA9ICcnO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDw9IGVuZEluZGV4OyArK2kpIHtcbiAgICAgIGNvbnN0IGhleEJ5dGUgPSB1dWlkW2ldLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgYnVmZiArPSBoZXhCeXRlO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZjtcbiAgfTtcbiAgLy8gUkZDIDQxMjIgVVVJRCBmb3JtYXQ6IHh4eHh4eHh4LXh4eHgteHh4eC14eHh4LXh4eHh4eHh4eHh4eFxuICByZXR1cm4gYCR7Z2V0SGV4UmFuZ2UoMCwgMyl9LSR7Z2V0SGV4UmFuZ2UoNCwgNSl9LSR7Z2V0SGV4UmFuZ2UoNiwgNyl9LSR7Z2V0SGV4UmFuZ2UoOCwgOSl9LSR7Z2V0SGV4UmFuZ2UoMTAsIDE1KX1gO1xufTtcblxuZXhwb3J0IHtcbiAgdXVpZFY0Qnl0ZXMsXG4gIHV1aWRWNFN0cmluZ1xufTtcbiIsImltcG9ydCB0eXBlIHsgU3BvdERlbHRhLCBTcG90UG9pbnQsIFNwb3RQb2ludHMsIFNwb3RSYW5nZSwgU3BvdFRleHQgfSBmcm9tICcuL1R5cGVzJztcblxuY29uc3QgcG9pbnQgPSA8RT4oZWxlbWVudDogRSwgb2Zmc2V0OiBudW1iZXIpOiBTcG90UG9pbnQ8RT4gPT4gKHtcbiAgZWxlbWVudCxcbiAgb2Zmc2V0XG59KTtcblxuY29uc3QgZGVsdGEgPSA8RT4oZWxlbWVudDogRSwgZGVsdGFPZmZzZXQ6IG51bWJlcik6IFNwb3REZWx0YTxFPiA9PiAoe1xuICBlbGVtZW50LFxuICBkZWx0YU9mZnNldFxufSk7XG5cbmNvbnN0IHJhbmdlID0gPEU+KGVsZW1lbnQ6IEUsIHN0YXJ0OiBudW1iZXIsIGZpbmlzaDogbnVtYmVyKTogU3BvdFJhbmdlPEU+ID0+ICh7XG4gIGVsZW1lbnQsXG4gIHN0YXJ0LFxuICBmaW5pc2hcbn0pO1xuXG5jb25zdCBwb2ludHMgPSA8RT4oYmVnaW46IFNwb3RQb2ludDxFPiwgZW5kOiBTcG90UG9pbnQ8RT4pOiBTcG90UG9pbnRzPEU+ID0+ICh7XG4gIGJlZ2luLFxuICBlbmRcbn0pO1xuXG5jb25zdCB0ZXh0ID0gPEU+KGVsZW1lbnQ6IEUsIHRleHQ6IHN0cmluZyk6IFNwb3RUZXh0PEU+ID0+ICh7XG4gIGVsZW1lbnQsXG4gIHRleHRcbn0pO1xuXG5leHBvcnQge1xuICBwb2ludCxcbiAgZGVsdGEsXG4gIHJhbmdlLFxuICBwb2ludHMsXG4gIHRleHRcbn07XG4iLCJpbXBvcnQgeyBEb21Vbml2ZXJzZSB9IGZyb20gJ0BlcGhveC9ib3NzJztcbmltcG9ydCB0eXBlIHsgU3VnYXJFbGVtZW50IH0gZnJvbSAnQGVwaG94L3N1Z2FyJztcblxuaW1wb3J0IHR5cGUgeyBTcG90UG9pbnQgfSBmcm9tICcuLi9kYXRhL1R5cGVzJztcbmltcG9ydCAqIGFzIERlc2NlbnQgZnJvbSAnLi4vZ2VuZXJhbC9EZXNjZW50JztcblxuY29uc3QgdW5pdmVyc2UgPSBEb21Vbml2ZXJzZSgpO1xuY29uc3QgdG9MZWFmID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudCwgb2Zmc2V0OiBudW1iZXIpOiBTcG90UG9pbnQ8U3VnYXJFbGVtZW50PiA9PiB7XG4gIHJldHVybiBEZXNjZW50LnRvTGVhZih1bml2ZXJzZSwgZWxlbWVudCwgb2Zmc2V0KTtcbn07XG5cbi8qIFRoZSBwdXJwb3NlIG9mIGZyZWVmYWxsIGlzIHRoYXQgdGhleSB3aWxsIGxhbmQgb24gYW4gZWxlbWVudCB0aGF0IGlzIG5vdCB3aGl0ZXNwYWNlIHRleHQuIFRoaXNcbiAqIGNhbiBiZSB2ZXJ5IHVzZWZ1bCBpbnNpZGUgYmVhdXRpZmllZCBjb250ZW50XG4gKi9cbmNvbnN0IGZyZWVmYWxsTHRyID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudCk6IFNwb3RQb2ludDxTdWdhckVsZW1lbnQ+ID0+IHtcbiAgcmV0dXJuIERlc2NlbnQuZnJlZWZhbGxMdHIodW5pdmVyc2UsIGVsZW1lbnQpO1xufTtcblxuY29uc3QgZnJlZWZhbGxSdGwgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50KTogU3BvdFBvaW50PFN1Z2FyRWxlbWVudD4gPT4ge1xuICByZXR1cm4gRGVzY2VudC5mcmVlZmFsbFJ0bCh1bml2ZXJzZSwgZWxlbWVudCk7XG59O1xuXG5leHBvcnQge1xuICB0b0xlYWYsXG4gIGZyZWVmYWxsTHRyLFxuICBmcmVlZmFsbFJ0bFxufTtcbiIsImltcG9ydCB0eXBlIHsgVW5pdmVyc2UgfSBmcm9tICdAZXBob3gvYm9zcyc7XG5cbmltcG9ydCAqIGFzIE5hdmlnYXRpb24gZnJvbSAnLi4vLi4vd3JhcC9OYXZpZ2F0aW9uJztcbmltcG9ydCB0eXBlIHsgU3BvdFBvaW50IH0gZnJvbSAnLi4vZGF0YS9UeXBlcyc7XG5cbnR5cGUgVG9MZWFmQXBpID0gPEUsIEQ+KHVuaXZlcnNlOiBVbml2ZXJzZTxFLCBEPiwgZWxlbWVudDogRSwgb2Zmc2V0OiBudW1iZXIpID0+IFNwb3RQb2ludDxFPjtcbmNvbnN0IHRvTGVhZjogVG9MZWFmQXBpID0gTmF2aWdhdGlvbi50b0xlYWY7XG5cbnR5cGUgRnJlZWZhbGxMdHJBcGkgPSA8RSwgRD4odW5pdmVyc2U6IFVuaXZlcnNlPEUsIEQ+LCBlbGVtZW50OiBFKSA9PiBTcG90UG9pbnQ8RT47XG5jb25zdCBmcmVlZmFsbEx0cjogRnJlZWZhbGxMdHJBcGkgPSBOYXZpZ2F0aW9uLmZyZWVmYWxsTHRyO1xuXG50eXBlIEZyZWVmYWxsUnRsQXBpID0gPEUsIEQ+KHVuaXZlcnNlOiBVbml2ZXJzZTxFLCBEPiwgZWxlbWVudDogRSkgPT4gU3BvdFBvaW50PEU+O1xuY29uc3QgZnJlZWZhbGxSdGw6IEZyZWVmYWxsUnRsQXBpID0gTmF2aWdhdGlvbi5mcmVlZmFsbFJ0bDtcblxuZXhwb3J0IHtcbiAgdG9MZWFmLFxuICBmcmVlZmFsbEx0cixcbiAgZnJlZWZhbGxSdGxcbn07IiwiaW1wb3J0IHR5cGUgeyBVbml2ZXJzZSB9IGZyb20gJ0BlcGhveC9ib3NzJztcbmltcG9ydCB7IE9wdGlvbmFsIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuaW1wb3J0ICogYXMgU3BvdCBmcm9tICcuLi9hcGkvZGF0YS9TcG90JztcbmltcG9ydCB0eXBlIHsgU3BvdFBvaW50IH0gZnJvbSAnLi4vYXBpL2RhdGEvVHlwZXMnO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGFzdCBhdmFpbGFibGUgY3Vyc29yIHBvc2l0aW9uIGluIHRoZSBub2RlLlxuICovXG5jb25zdCB0b0xhc3QgPSA8RSwgRD4odW5pdmVyc2U6IFVuaXZlcnNlPEUsIEQ+LCBub2RlOiBFKTogU3BvdFBvaW50PEU+ID0+IHtcbiAgaWYgKHVuaXZlcnNlLnByb3BlcnR5KCkuaXNUZXh0KG5vZGUpKSB7XG4gICAgcmV0dXJuIFNwb3QucG9pbnQobm9kZSwgdW5pdmVyc2UucHJvcGVydHkoKS5nZXRUZXh0KG5vZGUpLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB1bml2ZXJzZS5wcm9wZXJ0eSgpLmNoaWxkcmVuKG5vZGUpO1xuICAgIC8vIGtlZXAgZGVzY2VuZGluZyBpZiB0aGVyZSBhcmUgY2hpbGRyZW4uXG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA+IDAgPyB0b0xhc3QodW5pdmVyc2UsIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdKSA6IFNwb3QucG9pbnQobm9kZSwgY2hpbGRyZW4ubGVuZ3RoKTtcbiAgfVxufTtcblxuY29uc3QgdG9Mb3dlciA9IDxFLCBEPih1bml2ZXJzZTogVW5pdmVyc2U8RSwgRD4sIG5vZGU6IEUpOiBTcG90UG9pbnQ8RT4gPT4ge1xuICBjb25zdCBsYXN0T2Zmc2V0ID0gdW5pdmVyc2UucHJvcGVydHkoKS5pc1RleHQobm9kZSkgP1xuICAgIHVuaXZlcnNlLnByb3BlcnR5KCkuZ2V0VGV4dChub2RlKS5sZW5ndGggOlxuICAgIHVuaXZlcnNlLnByb3BlcnR5KCkuY2hpbGRyZW4obm9kZSkubGVuZ3RoO1xuICByZXR1cm4gU3BvdC5wb2ludChub2RlLCBsYXN0T2Zmc2V0KTtcbn07XG5cbi8qKlxuICogRGVzY2VuZCBkb3duIHRvIGEgbGVhZiBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKi9cbmNvbnN0IHRvTGVhZiA9IDxFLCBEPih1bml2ZXJzZTogVW5pdmVyc2U8RSwgRD4sIGVsZW1lbnQ6IEUsIG9mZnNldDogbnVtYmVyKTogU3BvdFBvaW50PEU+ID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSB1bml2ZXJzZS5wcm9wZXJ0eSgpLmNoaWxkcmVuKGVsZW1lbnQpO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBvZmZzZXQgPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gdG9MZWFmKHVuaXZlcnNlLCBjaGlsZHJlbltvZmZzZXRdLCAwKTtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwICYmIHVuaXZlcnNlLnByb3BlcnR5KCkuaXNFbGVtZW50KGVsZW1lbnQpICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gb2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRvTGFzdCh1bml2ZXJzZSwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBTcG90LnBvaW50KGVsZW1lbnQsIG9mZnNldCk7XG4gIH1cbn07XG5cbmNvbnN0IHNjYW4gPSA8RSwgRD4odW5pdmVyc2U6IFVuaXZlcnNlPEUsIEQ+LCBlbGVtZW50OiBFLCBkaXJlY3Rpb246IChlOiBFKSA9PiBPcHRpb25hbDxFPik6IE9wdGlvbmFsPEU+ID0+IHtcbiAgLy8gaWYgYSBjb21tZW50IG9yIHplcm8tbGVuZ3RoIHRleHQsIHNjYW4gdGhlIHNpYmxpbmdzXG4gIGlmICgodW5pdmVyc2UucHJvcGVydHkoKS5pc1RleHQoZWxlbWVudCkgJiYgdW5pdmVyc2UucHJvcGVydHkoKS5nZXRUZXh0KGVsZW1lbnQpLnRyaW0oKS5sZW5ndGggPT09IDApXG4gICAgfHwgdW5pdmVyc2UucHJvcGVydHkoKS5pc0NvbW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uKGVsZW1lbnQpLmJpbmQoKGVsZW0pID0+IHtcbiAgICAgIHJldHVybiBzY2FuKHVuaXZlcnNlLCBlbGVtLCBkaXJlY3Rpb24pLm9yVGh1bmsoKCkgPT4ge1xuICAgICAgICByZXR1cm4gT3B0aW9uYWwuc29tZShlbGVtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPcHRpb25hbC5ub25lKCk7XG4gIH1cbn07XG5cbmNvbnN0IGZyZWVmYWxsTHRyID0gPEUsIEQ+KHVuaXZlcnNlOiBVbml2ZXJzZTxFLCBEPiwgZWxlbWVudDogRSk6IFNwb3RQb2ludDxFPiA9PiB7XG4gIGNvbnN0IGNhbmRpZGF0ZSA9IHNjYW4odW5pdmVyc2UsIGVsZW1lbnQsIHVuaXZlcnNlLnF1ZXJ5KCkubmV4dFNpYmxpbmcpLmdldE9yKGVsZW1lbnQpO1xuICBpZiAodW5pdmVyc2UucHJvcGVydHkoKS5pc1RleHQoY2FuZGlkYXRlKSkge1xuICAgIHJldHVybiBTcG90LnBvaW50KGNhbmRpZGF0ZSwgMCk7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSB1bml2ZXJzZS5wcm9wZXJ0eSgpLmNoaWxkcmVuKGNhbmRpZGF0ZSk7XG4gIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPiAwID8gZnJlZWZhbGxMdHIodW5pdmVyc2UsIGNoaWxkcmVuWzBdKSA6IFNwb3QucG9pbnQoY2FuZGlkYXRlLCAwKTtcbn07XG5cbmNvbnN0IHRvRW5kID0gPEUsIEQ+KHVuaXZlcnNlOiBVbml2ZXJzZTxFLCBEPiwgZWxlbWVudDogRSk6IG51bWJlciA9PiB7XG4gIGlmICh1bml2ZXJzZS5wcm9wZXJ0eSgpLmlzVGV4dChlbGVtZW50KSkge1xuICAgIHJldHVybiB1bml2ZXJzZS5wcm9wZXJ0eSgpLmdldFRleHQoZWxlbWVudCkubGVuZ3RoO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gdW5pdmVyc2UucHJvcGVydHkoKS5jaGlsZHJlbihlbGVtZW50KTtcbiAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aDtcbn07XG5cbmNvbnN0IGZyZWVmYWxsUnRsID0gPEUsIEQ+KHVuaXZlcnNlOiBVbml2ZXJzZTxFLCBEPiwgZWxlbWVudDogRSk6IFNwb3RQb2ludDxFPiA9PiB7XG4gIGNvbnN0IGNhbmRpZGF0ZSA9IHNjYW4odW5pdmVyc2UsIGVsZW1lbnQsIHVuaXZlcnNlLnF1ZXJ5KCkucHJldlNpYmxpbmcpLmdldE9yKGVsZW1lbnQpO1xuICBpZiAodW5pdmVyc2UucHJvcGVydHkoKS5pc1RleHQoY2FuZGlkYXRlKSkge1xuICAgIHJldHVybiBTcG90LnBvaW50KGNhbmRpZGF0ZSwgdG9FbmQodW5pdmVyc2UsIGNhbmRpZGF0ZSkpO1xuICB9XG4gIGNvbnN0IGNoaWxkcmVuID0gdW5pdmVyc2UucHJvcGVydHkoKS5jaGlsZHJlbihjYW5kaWRhdGUpO1xuICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID4gMCA/IGZyZWVmYWxsUnRsKHVuaXZlcnNlLCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSkgOiBTcG90LnBvaW50KGNhbmRpZGF0ZSwgdG9FbmQodW5pdmVyc2UsIGNhbmRpZGF0ZSkpO1xufTtcblxuZXhwb3J0IHtcbiAgdG9MYXN0LFxuICB0b0xlYWYsXG4gIHRvTG93ZXIsXG4gIGZyZWVmYWxsTHRyLFxuICBmcmVlZmFsbFJ0bFxufTtcbiIsImltcG9ydCB7IFJlc29sdmUsIFR5cGUgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgKiBhcyBHbG9iYWwgZnJvbSAnLi4vdXRpbC9HbG9iYWwnO1xuXG5jb25zdCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuLypcbiAqIElFOSBhbmQgYWJvdmVcbiAqXG4gKiBNRE4gbm8gdXNlIG9uIHRoaXMgb25lLCBidXQgaGVyZSdzIHRoZSBsaW5rIGFueXdheTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MRWxlbWVudFxuICovXG5jb25zdCBzYW5kSFRNTEVsZW1lbnQgPSAoc2NvcGU6IFdpbmRvdyB8IHVuZGVmaW5lZCkgPT4ge1xuICByZXR1cm4gR2xvYmFsLmdldE9yRGllKCdIVE1MRWxlbWVudCcsIHNjb3BlKSBhcyB0eXBlb2YgSFRNTEVsZW1lbnQ7XG59O1xuXG5jb25zdCBpc1Byb3RvdHlwZU9mID0gKHg6IGFueSk6IHggaXMgSFRNTEVsZW1lbnQgPT4ge1xuICAvLyB1c2UgUmVzb2x2ZSB0byBnZXQgdGhlIHdpbmRvdyBvYmplY3QgZm9yIHggYW5kIGp1c3QgcmV0dXJuIHVuZGVmaW5lZCBpZiBpdCBjYW4ndCBmaW5kIGl0LlxuICAvLyB1bmRlZmluZWQgc2NvcGUgbGF0ZXIgdHJpZ2dlcnMgdXNpbmcgdGhlIGdsb2JhbCB3aW5kb3cuXG4gIGNvbnN0IHNjb3BlOiBXaW5kb3cgfCB1bmRlZmluZWQgPSBSZXNvbHZlLnJlc29sdmUoJ293bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcnLCB4KTtcblxuICAvLyBUSU5ZLTczNzQ6IFdlIGNhbid0IHJlbHkgb24gbG9va2luZyBhdCB0aGUgb3duZXIgd2luZG93IEhUTUxFbGVtZW50IGFzIHRoZSBlbGVtZW50IG1heSBoYXZlXG4gIC8vIGJlZW4gY29uc3RydWN0ZWQgaW4gYSBkaWZmZXJlbnQgd2luZG93IGFuZCB0aGVuIGFwcGVuZGVkIHRvIHRoZSBjdXJyZW50IHdpbmRvdyBkb2N1bWVudC5cbiAgcmV0dXJuIFR5cGUuaXNPYmplY3QoeCkgJiYgKHNhbmRIVE1MRWxlbWVudChzY29wZSkucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoeCkgfHwgL15IVE1MXFx3KkVsZW1lbnQkLy50ZXN0KGdldFByb3RvdHlwZU9mKHgpLmNvbnN0cnVjdG9yLm5hbWUpKTtcbn07XG5cbmV4cG9ydCB7XG4gIGlzUHJvdG90eXBlT2Zcbn07XG4iLCJpbXBvcnQgeyBSZXNvbHZlIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuY29uc3QgdW5zYWZlID0gPFQ+KG5hbWU6IHN0cmluZywgc2NvcGU/OiB7fSk6IFQgfCB1bmRlZmluZWQgPT4ge1xuICByZXR1cm4gUmVzb2x2ZS5yZXNvbHZlKG5hbWUsIHNjb3BlKTtcbn07XG5cbmNvbnN0IGdldE9yRGllID0gPFQ+KG5hbWU6IHN0cmluZywgc2NvcGU/OiB7fSk6IFQgPT4ge1xuICBjb25zdCBhY3R1YWwgPSB1bnNhZmU8VD4obmFtZSwgc2NvcGUpO1xuXG4gIGlmIChhY3R1YWwgPT09IHVuZGVmaW5lZCB8fCBhY3R1YWwgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgbm90IGF2YWlsYWJsZSBvbiB0aGlzIGJyb3dzZXInKTtcbiAgfVxuICByZXR1cm4gYWN0dWFsO1xufTtcblxuZXhwb3J0IHtcbiAgZ2V0T3JEaWVcbn07XG4iLCJpbXBvcnQgdHlwZSB7IE9wdGlvbmFsIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuLyoqXG4gKiBBcHBsaWVzIGYgcmVwZWF0ZWRseSB1bnRpbCBpdCBjb21wbGV0ZXMgKGJ5IHJldHVybmluZyBPcHRpb25hbC5ub25lKCkpLlxuICpcbiAqIE5vcm1hbGx5IHdvdWxkIGp1c3QgdXNlIHJlY3Vyc2lvbiwgYnV0IEphdmFTY3JpcHQgbGFja3MgdGFpbCBjYWxsIG9wdGltaXNhdGlvbi5cbiAqXG4gKiBUaGlzIGlzIHdoYXQgcmVjdXJzaW9uIGxvb2tzIGxpa2Ugd2hlbiBtYW51YWxseSB1bnJhdmVsbGVkIDopXG4gKi9cbmNvbnN0IHRvQXJyYXkgPSA8VCA9IGFueSwgVSBleHRlbmRzIFQgPSBUPiAodGFyZ2V0OiBULCBmOiAodDogVCkgPT4gT3B0aW9uYWw8VT4pOiBVW10gPT4ge1xuICBjb25zdCByOiBVW10gPSBbXTtcblxuICBjb25zdCByZWN1cnNlID0gKGU6IFUpID0+IHtcbiAgICByLnB1c2goZSk7XG4gICAgcmV0dXJuIGYoZSk7XG4gIH07XG5cbiAgbGV0IGN1ciA9IGYodGFyZ2V0KTtcbiAgZG8ge1xuICAgIGN1ciA9IGN1ci5iaW5kKHJlY3Vyc2UpO1xuICB9IHdoaWxlIChjdXIuaXNTb21lKCkpO1xuXG4gIHJldHVybiByO1xufTtcblxuZXhwb3J0IHtcbiAgdG9BcnJheVxufTtcbiIsImltcG9ydCB7IEFyciwgRnVuIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuaW1wb3J0IHR5cGUgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuLi9ub2RlL1N1Z2FyRWxlbWVudCc7XG5pbXBvcnQgKiBhcyBTZWxlY3RvcnMgZnJvbSAnLi4vc2VhcmNoL1NlbGVjdG9ycyc7XG5cbmNvbnN0IGVxID0gKGUxOiBTdWdhckVsZW1lbnQ8dW5rbm93bj4sIGUyOiBTdWdhckVsZW1lbnQ8dW5rbm93bj4pOiBib29sZWFuID0+XG4gIGUxLmRvbSA9PT0gZTIuZG9tO1xuXG5jb25zdCBpc0VxdWFsTm9kZSA9IChlMTogU3VnYXJFbGVtZW50PE5vZGU+LCBlMjogU3VnYXJFbGVtZW50PE5vZGU+KTogYm9vbGVhbiA9PlxuICBlMS5kb20uaXNFcXVhbE5vZGUoZTIuZG9tKTtcblxuY29uc3QgbWVtYmVyID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDx1bmtub3duPiwgZWxlbWVudHM6IFN1Z2FyRWxlbWVudDx1bmtub3duPltdKTogYm9vbGVhbiA9PlxuICBBcnIuZXhpc3RzKGVsZW1lbnRzLCBGdW4uY3VycnkoZXEsIGVsZW1lbnQpKTtcblxuLy8gUmV0dXJuczogdHJ1ZSBpZiBub2RlIGUxIGNvbnRhaW5zIGUyLCBvdGhlcndpc2UgZmFsc2UuXG4vLyAocmV0dXJucyBmYWxzZSBpZiBlMT09PWUyOiBBIG5vZGUgZG9lcyBub3QgY29udGFpbiBpdHNlbGYpLlxuY29uc3QgY29udGFpbnMgPSAoZTE6IFN1Z2FyRWxlbWVudDxOb2RlPiwgZTI6IFN1Z2FyRWxlbWVudDxOb2RlPik6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBkMSA9IGUxLmRvbTtcbiAgY29uc3QgZDIgPSBlMi5kb207XG4gIHJldHVybiBkMSA9PT0gZDIgPyBmYWxzZSA6IGQxLmNvbnRhaW5zKGQyKTtcbn07XG5cbmNvbnN0IGlzID0gU2VsZWN0b3JzLmlzO1xuXG5leHBvcnQge1xuICBlcSxcbiAgaXNFcXVhbE5vZGUsXG4gIG1lbWJlcixcbiAgY29udGFpbnMsXG4gIC8vIE9ubHkgdXNlZCBieSBEb21Vbml2ZXJzZS4gUmVtb3ZlIChvciBzaG91bGQgU2VsZWN0b3JzLmlzIG1vdmUgaGVyZT8pXG4gIGlzXG59O1xuIiwiaW1wb3J0IHR5cGUgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuLi9ub2RlL1N1Z2FyRWxlbWVudCc7XG5pbXBvcnQgKiBhcyBUcmF2ZXJzZSBmcm9tICcuLi9zZWFyY2gvVHJhdmVyc2UnO1xuXG5jb25zdCBiZWZvcmUgPSAobWFya2VyOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IHZvaWQgPT4ge1xuICBjb25zdCBwYXJlbnQgPSBUcmF2ZXJzZS5wYXJlbnQobWFya2VyKTtcbiAgcGFyZW50LmVhY2goKHYpID0+IHtcbiAgICB2LmRvbS5pbnNlcnRCZWZvcmUoZWxlbWVudC5kb20sIG1hcmtlci5kb20pO1xuICB9KTtcbn07XG5cbmNvbnN0IGFmdGVyID0gKG1hcmtlcjogU3VnYXJFbGVtZW50PE5vZGU+LCBlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiB2b2lkID0+IHtcbiAgY29uc3Qgc2libGluZyA9IFRyYXZlcnNlLm5leHRTaWJsaW5nKG1hcmtlcik7XG4gIHNpYmxpbmcuZm9sZCgoKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gVHJhdmVyc2UucGFyZW50KG1hcmtlcik7XG4gICAgcGFyZW50LmVhY2goKHYpID0+IHtcbiAgICAgIGFwcGVuZCh2LCBlbGVtZW50KTtcbiAgICB9KTtcbiAgfSwgKHYpID0+IHtcbiAgICBiZWZvcmUodiwgZWxlbWVudCk7XG4gIH0pO1xufTtcblxuY29uc3QgcHJlcGVuZCA9IChwYXJlbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPiwgZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogdm9pZCA9PiB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBUcmF2ZXJzZS5maXJzdENoaWxkKHBhcmVudCk7XG4gIGZpcnN0Q2hpbGQuZm9sZCgoKSA9PiB7XG4gICAgYXBwZW5kKHBhcmVudCwgZWxlbWVudCk7XG4gIH0sICh2KSA9PiB7XG4gICAgcGFyZW50LmRvbS5pbnNlcnRCZWZvcmUoZWxlbWVudC5kb20sIHYuZG9tKTtcbiAgfSk7XG59O1xuXG5jb25zdCBhcHBlbmQgPSAocGFyZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IHZvaWQgPT4ge1xuICBwYXJlbnQuZG9tLmFwcGVuZENoaWxkKGVsZW1lbnQuZG9tKTtcbn07XG5cbmNvbnN0IGFwcGVuZEF0ID0gKHBhcmVudDogU3VnYXJFbGVtZW50PE5vZGU+LCBlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGluZGV4OiBudW1iZXIpOiB2b2lkID0+IHtcbiAgVHJhdmVyc2UuY2hpbGQocGFyZW50LCBpbmRleCkuZm9sZCgoKSA9PiB7XG4gICAgYXBwZW5kKHBhcmVudCwgZWxlbWVudCk7XG4gIH0sICh2KSA9PiB7XG4gICAgYmVmb3JlKHYsIGVsZW1lbnQpO1xuICB9KTtcbn07XG5cbmNvbnN0IHdyYXAgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+LCB3cmFwcGVyOiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiB2b2lkID0+IHtcbiAgYmVmb3JlKGVsZW1lbnQsIHdyYXBwZXIpO1xuICBhcHBlbmQod3JhcHBlciwgZWxlbWVudCk7XG59O1xuXG5leHBvcnQge1xuICBiZWZvcmUsXG4gIGFmdGVyLFxuICBwcmVwZW5kLFxuICBhcHBlbmQsXG4gIGFwcGVuZEF0LFxuICB3cmFwXG59O1xuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuaW1wb3J0IHR5cGUgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuLi9ub2RlL1N1Z2FyRWxlbWVudCc7XG5cbmltcG9ydCAqIGFzIEluc2VydCBmcm9tICcuL0luc2VydCc7XG5cbmNvbnN0IGJlZm9yZSA9IChtYXJrZXI6IFN1Z2FyRWxlbWVudDxOb2RlPiwgZWxlbWVudHM6IFN1Z2FyRWxlbWVudDxOb2RlPltdKTogdm9pZCA9PiB7XG4gIEFyci5lYWNoKGVsZW1lbnRzLCAoeCkgPT4ge1xuICAgIEluc2VydC5iZWZvcmUobWFya2VyLCB4KTtcbiAgfSk7XG59O1xuXG5jb25zdCBhZnRlciA9IChtYXJrZXI6IFN1Z2FyRWxlbWVudDxOb2RlPiwgZWxlbWVudHM6IFN1Z2FyRWxlbWVudDxOb2RlPltdKTogdm9pZCA9PiB7XG4gIEFyci5lYWNoKGVsZW1lbnRzLCAoeCwgaSkgPT4ge1xuICAgIGNvbnN0IGUgPSBpID09PSAwID8gbWFya2VyIDogZWxlbWVudHNbaSAtIDFdO1xuICAgIEluc2VydC5hZnRlcihlLCB4KTtcbiAgfSk7XG59O1xuXG5jb25zdCBwcmVwZW5kID0gKHBhcmVudDogU3VnYXJFbGVtZW50PE5vZGU+LCBlbGVtZW50czogU3VnYXJFbGVtZW50PE5vZGU+W10pOiB2b2lkID0+IHtcbiAgQXJyLmVhY2goZWxlbWVudHMuc2xpY2UoKS5yZXZlcnNlKCksICh4KSA9PiB7XG4gICAgSW5zZXJ0LnByZXBlbmQocGFyZW50LCB4KTtcbiAgfSk7XG59O1xuXG5jb25zdCBhcHBlbmQgPSAocGFyZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGVsZW1lbnRzOiBTdWdhckVsZW1lbnQ8Tm9kZT5bXSk6IHZvaWQgPT4ge1xuICBBcnIuZWFjaChlbGVtZW50cywgKHgpID0+IHtcbiAgICBJbnNlcnQuYXBwZW5kKHBhcmVudCwgeCk7XG4gIH0pO1xufTtcblxuZXhwb3J0IHtcbiAgYmVmb3JlLFxuICBhZnRlcixcbiAgcHJlcGVuZCxcbiAgYXBwZW5kXG59O1xuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuaW1wb3J0IHR5cGUgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuLi9ub2RlL1N1Z2FyRWxlbWVudCc7XG5pbXBvcnQgKiBhcyBUcmF2ZXJzZSBmcm9tICcuLi9zZWFyY2gvVHJhdmVyc2UnO1xuXG5pbXBvcnQgKiBhcyBJbnNlcnRBbGwgZnJvbSAnLi9JbnNlcnRBbGwnO1xuXG5jb25zdCBlbXB0eSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiB2b2lkID0+IHtcbiAgLy8gc2hvcnRjdXQgXCJlbXB0eSBub2RlXCIgdHJpY2suIFJlcXVpcmVzIElFIDkuXG4gIGVsZW1lbnQuZG9tLnRleHRDb250ZW50ID0gJyc7XG5cbiAgLy8gSWYgdGhlIGNvbnRlbnRzIHdhcyBhIHNpbmdsZSBlbXB0eSB0ZXh0IG5vZGUsIHRoZSBhYm92ZSBkb2Vzbid0IHJlbW92ZSBpdC4gQnV0LCBpdCdzIHN0aWxsIGZhc3RlciBpbiBnZW5lcmFsXG4gIC8vIHRoYW4gcmVtb3ZpbmcgZXZlcnkgY2hpbGQgbm9kZSBtYW51YWxseS5cbiAgLy8gVGhlIGZvbGxvd2luZyBpcyAocHJvYmFibHkpIHNhZmUgZm9yIHBlcmZvcm1hbmNlIGFzIDk5LjklIG9mIHRoZSB0aW1lIHRoZSB0cmljayB3b3JrcyBhbmRcbiAgLy8gVHJhdmVyc2UuY2hpbGRyZW4gd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gIEFyci5lYWNoKFRyYXZlcnNlLmNoaWxkcmVuKGVsZW1lbnQpLCAocm9ndWUpID0+IHtcbiAgICByZW1vdmUocm9ndWUpO1xuICB9KTtcbn07XG5cbmNvbnN0IHJlbW92ZSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiB2b2lkID0+IHtcbiAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gIGlmIChkb20ucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gIH1cbn07XG5cbmNvbnN0IHVud3JhcCA9ICh3cmFwcGVyOiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiB2b2lkID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBUcmF2ZXJzZS5jaGlsZHJlbih3cmFwcGVyKTtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICBJbnNlcnRBbGwuYWZ0ZXIod3JhcHBlciwgY2hpbGRyZW4pO1xuICB9XG4gIHJlbW92ZSh3cmFwcGVyKTtcbn07XG5cbmV4cG9ydCB7XG4gIGVtcHR5LFxuICByZW1vdmUsXG4gIHVud3JhcFxufTtcbiIsImNvbnN0IEFUVFJJQlVURSA9IDI7XG5jb25zdCBDREFUQV9TRUNUSU9OID0gNDtcbmNvbnN0IENPTU1FTlQgPSA4O1xuY29uc3QgRE9DVU1FTlQgPSA5O1xuY29uc3QgRE9DVU1FTlRfVFlQRSA9IDEwO1xuY29uc3QgRE9DVU1FTlRfRlJBR01FTlQgPSAxMTtcbmNvbnN0IEVMRU1FTlQgPSAxO1xuY29uc3QgVEVYVCA9IDM7XG5jb25zdCBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OID0gNztcbmNvbnN0IEVOVElUWV9SRUZFUkVOQ0UgPSA1O1xuY29uc3QgRU5USVRZID0gNjtcbmNvbnN0IE5PVEFUSU9OID0gMTI7XG5cbmV4cG9ydCB7XG4gIEFUVFJJQlVURSxcbiAgQ0RBVEFfU0VDVElPTixcbiAgQ09NTUVOVCxcbiAgRE9DVU1FTlQsXG4gIERPQ1VNRU5UX1RZUEUsXG4gIERPQ1VNRU5UX0ZSQUdNRU5ULFxuICBFTEVNRU5ULFxuICBURVhULFxuICBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OLFxuICBFTlRJVFlfUkVGRVJFTkNFLFxuICBFTlRJVFksXG4gIE5PVEFUSU9OXG59O1xuIiwiaW1wb3J0IHsgRnVuIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuaW1wb3J0IHsgU3VnYXJFbGVtZW50IH0gZnJvbSAnLi9TdWdhckVsZW1lbnQnO1xuaW1wb3J0ICogYXMgU3VnYXJOb2RlIGZyb20gJy4vU3VnYXJOb2RlJztcbmltcG9ydCB7IGdldFNoYWRvd0hvc3QsIGdldFNoYWRvd1Jvb3QgfSBmcm9tICcuL1N1Z2FyU2hhZG93RG9tJztcblxuLy8gTm9kZS5jb250YWlucygpIGlzIHZlcnksIHZlcnksIHZlcnkgZ29vZCBwZXJmb3JtYW5jZVxuLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc2VzdC12cy1jb250YWlucy81XG5jb25zdCBpbkJvZHkgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogYm9vbGVhbiA9PiB7XG4gIC8vIFRlY2huaWNhbGx5IHRoaXMgaXMgb25seSByZXF1aXJlZCBvbiBJRSwgd2hlcmUgY29udGFpbnMoKSByZXR1cm5zIGZhbHNlIGZvciB0ZXh0IG5vZGVzLlxuICAvLyBCdXQgaXQncyBjaGVhcCBlbm91Z2ggdG8gcnVuIGV2ZXJ5d2hlcmUgYW5kIFN1Z2FyIGRvZXNuJ3QgaGF2ZSBwbGF0Zm9ybSBkZXRlY3Rpb24gKHlldCkuXG4gIGNvbnN0IGRvbSA9IFN1Z2FyTm9kZS5pc1RleHQoZWxlbWVudCkgPyBlbGVtZW50LmRvbS5wYXJlbnROb2RlIDogZWxlbWVudC5kb207XG5cbiAgLy8gdXNlIG93bmVyRG9jdW1lbnQuYm9keSB0byBlbnN1cmUgdGhpcyB3b3JrcyBpbnNpZGUgaWZyYW1lcy5cbiAgLy8gTm9ybWFsbHkgY29udGFpbnMgaXMgYmFkIGJlY2F1c2UgYW4gZWxlbWVudCBcImNvbnRhaW5zXCIgaXRzZWxmLCBidXQgaGVyZSB3ZSB3YW50IHRoYXQuXG4gIGlmIChkb20gPT09IHVuZGVmaW5lZCB8fCBkb20gPT09IG51bGwgfHwgZG9tLm93bmVyRG9jdW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBkb2MgPSBkb20ub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIGdldFNoYWRvd1Jvb3QoU3VnYXJFbGVtZW50LmZyb21Eb20oZG9tKSkuZm9sZChcbiAgICAoKSA9PiBkb2MuYm9keS5jb250YWlucyhkb20pLFxuICAgIEZ1bi5jb21wb3NlMShpbkJvZHksIGdldFNoYWRvd0hvc3QpXG4gICk7XG59O1xuXG5jb25zdCBib2R5ID0gKCk6IFN1Z2FyRWxlbWVudDxIVE1MRWxlbWVudD4gPT5cbiAgZ2V0Qm9keShTdWdhckVsZW1lbnQuZnJvbURvbShkb2N1bWVudCkpO1xuXG5jb25zdCBnZXRCb2R5ID0gKGRvYzogU3VnYXJFbGVtZW50PERvY3VtZW50Pik6IFN1Z2FyRWxlbWVudDxIVE1MRWxlbWVudD4gPT4ge1xuICBjb25zdCBiID0gZG9jLmRvbS5ib2R5O1xuICBpZiAoYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvZHkgaXMgbm90IGF2YWlsYWJsZSB5ZXQnKTtcbiAgfVxuICByZXR1cm4gU3VnYXJFbGVtZW50LmZyb21Eb20oYik7XG59O1xuXG5leHBvcnQge1xuICBib2R5LFxuICBnZXRCb2R5LFxuICBpbkJvZHlcbn07XG4iLCJpbXBvcnQgeyBPcHRpb25hbCB9IGZyb20gJ0BlcGhveC9rYXRhbWFyaSc7XG5cbmltcG9ydCB0eXBlIHsgSFRNTEVsZW1lbnRGdWxsVGFnTmFtZU1hcCB9IGZyb20gJy4uLy4uL2FsaWVuL0RvbVR5cGVzJztcblxuaW50ZXJmYWNlIFN1Z2FyRWxlbWVudDxUID0gYW55PiB7XG4gIHJlYWRvbmx5IGRvbTogVDtcbn1cblxuY29uc3QgZnJvbUh0bWwgPSA8RSBleHRlbmRzIE5vZGUgPSBOb2RlICYgQ2hpbGROb2RlPiAoaHRtbDogc3RyaW5nLCBzY29wZT86IERvY3VtZW50IHwgbnVsbCk6IFN1Z2FyRWxlbWVudDxFPiA9PiB7XG4gIGNvbnN0IGRvYyA9IHNjb3BlIHx8IGRvY3VtZW50O1xuICBjb25zdCBkaXYgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBodG1sO1xuICBpZiAoIWRpdi5oYXNDaGlsZE5vZGVzKCkgfHwgZGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSAnSFRNTCBkb2VzIG5vdCBoYXZlIGEgc2luZ2xlIHJvb3Qgbm9kZSc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UsIGh0bWwpO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gZnJvbURvbShkaXYuY2hpbGROb2Rlc1swXSBhcyB1bmtub3duIGFzIEUpO1xufTtcblxuY29uc3QgZnJvbVRhZzoge1xuICA8SyBleHRlbmRzIGtleW9mIEhUTUxFbGVtZW50RnVsbFRhZ05hbWVNYXA+KHRhZzogSywgc2NvcGU/OiBEb2N1bWVudCB8IG51bGwpOiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnRGdWxsVGFnTmFtZU1hcFtLXT47XG4gICh0YWc6IHN0cmluZywgc2NvcGU/OiBEb2N1bWVudCB8IG51bGwpOiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnQ+O1xufSA9ICh0YWc6IHN0cmluZywgc2NvcGU/OiBEb2N1bWVudCB8IG51bGwpOiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnQ+ID0+IHtcbiAgY29uc3QgZG9jID0gc2NvcGUgfHwgZG9jdW1lbnQ7XG4gIGNvbnN0IG5vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCh0YWcpO1xuICByZXR1cm4gZnJvbURvbShub2RlKTtcbn07XG5cbmNvbnN0IGZyb21UZXh0ID0gKHRleHQ6IHN0cmluZywgc2NvcGU/OiBEb2N1bWVudCB8IG51bGwpOiBTdWdhckVsZW1lbnQ8VGV4dD4gPT4ge1xuICBjb25zdCBkb2MgPSBzY29wZSB8fCBkb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgcmV0dXJuIGZyb21Eb20obm9kZSk7XG59O1xuXG5jb25zdCBmcm9tRG9tID0gPFQgZXh0ZW5kcyBOb2RlIHwgV2luZG93PiAobm9kZTogVCk6IFN1Z2FyRWxlbWVudDxUPiA9PiB7XG4gIC8vIFRPRE86IENvbnNpZGVyIHJlbW92aW5nIHRoaXMgY2hlY2ssIGJ1dCBsZWZ0IGF0bSBmb3Igc2FmZXR5XG4gIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRvbTogbm9kZVxuICB9O1xufTtcblxuY29uc3QgZnJvbVBvaW50ID0gKGRvY0VsbTogU3VnYXJFbGVtZW50PERvY3VtZW50PiwgeDogbnVtYmVyLCB5OiBudW1iZXIpOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8RWxlbWVudD4+ID0+XG4gIE9wdGlvbmFsLmZyb20oZG9jRWxtLmRvbS5lbGVtZW50RnJvbVBvaW50KHgsIHkpKS5tYXAoZnJvbURvbSk7XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG5jb25zdCBTdWdhckVsZW1lbnQgPSB7XG4gIGZyb21IdG1sLFxuICBmcm9tVGFnLFxuICBmcm9tVGV4dCxcbiAgZnJvbURvbSxcbiAgZnJvbVBvaW50XG59O1xuXG5leHBvcnQge1xuICBTdWdhckVsZW1lbnRcbn07XG4iLCJpbXBvcnQgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuL1N1Z2FyRWxlbWVudCc7XG5cbmV4cG9ydCBjb25zdCBoZWFkID0gKCk6IFN1Z2FyRWxlbWVudDxIVE1MSGVhZEVsZW1lbnQ+ID0+IGdldEhlYWQoU3VnYXJFbGVtZW50LmZyb21Eb20oZG9jdW1lbnQpKTtcblxuZXhwb3J0IGNvbnN0IGdldEhlYWQgPSAoZG9jOiBTdWdhckVsZW1lbnQ8RG9jdW1lbnQ+KTogU3VnYXJFbGVtZW50PEhUTUxIZWFkRWxlbWVudD4gPT4ge1xuICAvKlxuICAgKiBJRTkgYW5kIGFib3ZlIHBlclxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvaGVhZFxuICAgKi9cbiAgY29uc3QgYiA9IGRvYy5kb20uaGVhZDtcbiAgaWYgKGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkIGlzIG5vdCBhdmFpbGFibGUgeWV0Jyk7XG4gIH1cbiAgcmV0dXJuIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGIpO1xufTtcbiIsImltcG9ydCB7IFNhbmRIVE1MRWxlbWVudCB9IGZyb20gJ0BlcGhveC9zYW5kJztcblxuaW1wb3J0IHR5cGUgeyBIVE1MRWxlbWVudEZ1bGxUYWdOYW1lTWFwIH0gZnJvbSAnLi4vLi4vYWxpZW4vRG9tVHlwZXMnO1xuXG5pbXBvcnQgKiBhcyBOb2RlVHlwZXMgZnJvbSAnLi9Ob2RlVHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuL1N1Z2FyRWxlbWVudCc7XG5cbmNvbnN0IG5hbWUgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogc3RyaW5nID0+IHtcbiAgY29uc3QgciA9IGVsZW1lbnQuZG9tLm5vZGVOYW1lO1xuICByZXR1cm4gci50b0xvd2VyQ2FzZSgpO1xufTtcblxuY29uc3QgdHlwZSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBudW1iZXIgPT5cbiAgZWxlbWVudC5kb20ubm9kZVR5cGU7XG5cbmNvbnN0IHZhbHVlID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IHN0cmluZyB8IG51bGwgPT5cbiAgZWxlbWVudC5kb20ubm9kZVZhbHVlO1xuXG5jb25zdCBpc1R5cGUgPSA8RSBleHRlbmRzIE5vZGU+ICh0OiBudW1iZXIpID0+IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBlbGVtZW50IGlzIFN1Z2FyRWxlbWVudDxFPiA9PlxuICB0eXBlKGVsZW1lbnQpID09PSB0O1xuXG5jb25zdCBpc0NvbW1lbnQgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogZWxlbWVudCBpcyBTdWdhckVsZW1lbnQ8Q29tbWVudD4gPT5cbiAgdHlwZShlbGVtZW50KSA9PT0gTm9kZVR5cGVzLkNPTU1FTlQgfHwgbmFtZShlbGVtZW50KSA9PT0gJyNjb21tZW50JztcblxuY29uc3QgaXNIVE1MRWxlbWVudCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBlbGVtZW50IGlzIFN1Z2FyRWxlbWVudDxIVE1MRWxlbWVudD4gPT5cbiAgaXNFbGVtZW50KGVsZW1lbnQpICYmIFNhbmRIVE1MRWxlbWVudC5pc1Byb3RvdHlwZU9mKGVsZW1lbnQuZG9tKTtcblxuY29uc3QgaXNFbGVtZW50ID0gaXNUeXBlPEVsZW1lbnQ+KE5vZGVUeXBlcy5FTEVNRU5UKTtcbmNvbnN0IGlzVGV4dCA9IGlzVHlwZTxUZXh0PihOb2RlVHlwZXMuVEVYVCk7XG5jb25zdCBpc0RvY3VtZW50ID0gaXNUeXBlPERvY3VtZW50PihOb2RlVHlwZXMuRE9DVU1FTlQpO1xuY29uc3QgaXNEb2N1bWVudEZyYWdtZW50ID0gaXNUeXBlPERvY3VtZW50RnJhZ21lbnQ+KE5vZGVUeXBlcy5ET0NVTUVOVF9GUkFHTUVOVCk7XG5cbmNvbnN0IGlzVGFnID0gPEsgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEZ1bGxUYWdOYW1lTWFwPih0YWc6IEspID0+IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBlIGlzIFN1Z2FyRWxlbWVudDxIVE1MRWxlbWVudEZ1bGxUYWdOYW1lTWFwW0tdPiA9PlxuICBpc0VsZW1lbnQoZSkgJiYgbmFtZShlKSA9PT0gdGFnO1xuXG5leHBvcnQge1xuICBuYW1lLFxuICB0eXBlLFxuICB2YWx1ZSxcbiAgaXNFbGVtZW50LFxuICBpc0hUTUxFbGVtZW50LFxuICBpc1RleHQsXG4gIGlzRG9jdW1lbnQsXG4gIGlzRG9jdW1lbnRGcmFnbWVudCxcbiAgaXNDb21tZW50LFxuICBpc1RhZ1xufTtcbiIsImltcG9ydCB7IEFyciwgT3B0aW9uYWwsIFR5cGUgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgdHlwZSB7IEhUTUxFbGVtZW50RnVsbFRhZ05hbWVNYXAgfSBmcm9tICcuLi8uLi9hbGllbi9Eb21UeXBlcyc7XG5pbXBvcnQgKiBhcyBUcmF2ZXJzZSBmcm9tICcuLi9zZWFyY2gvVHJhdmVyc2UnO1xuXG5pbXBvcnQgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuL1N1Z2FyRWxlbWVudCc7XG5pbXBvcnQgKiBhcyBTdWdhckhlYWQgZnJvbSAnLi9TdWdhckhlYWQnO1xuaW1wb3J0ICogYXMgU3VnYXJOb2RlIGZyb20gJy4vU3VnYXJOb2RlJztcblxuZXhwb3J0IHR5cGUgUm9vdE5vZGUgPSBTdWdhckVsZW1lbnQ8RG9jdW1lbnQgfCBTaGFkb3dSb290PjtcblxuLyoqXG4gKiBJcyB0aGUgZWxlbWVudCBhIFNoYWRvd1Jvb3Q/XG4gKlxuICogTm90ZTogdGhpcyBpcyBpbnN1ZmZpY2llbnQgdG8gdGVzdCBpZiBhbnkgZWxlbWVudCBpcyBhIHNoYWRvdyByb290LCBidXQgaXQgaXMgc3VmZmljaWVudCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW5cbiAqIGEgRG9jdW1lbnQgYW5kIGEgU2hhZG93Um9vdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzU2hhZG93Um9vdCA9IChkb3M6IFN1Z2FyRWxlbWVudDxOb2RlPik6IGRvcyBpcyBTdWdhckVsZW1lbnQ8U2hhZG93Um9vdD4gPT5cbiAgU3VnYXJOb2RlLmlzRG9jdW1lbnRGcmFnbWVudChkb3MpICYmIFR5cGUuaXNOb25OdWxsYWJsZSgoZG9zLmRvbSBhcyBTaGFkb3dSb290KS5ob3N0KTtcblxuZXhwb3J0IGNvbnN0IGdldFJvb3ROb2RlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBSb290Tm9kZSA9IChlKSA9PlxuICBTdWdhckVsZW1lbnQuZnJvbURvbShlLmRvbS5nZXRSb290Tm9kZSgpKSBhcyBSb290Tm9kZTtcblxuLyoqIENyZWF0ZSBhbiBlbGVtZW50LCB1c2luZyB0aGUgYWN0dWFsIGRvY3VtZW50LiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVsZW1lbnQ6IHtcbiAgPEsgZXh0ZW5kcyBrZXlvZiBIVE1MRWxlbWVudEZ1bGxUYWdOYW1lTWFwPihkb3M6IFJvb3ROb2RlLCB0YWc6IEspOiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnRGdWxsVGFnTmFtZU1hcFtLXT47XG4gIChkb3M6IFJvb3ROb2RlLCB0YWc6IHN0cmluZyk6IFN1Z2FyRWxlbWVudDxIVE1MRWxlbWVudD47XG59ID0gKGRvczogUm9vdE5vZGUsIHRhZzogc3RyaW5nKSA9PlxuICBTdWdhckVsZW1lbnQuZnJvbVRhZyh0YWcsIFRyYXZlcnNlLmRvY3VtZW50T3JPd25lcihkb3MpLmRvbSk7XG5cbi8qKiBXaGVyZSBzdHlsZSB0YWdzIG5lZWQgdG8gZ28uIFNoYWRvd1Jvb3Qgb3IgZG9jdW1lbnQgaGVhZCAqL1xuZXhwb3J0IGNvbnN0IGdldFN0eWxlQ29udGFpbmVyID0gKGRvczogUm9vdE5vZGUpOiBTdWdhckVsZW1lbnQ8SFRNTEhlYWRFbGVtZW50IHwgU2hhZG93Um9vdD4gPT5cbiAgaXNTaGFkb3dSb290KGRvcykgPyBkb3MgOiBTdWdhckhlYWQuZ2V0SGVhZChUcmF2ZXJzZS5kb2N1bWVudE9yT3duZXIoZG9zKSk7XG5cbi8qKiBXaGVyZSBjb250ZW50IG5lZWRzIHRvIGdvLiBTaGFkb3dSb290IG9yIGRvY3VtZW50IGJvZHkgKi9cbmV4cG9ydCBjb25zdCBnZXRDb250ZW50Q29udGFpbmVyID0gKGRvczogUm9vdE5vZGUpOiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnQgfCBTaGFkb3dSb290PiA9PlxuICAvLyBDYW4ndCB1c2UgU3VnYXJCb2R5LmJvZHkgd2l0aG91dCBjYXVzaW5nIGEgY2lyY3VsYXIgbW9kdWxlIHJlZmVyZW5jZSAoc2luY2UgU3VnYXJCb2R5LmluQm9keSB1c2VzIFN1Z2FyU2hhZG93RG9tKVxuICBpc1NoYWRvd1Jvb3QoZG9zKSA/IGRvcyA6IFN1Z2FyRWxlbWVudC5mcm9tRG9tKFRyYXZlcnNlLmRvY3VtZW50T3JPd25lcihkb3MpLmRvbS5ib2R5KTtcblxuLyoqIElzIHRoaXMgZWxlbWVudCBlaXRoZXIgYSBTaGFkb3dSb290IG9yIGEgZGVzY2VuZGVudCBvZiBhIFNoYWRvd1Jvb3QuICovXG5leHBvcnQgY29uc3QgaXNJblNoYWRvd1Jvb3QgPSAoZTogU3VnYXJFbGVtZW50PE5vZGU+KTogYm9vbGVhbiA9PlxuICBnZXRTaGFkb3dSb290KGUpLmlzU29tZSgpO1xuXG4vKiogSWYgdGhpcyBlbGVtZW50IGlzIGluIGEgU2hhZG93Um9vdCwgcmV0dXJuIGl0LiAqL1xuZXhwb3J0IGNvbnN0IGdldFNoYWRvd1Jvb3QgPSAoZTogU3VnYXJFbGVtZW50PE5vZGU+KTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PFNoYWRvd1Jvb3Q+PiA9PiB7XG4gIGNvbnN0IHIgPSBnZXRSb290Tm9kZShlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyKSA/IE9wdGlvbmFsLnNvbWUocikgOiBPcHRpb25hbC5ub25lKCk7XG59O1xuXG4vKiogUmV0dXJuIHRoZSBob3N0IG9mIGEgU2hhZG93Um9vdC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgaWYgU2hhZG93IERPTSBpcyB1bnN1cHBvcnRlZCBpbiB0aGUgYnJvd3Nlciwgb3IgaWYgdGhlIGhvc3QgaXMgbnVsbC5cbiAqIElmIHlvdSBhY3R1YWxseSBoYXZlIGEgU2hhZG93Um9vdCwgdGhpcyBzaG91bGRuJ3QgaGFwcGVuLlxuICovXG5leHBvcnQgY29uc3QgZ2V0U2hhZG93SG9zdCA9IChlOiBTdWdhckVsZW1lbnQ8U2hhZG93Um9vdD4pOiBTdWdhckVsZW1lbnQ8RWxlbWVudD4gPT5cbiAgU3VnYXJFbGVtZW50LmZyb21Eb20oZS5kb20uaG9zdCk7XG5cbi8qKlxuICogV2hlbiBFdmVudHMgYnViYmxlIHVwIHRocm91Z2ggYSBTaGFkb3dSb290LCB0aGUgYnJvd3NlciBjaGFuZ2VzIHRoZSB0YXJnZXQgdG8gYmUgdGhlIHNoYWRvdyBob3N0LlxuICogVGhpcyBmdW5jdGlvbiBnZXRzIHRoZSBcIm9yaWdpbmFsXCIgZXZlbnQgdGFyZ2V0IGlmIHBvc3NpYmxlLlxuICogVGhpcyBvbmx5IHdvcmtzIGlmIHRoZSBzaGFkb3cgdHJlZSBpcyBvcGVuIC0gaWYgdGhlIHNoYWRvdyB0cmVlIGlzIGNsb3NlZCwgZXZlbnQudGFyZ2V0IGlzIHJldHVybmVkLlxuICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvZnVuZGFtZW50YWxzL3dlYi1jb21wb25lbnRzL3NoYWRvd2RvbSNldmVudHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldE9yaWdpbmFsRXZlbnRUYXJnZXQgPSAoZXZlbnQ6IEV2ZW50KTogT3B0aW9uYWw8RXZlbnRUYXJnZXQ+ID0+IHtcbiAgaWYgKFR5cGUuaXNOb25OdWxsYWJsZShldmVudC50YXJnZXQpKSB7XG4gICAgY29uc3QgZWwgPSBTdWdhckVsZW1lbnQuZnJvbURvbShldmVudC50YXJnZXQgYXMgTm9kZSk7XG4gICAgaWYgKFN1Z2FyTm9kZS5pc0VsZW1lbnQoZWwpICYmIGlzT3BlblNoYWRvd0hvc3QoZWwpKSB7XG4gICAgICAvLyBXaGVuIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBTaGFkb3cgRE9NIHdlIG5lZWQgdG8gdGFrZSBmaXJzdCBlbGVtZW50IGZyb20gY29tcG9zZWRQYXRoXG4gICAgICAvLyBvdGhlcndpc2Ugd2UnbGwgZ2V0IFNoYWRvdyBSb290IHBhcmVudCwgbm90IGFjdHVhbCB0YXJnZXQgZWxlbWVudC5cbiAgICAgIGlmIChldmVudC5jb21wb3NlZCAmJiBldmVudC5jb21wb3NlZFBhdGgpIHtcbiAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgIGlmIChjb21wb3NlZFBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gQXJyLmhlYWQoY29tcG9zZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gT3B0aW9uYWwuZnJvbShldmVudC50YXJnZXQpO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzT3BlblNoYWRvd1Jvb3QgPSAoc3I6IFN1Z2FyRWxlbWVudDxTaGFkb3dSb290Pik6IGJvb2xlYW4gPT5cbiAgc3IuZG9tLm1vZGUgPT09ICdvcGVuJztcblxuZXhwb3J0IGNvbnN0IGlzQ2xvc2VkU2hhZG93Um9vdCA9IChzcjogU3VnYXJFbGVtZW50PFNoYWRvd1Jvb3Q+KTogYm9vbGVhbiA9PlxuICBzci5kb20ubW9kZSA9PT0gJ2Nsb3NlZCc7XG5cbi8qKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBhIGhvc3Qgb2YgYW4gb3BlbiBzaGFkb3cgcm9vdC5cbiAqICBSZXR1cm4gZmFsc2UgaWYgdGhlIGVsZW1lbnQgaXMgYSBob3N0IG9mIGEgY2xvc2VkIHNoYWRvdyByb290LCBvciBpZiB0aGUgZWxlbWVudCBpcyBub3QgYSBob3N0LlxuICovXG5leHBvcnQgY29uc3QgaXNPcGVuU2hhZG93SG9zdCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8RWxlbWVudD4pOiBib29sZWFuID0+XG4gIFR5cGUuaXNOb25OdWxsYWJsZShlbGVtZW50LmRvbS5zaGFkb3dSb290KTtcbiIsImltcG9ydCB0eXBlIHsgT3B0aW9uYWwgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgeyBOb2RlVmFsdWUgfSBmcm9tICcuLi8uLi9pbXBsL05vZGVWYWx1ZSc7XG5cbmltcG9ydCB0eXBlIHsgU3VnYXJFbGVtZW50IH0gZnJvbSAnLi9TdWdhckVsZW1lbnQnO1xuaW1wb3J0ICogYXMgU3VnYXJOb2RlIGZyb20gJy4vU3VnYXJOb2RlJztcblxuY29uc3QgYXBpID0gTm9kZVZhbHVlKFN1Z2FyTm9kZS5pc1RleHQsICd0ZXh0Jyk7XG5cbmNvbnN0IGdldCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8VGV4dD4pOiBzdHJpbmcgPT5cbiAgYXBpLmdldChlbGVtZW50KTtcblxuY29uc3QgZ2V0T3B0aW9uID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IE9wdGlvbmFsPHN0cmluZz4gPT5cbiAgYXBpLmdldE9wdGlvbihlbGVtZW50KTtcblxuY29uc3Qgc2V0ID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxUZXh0PiwgdmFsdWU6IHN0cmluZyk6IHZvaWQgPT5cbiAgYXBpLnNldChlbGVtZW50LCB2YWx1ZSk7XG5cbmV4cG9ydCB7XG4gIGdldCxcbiAgZ2V0T3B0aW9uLFxuICBzZXRcbn07XG4iLCJpbXBvcnQgeyBBcnIsIE9iaiwgT3B0aW9uYWwsIFR5cGUgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgdHlwZSB7IFN1Z2FyRWxlbWVudCB9IGZyb20gJy4uL25vZGUvU3VnYXJFbGVtZW50JztcbmltcG9ydCAqIGFzIFN1Z2FyTm9kZSBmcm9tICcuLi9ub2RlL1N1Z2FyTm9kZSc7XG5cbmNvbnN0IHJhd1NldCA9IChkb206IEVsZW1lbnQsIGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nIHwgYm9vbGVhbiB8IG51bWJlcik6IHZvaWQgPT4ge1xuICAvKlxuICAgKiBKUXVlcnkgY29lcmNlZCBldmVyeXRoaW5nIHRvIGEgc3RyaW5nLCBhbmQgc2lsZW50bHkgZGlkIG5vdGhpbmcgb24gdGV4dCBub2RlL251bGwvdW5kZWZpbmVkLlxuICAgKlxuICAgKiBXZSBmYWlsIG9uIHRob3NlIGludmFsaWQgY2FzZXMsIG9ubHkgYWxsb3dpbmcgbnVtYmVycyBhbmQgYm9vbGVhbnMuXG4gICAqL1xuICBpZiAoVHlwZS5pc1N0cmluZyh2YWx1ZSkgfHwgVHlwZS5pc0Jvb2xlYW4odmFsdWUpIHx8IFR5cGUuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlICsgJycpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBjYWxsIHRvIEF0dHJpYnV0ZS5zZXQuIEtleSAnLCBrZXksICc6OiBWYWx1ZSAnLCB2YWx1ZSwgJzo6IEVsZW1lbnQgJywgZG9tKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dHJpYnV0ZSB2YWx1ZSB3YXMgbm90IHNpbXBsZScpO1xuICB9XG59O1xuXG5jb25zdCBzZXQgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PEVsZW1lbnQ+LCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyB8IGJvb2xlYW4gfCBudW1iZXIpOiB2b2lkID0+IHtcbiAgcmF3U2V0KGVsZW1lbnQuZG9tLCBrZXksIHZhbHVlKTtcbn07XG5cbmNvbnN0IHNldEFsbCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8RWxlbWVudD4sIGF0dHJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyPik6IHZvaWQgPT4ge1xuICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgT2JqLmVhY2goYXR0cnMsICh2LCBrKSA9PiB7XG4gICAgcmF3U2V0KGRvbSwgaywgdik7XG4gIH0pO1xufTtcblxuY29uc3Qgc2V0T3B0aW9ucyA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8RWxlbWVudD4sIGF0dHJzOiBSZWNvcmQ8c3RyaW5nLCBPcHRpb25hbDxzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyPj4pOiB2b2lkID0+IHtcbiAgT2JqLmVhY2goYXR0cnMsICh2LCBrKSA9PiB7XG4gICAgdi5mb2xkKCgpID0+IHtcbiAgICAgIHJlbW92ZShlbGVtZW50LCBrKTtcbiAgICB9LCAodmFsdWUpID0+IHtcbiAgICAgIHJhd1NldChlbGVtZW50LmRvbSwgaywgdmFsdWUpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmNvbnN0IGdldCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8RWxlbWVudD4sIGtleTogc3RyaW5nKTogdW5kZWZpbmVkIHwgc3RyaW5nID0+IHtcbiAgY29uc3QgdiA9IGVsZW1lbnQuZG9tLmdldEF0dHJpYnV0ZShrZXkpO1xuXG4gIC8vIHVuZGVmaW5lZCBpcyB0aGUgbW9yZSBhcHByb3ByaWF0ZSB2YWx1ZSBmb3IgSlMsIGFuZCB0aGlzIG1hdGNoZXMgSlF1ZXJ5XG4gIHJldHVybiB2ID09PSBudWxsID8gdW5kZWZpbmVkIDogdjtcbn07XG5cbmNvbnN0IGdldE9wdCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8RWxlbWVudD4sIGtleTogc3RyaW5nKTogT3B0aW9uYWw8c3RyaW5nPiA9PlxuICBPcHRpb25hbC5mcm9tKGdldChlbGVtZW50LCBrZXkpKTtcblxuY29uc3QgaGFzID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPiwga2V5OiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG5cbiAgLy8gcmV0dXJuIGZhbHNlIGZvciBub24tZWxlbWVudCBub2Rlcywgbm8gcG9pbnQgaW4gdGhyb3dpbmcgYW4gZXJyb3JcbiAgcmV0dXJuIGRvbSAmJiAoZG9tIGFzIEVsZW1lbnQpLmhhc0F0dHJpYnV0ZSA/IChkb20gYXMgRWxlbWVudCkuaGFzQXR0cmlidXRlKGtleSkgOiBmYWxzZTtcbn07XG5cbmNvbnN0IHJlbW92ZSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8RWxlbWVudD4sIGtleTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIGVsZW1lbnQuZG9tLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xufTtcblxuY29uc3QgaGFzTm9uZSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBib29sZWFuID0+IHtcbiAgY29uc3QgYXR0cnMgPSAoZWxlbWVudC5kb20gYXMgRWxlbWVudCkuYXR0cmlidXRlcztcbiAgcmV0dXJuIGF0dHJzID09PSB1bmRlZmluZWQgfHwgYXR0cnMgPT09IG51bGwgfHwgYXR0cnMubGVuZ3RoID09PSAwO1xufTtcblxuY29uc3QgY2xvbmUgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PEVsZW1lbnQ+KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9PlxuICBBcnIuZm9sZGwoZWxlbWVudC5kb20uYXR0cmlidXRlcywgKGFjYywgYXR0cikgPT4ge1xuICAgIGFjY1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTtcblxuY29uc3QgdHJhbnNmZXJPbmUgPSAoc291cmNlOiBTdWdhckVsZW1lbnQ8RWxlbWVudD4sIGRlc3RpbmF0aW9uOiBTdWdhckVsZW1lbnQ8RWxlbWVudD4sIGF0dHI6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIGNsb2JiZXIgYW55IGV4aXN0aW5nIGF0dHJpYnV0ZXNcbiAgaWYgKCFoYXMoZGVzdGluYXRpb24sIGF0dHIpKSB7XG4gICAgZ2V0T3B0KHNvdXJjZSwgYXR0cikuZWFjaCgoc3JjVmFsdWUpID0+IHNldChkZXN0aW5hdGlvbiwgYXR0ciwgc3JjVmFsdWUpKTtcbiAgfVxufTtcblxuLy8gVHJhbnNmZXIgYXR0cmlidXRlcyhhdHRycykgZnJvbSBzb3VyY2UgdG8gZGVzdGluYXRpb24sIHVubGVzcyB0aGV5IGFyZSBhbHJlYWR5IHByZXNlbnRcbmNvbnN0IHRyYW5zZmVyID0gKHNvdXJjZTogU3VnYXJFbGVtZW50PEVsZW1lbnQ+LCBkZXN0aW5hdGlvbjogU3VnYXJFbGVtZW50PEVsZW1lbnQ+LCBhdHRyczogc3RyaW5nW10pOiB2b2lkID0+IHtcbiAgaWYgKCFTdWdhck5vZGUuaXNFbGVtZW50KHNvdXJjZSkgfHwgIVN1Z2FyTm9kZS5pc0VsZW1lbnQoZGVzdGluYXRpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIEFyci5lYWNoKGF0dHJzLCAoYXR0cikgPT4ge1xuICAgIHRyYW5zZmVyT25lKHNvdXJjZSwgZGVzdGluYXRpb24sIGF0dHIpO1xuICB9KTtcbn07XG5cbmV4cG9ydCB7IGNsb25lLCBzZXQsIHNldEFsbCwgc2V0T3B0aW9ucywgZ2V0LCBnZXRPcHQsIGhhcywgcmVtb3ZlLCBoYXNOb25lLCB0cmFuc2ZlciB9O1xuIiwiaW1wb3J0IHsgQXJyLCBPYmosIE9wdGlvbmFsLCBPcHRpb25hbHMsIFN0cmluZ3MsIFR5cGUgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgKiBhcyBTdHlsZSBmcm9tICcuLi8uLi9pbXBsL1N0eWxlJztcbmltcG9ydCAqIGFzIFN1Z2FyQm9keSBmcm9tICcuLi9ub2RlL1N1Z2FyQm9keSc7XG5pbXBvcnQgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuLi9ub2RlL1N1Z2FyRWxlbWVudCc7XG5pbXBvcnQgKiBhcyBTdWdhck5vZGUgZnJvbSAnLi4vbm9kZS9TdWdhck5vZGUnO1xuXG5pbXBvcnQgKiBhcyBBdHRyaWJ1dGUgZnJvbSAnLi9BdHRyaWJ1dGUnO1xuXG5jb25zdCBpbnRlcm5hbFNldCA9IChkb206IE5vZGUsIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgLy8gVGhpcyBpcyBnb2luZyB0byBodXJ0LiBBcG9sb2dpZXMuXG4gIC8vIEpRdWVyeSBjb2VyY2VzIG51bWJlcnMgdG8gcGl4ZWxzIGZvciBjZXJ0YWluIHByb3BlcnR5IG5hbWVzLCBhbmQgb3RoZXIgdGltZXMgbGV0cyBudW1iZXJzIHRocm91Z2guXG4gIC8vIHdlJ3JlIGdvaW5nIHRvIGJlIGV4cGxpY2l0OyBzdHJpbmdzIG9ubHkuXG4gIGlmICghVHlwZS5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgY2FsbCB0byBDU1Muc2V0LiBQcm9wZXJ0eSAnLCBwcm9wZXJ0eSwgJzo6IFZhbHVlICcsIHZhbHVlLCAnOjogRWxlbWVudCAnLCBkb20pO1xuICAgIHRocm93IG5ldyBFcnJvcignQ1NTIHZhbHVlIG11c3QgYmUgYSBzdHJpbmc6ICcgKyB2YWx1ZSk7XG4gIH1cblxuICAvLyByZW1vdmVkOiBzdXBwb3J0IGZvciBkb20oKS5zdHlsZVtwcm9wZXJ0eV0gd2hlcmUgcHJvcCBpcyBjYW1lbCBjYXNlIGluc3RlYWQgb2Ygbm9ybWFsIHByb3BlcnR5IG5hbWVcbiAgaWYgKFN0eWxlLmlzU3VwcG9ydGVkKGRvbSkpIHtcbiAgICBkb20uc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgfVxufTtcblxuY29uc3QgaW50ZXJuYWxSZW1vdmUgPSAoZG9tOiBOb2RlLCBwcm9wZXJ0eTogc3RyaW5nKTogdm9pZCA9PiB7XG4gIC8qXG4gICAqIElFOSBhbmQgYWJvdmUgLSBNRE4gZG9lc24ndCBoYXZlIGRldGFpbHMsIGJ1dCBoZXJlJ3MgYSBjb3VwbGUgb2YgcmFuZG9tIGludGVybmV0IGNsYWltc1xuICAgKlxuICAgKiBodHRwOi8vaGVscC5kb3R0b3JvLmNvbS9sam9wc2pjay5waHBcbiAgICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzkwMTg4Ni83NTQ2XG4gICAqL1xuICBpZiAoU3R5bGUuaXNTdXBwb3J0ZWQoZG9tKSkge1xuICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gIH1cbn07XG5cbmNvbnN0IHNldCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG4gIGludGVybmFsU2V0KGRvbSwgcHJvcGVydHksIHZhbHVlKTtcbn07XG5cbmNvbnN0IHNldEFsbCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGNzczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IHZvaWQgPT4ge1xuICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcblxuICBPYmouZWFjaChjc3MsICh2LCBrKSA9PiB7XG4gICAgaW50ZXJuYWxTZXQoZG9tLCBrLCB2KTtcbiAgfSk7XG59O1xuXG5jb25zdCBzZXRPcHRpb25zID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPiwgY3NzOiBSZWNvcmQ8c3RyaW5nLCBPcHRpb25hbDxzdHJpbmc+Pik6IHZvaWQgPT4ge1xuICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcblxuICBPYmouZWFjaChjc3MsICh2LCBrKSA9PiB7XG4gICAgdi5mb2xkKCgpID0+IHtcbiAgICAgIGludGVybmFsUmVtb3ZlKGRvbSwgayk7XG4gICAgfSwgKHZhbHVlKSA9PiB7XG4gICAgICBpbnRlcm5hbFNldChkb20sIGssIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKlxuICogTk9URTogRm9yIGNlcnRhaW4gcHJvcGVydGllcywgdGhpcyByZXR1cm5zIHRoZSBcInVzZWQgdmFsdWVcIiB3aGljaCBpcyBzdWJ0bHkgZGlmZmVyZW50IHRvIHRoZSBcImNvbXB1dGVkIHZhbHVlXCIgKGRlc3BpdGUgY2FsbGluZyBnZXRDb21wdXRlZFN0eWxlKS5cbiAqIEJsYW1lIENTUyAyLjAuXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqL1xuY29uc3QgZ2V0ID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxFbGVtZW50PiwgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGRvbSA9IGVsZW1lbnQuZG9tO1xuICAvKlxuICAgKiBJRTkgYW5kIGFib3ZlIHBlclxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LmdldENvbXB1dGVkU3R5bGVcbiAgICpcbiAgICogTm90IGluIG51bWVyb3NpdHksIGJlY2F1c2UgaXQgZG9lc24ndCBtZW1vaXplIGFuZCBsb29raW5nIHRoaXMgdXAgZHluYW1pY2FsbHkgaW4gcGVyZm9ybWFuY2UgY3JpdGljYWwgY29kZSB3b3VsZCBiZSBob3JyZW5kb3VzLlxuICAgKlxuICAgKiBKUXVlcnkgaGFzIHNvbWUgbWFnaWMgaGVyZSBmb3IgSUUgcG9wdXBzLCBidXQgd2UgZG9uJ3QgcmVhbGx5IG5lZWQgdGhhdC5cbiAgICogSXQgYWxzbyB1c2VzIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB0byBoYW5kbGUgaWZyYW1lcyBidXQgdGhhdCBoYXNuJ3QgYmVlbiByZXF1aXJlZCBzaW5jZSBGRiAzLjYuXG4gICAqL1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pO1xuICBjb25zdCByID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuXG4gIC8vIGpxdWVyeS1pc206IElmIHIgaXMgYW4gZW1wdHkgc3RyaW5nLCBjaGVjayB0aGF0IHRoZSBlbGVtZW50IGlzIG5vdCBpbiBhIGRvY3VtZW50LiBJZiBpdCBpc24ndCwgcmV0dXJuIHRoZSByYXcgdmFsdWUuXG4gIC8vIFR1cm5zIG91dCB3ZSBkbyB0aGlzIGEgbG90LlxuICByZXR1cm4gKHIgPT09ICcnICYmICFTdWdhckJvZHkuaW5Cb2R5KGVsZW1lbnQpKSA/IGdldFVuc2FmZVByb3BlcnR5KGRvbSwgcHJvcGVydHkpIDogcjtcbn07XG5cbi8vIHJlbW92ZWQ6IHN1cHBvcnQgZm9yIGRvbSgpLnN0eWxlW3Byb3BlcnR5XSB3aGVyZSBwcm9wIGlzIGNhbWVsIGNhc2UgaW5zdGVhZCBvZiBub3JtYWwgcHJvcGVydHkgbmFtZVxuLy8gZW1wdHkgc3RyaW5nIGlzIHdoYXQgdGhlIGJyb3dzZXJzIChJRTExIGFuZCBDaHJvbWUpIHJldHVybiB3aGVuIHRoZSBwcm9wZXJ0eVZhbHVlIGRvZXNuJ3QgZXhpc3RzLlxuY29uc3QgZ2V0VW5zYWZlUHJvcGVydHkgPSAoZG9tOiBOb2RlLCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nID0+XG4gIFN0eWxlLmlzU3VwcG9ydGVkKGRvbSkgPyBkb20uc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSkgOiAnJztcblxuLypcbiAqIEdldHMgdGhlIHJhdyB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBhdHRyaWJ1dGUuIFVzZWZ1bCBmb3IgcmV0cmlldmluZyBcInVzZWQgdmFsdWVzXCIgZnJvbSB0aGUgRE9NOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3VzZWRfdmFsdWVcbiAqXG4gKiBSZXR1cm5zIE5PTkUgaWYgdGhlIHByb3BlcnR5IGlzbid0IHNldCwgb3IgdGhlIHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuY29uc3QgZ2V0UmF3ID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPiwgcHJvcGVydHk6IHN0cmluZyk6IE9wdGlvbmFsPHN0cmluZz4gPT4ge1xuICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgY29uc3QgcmF3ID0gZ2V0VW5zYWZlUHJvcGVydHkoZG9tLCBwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIE9wdGlvbmFsLmZyb20ocmF3KS5maWx0ZXIoKHIpID0+IHIubGVuZ3RoID4gMCk7XG59O1xuXG5jb25zdCBnZXRBbGxSYXcgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9PiB7XG4gIGNvbnN0IGNzczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcblxuICBpZiAoU3R5bGUuaXNTdXBwb3J0ZWQoZG9tKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tLnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBydWxlTmFtZSA9IGRvbS5zdHlsZS5pdGVtKGkpIGFzIGtleW9mIENTU1N0eWxlRGVjbGFyYXRpb247XG4gICAgICBjc3NbcnVsZU5hbWVdID0gZG9tLnN0eWxlW3J1bGVOYW1lXSBhcyBzdHJpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3M7XG59O1xuXG5jb25zdCBpc1ZhbGlkVmFsdWUgPSAodGFnOiBzdHJpbmcsIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IFN1Z2FyRWxlbWVudC5mcm9tVGFnKHRhZyk7XG4gIHNldChlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICBjb25zdCBzdHlsZSA9IGdldFJhdyhlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIHJldHVybiBzdHlsZS5pc1NvbWUoKTtcbn07XG5cbmNvbnN0IHJlbW92ZSA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByb3BlcnR5OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgY29uc3QgZG9tID0gZWxlbWVudC5kb207XG5cbiAgaW50ZXJuYWxSZW1vdmUoZG9tLCBwcm9wZXJ0eSk7XG5cbiAgaWYgKE9wdGlvbmFscy5pcyhBdHRyaWJ1dGUuZ2V0T3B0KGVsZW1lbnQgYXMgU3VnYXJFbGVtZW50PEVsZW1lbnQ+LCAnc3R5bGUnKS5tYXAoU3RyaW5ncy50cmltKSwgJycpKSB7XG4gICAgLy8gTm8gbW9yZSBzdHlsZXMgbGVmdCwgcmVtb3ZlIHRoZSBzdHlsZSBhdHRyaWJ1dGUgYXMgd2VsbFxuICAgIEF0dHJpYnV0ZS5yZW1vdmUoZWxlbWVudCBhcyBTdWdhckVsZW1lbnQ8RWxlbWVudD4sICdzdHlsZScpO1xuICB9XG59O1xuXG5jb25zdCBwcmVzZXJ2ZSA9IDxFIGV4dGVuZHMgRWxlbWVudCwgVD4gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxFPiwgZjogKGU6IFN1Z2FyRWxlbWVudDxFPikgPT4gVCk6IFQgPT4ge1xuICBjb25zdCBvbGRTdHlsZXMgPSBBdHRyaWJ1dGUuZ2V0KGVsZW1lbnQsICdzdHlsZScpO1xuICBjb25zdCByZXN1bHQgPSBmKGVsZW1lbnQpO1xuICBpZiAob2xkU3R5bGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBBdHRyaWJ1dGUucmVtb3ZlKGVsZW1lbnQsICdzdHlsZScpO1xuICB9IGVsc2Uge1xuICAgIEF0dHJpYnV0ZS5zZXQoZWxlbWVudCwgJ3N0eWxlJywgb2xkU3R5bGVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgY29weSA9IChzb3VyY2U6IFN1Z2FyRWxlbWVudDxOb2RlPiwgdGFyZ2V0OiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnQ+KTogdm9pZCA9PiB7XG4gIGNvbnN0IHNvdXJjZURvbSA9IHNvdXJjZS5kb207XG4gIGNvbnN0IHRhcmdldERvbSA9IHRhcmdldC5kb207XG4gIGlmIChTdHlsZS5pc1N1cHBvcnRlZChzb3VyY2VEb20pICYmIFN0eWxlLmlzU3VwcG9ydGVkKHRhcmdldERvbSkpIHtcbiAgICB0YXJnZXREb20uc3R5bGUuY3NzVGV4dCA9IHNvdXJjZURvbS5zdHlsZS5jc3NUZXh0O1xuICB9XG59O1xuXG4vKiBOT1RFOiBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgZm9yIHRoZSBzaWRlIGVmZmVjdCBpdCB0cmlnZ2Vycy5cblRoZSB2YWx1ZSBpdHNlbGYgaXMgbm90IHVzZWQuXG5CZSBzdXJlIHRvIG5vdCB1c2UgdGhlIHJldHVybiB2YWx1ZSwgYW5kIHRoYXQgaXQgaXMgbm90IHJlbW92ZWQgYnkgYSBtaW5pZmllci5cbiAqL1xuY29uc3QgcmVmbG93ID0gKGU6IFN1Z2FyRWxlbWVudDxIVE1MRWxlbWVudD4pOiB2b2lkID0+XG4gIGUuZG9tLm9mZnNldFdpZHRoIGFzIHVua25vd24gYXMgdm9pZDtcblxuY29uc3QgdHJhbnNmZXJPbmUgPSAoc291cmNlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGRlc3RpbmF0aW9uOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHN0eWxlOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgZ2V0UmF3KHNvdXJjZSwgc3R5bGUpLmVhY2goKHZhbHVlKSA9PiB7XG4gICAgLy8gTk9URTogV2UgZG9uJ3Qgd2FudCB0byBjbG9iYmVyIGFueSBleGlzdGluZyBpbmxpbmUgc3R5bGVzLlxuICAgIGlmIChnZXRSYXcoZGVzdGluYXRpb24sIHN0eWxlKS5pc05vbmUoKSkge1xuICAgICAgc2V0KGRlc3RpbmF0aW9uLCBzdHlsZSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCB0cmFuc2ZlciA9IChzb3VyY2U6IFN1Z2FyRWxlbWVudDxOb2RlPiwgZGVzdGluYXRpb246IFN1Z2FyRWxlbWVudDxOb2RlPiwgc3R5bGVzOiBzdHJpbmdbXSk6IHZvaWQgPT4ge1xuICBpZiAoIVN1Z2FyTm9kZS5pc0VsZW1lbnQoc291cmNlKSB8fCAhU3VnYXJOb2RlLmlzRWxlbWVudChkZXN0aW5hdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgQXJyLmVhY2goc3R5bGVzLCAoc3R5bGUpID0+IHtcbiAgICB0cmFuc2Zlck9uZShzb3VyY2UsIGRlc3RpbmF0aW9uLCBzdHlsZSk7XG4gIH0pO1xufTtcblxuZXhwb3J0IHsgY29weSwgc2V0LCBwcmVzZXJ2ZSwgc2V0QWxsLCBzZXRPcHRpb25zLCByZW1vdmUsIGdldCwgZ2V0UmF3LCBnZXRBbGxSYXcsIGlzVmFsaWRWYWx1ZSwgcmVmbG93LCB0cmFuc2ZlciB9O1xuIiwiaW1wb3J0IHsgQXJyIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuaW1wb3J0ICogYXMgU3VnYXJCb2R5IGZyb20gJy4uL25vZGUvU3VnYXJCb2R5JztcbmltcG9ydCB0eXBlIHsgU3VnYXJFbGVtZW50IH0gZnJvbSAnLi4vbm9kZS9TdWdhckVsZW1lbnQnO1xuXG5pbXBvcnQgKiBhcyBUcmF2ZXJzZSBmcm9tICcuL1RyYXZlcnNlJztcblxuLy8gbWF5YmUgVHJhdmVyc2VXaXRoLCBzaW1pbGFyIHRvIHRyYXZlcnNlIGJ1dCB3aXRoIGEgcHJlZGljYXRlP1xuXG5jb25zdCBhbGw6IHtcbiAgPFQgZXh0ZW5kcyBOb2RlID0gTm9kZT4ocHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBlIGlzIFN1Z2FyRWxlbWVudDxUPik6IFN1Z2FyRWxlbWVudDxUPltdO1xuICAocHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogU3VnYXJFbGVtZW50PE5vZGU+W107XG59ID0gKHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbikgPT5cbiAgZGVzY2VuZGFudHMoU3VnYXJCb2R5LmJvZHkoKSwgcHJlZGljYXRlKTtcblxuY29uc3QgYW5jZXN0b3JzOiB7XG4gIDxUIGV4dGVuZHMgTm9kZSA9IE5vZGU+KHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gZSBpcyBTdWdhckVsZW1lbnQ8VD4sIGlzUm9vdD86IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pOiBTdWdhckVsZW1lbnQ8VD5bXTtcbiAgKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbiwgaXNSb290PzogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbik6IFN1Z2FyRWxlbWVudDxOb2RlPltdO1xufSA9IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4sIGlzUm9vdD86IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pID0+XG4gIEFyci5maWx0ZXIoVHJhdmVyc2UucGFyZW50cyhzY29wZSwgaXNSb290KSwgcHJlZGljYXRlKTtcblxuY29uc3Qgc2libGluZ3M6IHtcbiAgPFQgZXh0ZW5kcyBOb2RlID0gTm9kZT4oc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgcHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBlIGlzIFN1Z2FyRWxlbWVudDxUPik6IFN1Z2FyRWxlbWVudDxUPltdO1xuICAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgcHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogU3VnYXJFbGVtZW50PE5vZGU+W107XG59ID0gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbikgPT5cbiAgQXJyLmZpbHRlcihUcmF2ZXJzZS5zaWJsaW5ncyhzY29wZSksIHByZWRpY2F0ZSk7XG5cbmNvbnN0IGNoaWxkcmVuOiB7XG4gIDxUIGV4dGVuZHMgTm9kZSA9IE5vZGU+KHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gZSBpcyBTdWdhckVsZW1lbnQ8VD4pOiBTdWdhckVsZW1lbnQ8VD5bXTtcbiAgKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbik6IFN1Z2FyRWxlbWVudDxOb2RlPltdO1xufSA9IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pID0+XG4gIEFyci5maWx0ZXIoVHJhdmVyc2UuY2hpbGRyZW4oc2NvcGUpLCBwcmVkaWNhdGUpO1xuXG5jb25zdCBkZXNjZW5kYW50czoge1xuICA8VCBleHRlbmRzIE5vZGUgPSBOb2RlPihzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGUgaXMgU3VnYXJFbGVtZW50PFQ+KTogU3VnYXJFbGVtZW50PFQ+W107XG4gIChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pOiBTdWdhckVsZW1lbnQ8Tm9kZT5bXTtcbn0gPSAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgcHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKSA9PiB7XG4gIGxldCByZXN1bHQ6IFN1Z2FyRWxlbWVudDxOb2RlPltdID0gW107XG5cbiAgLy8gUmVjdXJzZS50b0FycmF5KCkgbWlnaHQgaGVscCBoZXJlXG4gIEFyci5lYWNoKFRyYXZlcnNlLmNoaWxkcmVuKHNjb3BlKSwgKHgpID0+IHtcbiAgICBpZiAocHJlZGljYXRlKHgpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KFsgeCBdKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChkZXNjZW5kYW50cyh4LCBwcmVkaWNhdGUpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnQge1xuICBhbGwsXG4gIGFuY2VzdG9ycyxcbiAgc2libGluZ3MsXG4gIGNoaWxkcmVuLFxuICBkZXNjZW5kYW50c1xufTtcbiIsImltcG9ydCB7IEFyciwgRnVuLCBPcHRpb25hbCwgVHlwZSB9IGZyb20gJ0BlcGhveC9rYXRhbWFyaSc7XG5cbmltcG9ydCBDbG9zZXN0T3JBbmNlc3RvciBmcm9tICcuLi8uLi9pbXBsL0Nsb3Nlc3RPckFuY2VzdG9yJztcbmltcG9ydCAqIGFzIENvbXBhcmUgZnJvbSAnLi4vZG9tL0NvbXBhcmUnO1xuaW1wb3J0ICogYXMgU3VnYXJCb2R5IGZyb20gJy4uL25vZGUvU3VnYXJCb2R5JztcbmltcG9ydCB7IFN1Z2FyRWxlbWVudCB9IGZyb20gJy4uL25vZGUvU3VnYXJFbGVtZW50JztcblxuY29uc3QgZmlyc3Q6IHtcbiAgPFQgZXh0ZW5kcyBOb2RlID0gTm9kZT4gKHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gZSBpcyBTdWdhckVsZW1lbnQ8VD4pOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8VCAmIENoaWxkTm9kZT4+O1xuICAocHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+Pjtcbn0gPSAocHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKSA9PlxuICBkZXNjZW5kYW50KFN1Z2FyQm9keS5ib2R5KCksIHByZWRpY2F0ZSk7XG5cbmNvbnN0IGFuY2VzdG9yOiB7XG4gIDxUIGV4dGVuZHMgTm9kZSA9IE5vZGU+IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGUgaXMgU3VnYXJFbGVtZW50PFQ+LCBpc1Jvb3Q/OiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PFQ+PjtcbiAgKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbiwgaXNSb290PzogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxOb2RlPj47XG59ID0gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbiwgaXNSb290PzogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbikgPT4ge1xuICBsZXQgZWxlbWVudCA9IHNjb3BlLmRvbTtcbiAgY29uc3Qgc3RvcCA9IFR5cGUuaXNGdW5jdGlvbihpc1Jvb3QpID8gaXNSb290IDogRnVuLm5ldmVyO1xuXG4gIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGNvbnN0IGVsID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWxlbWVudCk7XG5cbiAgICBpZiAocHJlZGljYXRlKGVsKSkge1xuICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoZWwpO1xuICAgIH0gZWxzZSBpZiAoc3RvcChlbCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT3B0aW9uYWwubm9uZTxTdWdhckVsZW1lbnQ8Tm9kZT4+KCk7XG59O1xuXG5jb25zdCBjbG9zZXN0OiB7XG4gIDxUIGV4dGVuZHMgTm9kZSA9IE5vZGU+IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGUgaXMgU3VnYXJFbGVtZW50PFQ+LCBpc1Jvb3Q/OiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PFQ+PjtcbiAgKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbiwgaXNSb290PzogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxOb2RlPj47XG59ID0gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbiwgaXNSb290PzogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbikgPT4ge1xuICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIGF2b2lkIENsb3Nlc3RPckFuY2VzdG9yIHBhc3NpbmcgdGhlIHByZWRpY2F0ZSB0byBpdHNlbGZcbiAgY29uc3QgaXMgPSAoczogU3VnYXJFbGVtZW50PE5vZGU+LCB0ZXN0OiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogcyBpcyBTdWdhckVsZW1lbnQ8Tm9kZT4gPT4gdGVzdChzKTtcbiAgcmV0dXJuIENsb3Nlc3RPckFuY2VzdG9yKGlzLCBhbmNlc3Rvciwgc2NvcGUsIHByZWRpY2F0ZSwgaXNSb290KTtcbn07XG5cbmNvbnN0IHNpYmxpbmc6IHtcbiAgPFQgZXh0ZW5kcyBOb2RlID0gTm9kZT4gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gZSBpcyBTdWdhckVsZW1lbnQ8VD4pOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8VCAmIENoaWxkTm9kZT4+O1xuICAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgcHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+Pjtcbn0gPSAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgcHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+PiA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5kb207XG4gIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIE9wdGlvbmFsLm5vbmU8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+PigpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkKFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQucGFyZW50Tm9kZSksICh4KSA9PiAhQ29tcGFyZS5lcShzY29wZSwgeCkgJiYgcHJlZGljYXRlKHgpKTtcbn07XG5cbmNvbnN0IGNoaWxkOiB7XG4gIDxUIGV4dGVuZHMgTm9kZSA9IE5vZGU+IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGUgaXMgU3VnYXJFbGVtZW50PFQ+KTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PFQgJiBDaGlsZE5vZGU+PjtcbiAgKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxOb2RlICYgQ2hpbGROb2RlPj47XG59ID0gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHByZWRpY2F0ZTogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbikgPT4ge1xuICBjb25zdCBwcmVkID0gKG5vZGU6IE5vZGUpID0+IHByZWRpY2F0ZShTdWdhckVsZW1lbnQuZnJvbURvbShub2RlKSk7XG4gIGNvbnN0IHJlc3VsdCA9IEFyci5maW5kKHNjb3BlLmRvbS5jaGlsZE5vZGVzLCBwcmVkKTtcbiAgcmV0dXJuIHJlc3VsdC5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xufTtcblxuY29uc3QgZGVzY2VuZGFudDoge1xuICA8VCBleHRlbmRzIE5vZGUgPSBOb2RlPiAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgcHJlZGljYXRlOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBlIGlzIFN1Z2FyRWxlbWVudDxUPik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxUICYgQ2hpbGROb2RlPj47XG4gIChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8Tm9kZSAmIENoaWxkTm9kZT4+O1xufSA9IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pID0+IHtcbiAgY29uc3QgZGVzY2VuZCA9IChub2RlOiBOb2RlKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+PiA9PiB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1mb3Itb2ZcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBTdWdhckVsZW1lbnQuZnJvbURvbShub2RlLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXMgPSBkZXNjZW5kKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICBpZiAocmVzLmlzU29tZSgpKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wdGlvbmFsLm5vbmU8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+PigpO1xuICB9O1xuXG4gIHJldHVybiBkZXNjZW5kKHNjb3BlLmRvbSk7XG59O1xuXG5leHBvcnQgeyBmaXJzdCwgYW5jZXN0b3IsIGNsb3Nlc3QsIHNpYmxpbmcsIGNoaWxkLCBkZXNjZW5kYW50IH07XG4iLCJpbXBvcnQgdHlwZSB7IFN1Z2FyRWxlbWVudCB9IGZyb20gJy4uL25vZGUvU3VnYXJFbGVtZW50JztcblxuaW1wb3J0ICogYXMgUHJlZGljYXRlRmlsdGVyIGZyb20gJy4vUHJlZGljYXRlRmlsdGVyJztcbmltcG9ydCAqIGFzIFNlbGVjdG9ycyBmcm9tICcuL1NlbGVjdG9ycyc7XG5cbmNvbnN0IGFsbCA9IDxUIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQ+IChzZWxlY3Rvcjogc3RyaW5nKTogU3VnYXJFbGVtZW50PFQ+W10gPT5cbiAgU2VsZWN0b3JzLmFsbDxUPihzZWxlY3Rvcik7XG5cbi8vIEZvciBhbGwgb2YgdGhlIGZvbGxvd2luZzpcbi8vXG4vLyBqUXVlcnkgZG9lcyBzaWJsaW5ncyBvZiBmaXJzdENoaWxkLiBJRTkrIHN1cHBvcnRzIHNjb3BlLmRvbS5jaGlsZHJlbiAoc2ltaWxhciB0byBUcmF2ZXJzZS5jaGlsZHJlbiBidXQgZWxlbWVudHMgb25seSkuXG4vLyBUcmF2ZXJzZSBzaG91bGQgYWxzbyBkbyB0aGlzIChidXQgcHJvYmFibHkgbm90IGJ5IGRlZmF1bHQpLlxuLy9cblxuY29uc3QgYW5jZXN0b3JzID0gPFQgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudD4gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHNlbGVjdG9yOiBzdHJpbmcsIGlzUm9vdD86IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pOiBTdWdhckVsZW1lbnQ8VD5bXSA9PlxuICAvLyBJdCBtYXkgc3VycHJpc2UgeW91IHRvIGxlYXJuIHRoaXMgaXMgZXhhY3RseSB3aGF0IEpRdWVyeSBkb2VzXG4gIC8vIFRPRE86IEF2b2lkIGFsbCB0aGlzIHdyYXBwaW5nIGFuZCB1bndyYXBwaW5nXG4gIFByZWRpY2F0ZUZpbHRlci5hbmNlc3RvcnMoc2NvcGUsIChlKTogZSBpcyBTdWdhckVsZW1lbnQ8VD4gPT4gU2VsZWN0b3JzLmlzPFQ+KGUsIHNlbGVjdG9yKSwgaXNSb290KTtcblxuY29uc3Qgc2libGluZ3MgPSA8VCBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PiAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgc2VsZWN0b3I6IHN0cmluZyk6IFN1Z2FyRWxlbWVudDxUPltdID0+XG4gIC8vIEl0IG1heSBzdXJwcmlzZSB5b3UgdG8gbGVhcm4gdGhpcyBpcyBleGFjdGx5IHdoYXQgSlF1ZXJ5IGRvZXNcbiAgLy8gVE9ETzogQXZvaWQgYWxsIHRoZSB3cmFwcGluZyBhbmQgdW53cmFwcGluZ1xuICBQcmVkaWNhdGVGaWx0ZXIuc2libGluZ3Moc2NvcGUsIChlKTogZSBpcyBTdWdhckVsZW1lbnQ8VD4gPT4gU2VsZWN0b3JzLmlzPFQ+KGUsIHNlbGVjdG9yKSk7XG5cbmNvbnN0IGNoaWxkcmVuID0gPFQgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudD4gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHNlbGVjdG9yOiBzdHJpbmcpOiBTdWdhckVsZW1lbnQ8VD5bXSA9PlxuICAvLyBJdCBtYXkgc3VycHJpc2UgeW91IHRvIGxlYXJuIHRoaXMgaXMgZXhhY3RseSB3aGF0IEpRdWVyeSBkb2VzXG4gIC8vIFRPRE86IEF2b2lkIGFsbCB0aGUgd3JhcHBpbmcgYW5kIHVud3JhcHBpbmdcbiAgUHJlZGljYXRlRmlsdGVyLmNoaWxkcmVuKHNjb3BlLCAoZSk6IGUgaXMgU3VnYXJFbGVtZW50PFQ+ID0+IFNlbGVjdG9ycy5pczxUPihlLCBzZWxlY3RvcikpO1xuXG5jb25zdCBkZXNjZW5kYW50cyA9IDxUIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQ+IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBzZWxlY3Rvcjogc3RyaW5nKTogU3VnYXJFbGVtZW50PFQ+W10gPT5cbiAgU2VsZWN0b3JzLmFsbDxUPihzZWxlY3Rvciwgc2NvcGUpO1xuXG5leHBvcnQge1xuICBhbGwsXG4gIGFuY2VzdG9ycyxcbiAgc2libGluZ3MsXG4gIGNoaWxkcmVuLFxuICBkZXNjZW5kYW50c1xufTtcbiIsImltcG9ydCB0eXBlIHsgT3B0aW9uYWwgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgQ2xvc2VzdE9yQW5jZXN0b3IgZnJvbSAnLi4vLi4vaW1wbC9DbG9zZXN0T3JBbmNlc3Rvcic7XG5pbXBvcnQgdHlwZSB7IFN1Z2FyRWxlbWVudCB9IGZyb20gJy4uL25vZGUvU3VnYXJFbGVtZW50JztcblxuaW1wb3J0ICogYXMgUHJlZGljYXRlRmluZCBmcm9tICcuL1ByZWRpY2F0ZUZpbmQnO1xuaW1wb3J0ICogYXMgU2VsZWN0b3JzIGZyb20gJy4vU2VsZWN0b3JzJztcblxuLy8gVE9ETzogQW4gaW50ZXJuYWwgU2VsZWN0b3JGaWx0ZXIgbW9kdWxlIHRoYXQgZG9lc24ndCBTdWdhckVsZW1lbnQuZnJvbURvbSgpIGV2ZXJ5dGhpbmdcblxuY29uc3QgZmlyc3QgPSA8VCBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PiAoc2VsZWN0b3I6IHN0cmluZyk6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxUPj4gPT5cbiAgU2VsZWN0b3JzLm9uZTxUPihzZWxlY3Rvcik7XG5cbmNvbnN0IGFuY2VzdG9yID0gPFQgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudD4gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHNlbGVjdG9yOiBzdHJpbmcsIGlzUm9vdD86IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8VD4+ID0+XG4gIFByZWRpY2F0ZUZpbmQuYW5jZXN0b3Ioc2NvcGUsIChlKTogZSBpcyBTdWdhckVsZW1lbnQ8VD4gPT4gU2VsZWN0b3JzLmlzPFQ+KGUsIHNlbGVjdG9yKSwgaXNSb290KTtcblxuY29uc3Qgc2libGluZyA9IDxUIGV4dGVuZHMgRWxlbWVudCA9IEVsZW1lbnQ+IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBzZWxlY3Rvcjogc3RyaW5nKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PFQ+PiA9PlxuICBQcmVkaWNhdGVGaW5kLnNpYmxpbmcoc2NvcGUsIChlKTogZSBpcyBTdWdhckVsZW1lbnQ8VD4gPT4gU2VsZWN0b3JzLmlzPFQ+KGUsIHNlbGVjdG9yKSk7XG5cbmNvbnN0IGNoaWxkID0gPFQgZXh0ZW5kcyBFbGVtZW50ID0gRWxlbWVudD4gKHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHNlbGVjdG9yOiBzdHJpbmcpOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8VD4+ID0+XG4gIFByZWRpY2F0ZUZpbmQuY2hpbGQoc2NvcGUsIChlKTogZSBpcyBTdWdhckVsZW1lbnQ8VD4gPT4gU2VsZWN0b3JzLmlzPFQ+KGUsIHNlbGVjdG9yKSk7XG5cbmNvbnN0IGRlc2NlbmRhbnQgPSA8VCBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PiAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgc2VsZWN0b3I6IHN0cmluZyk6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxUPj4gPT5cbiAgU2VsZWN0b3JzLm9uZTxUPihzZWxlY3Rvciwgc2NvcGUpO1xuXG4vLyBSZXR1cm5zIFNvbWUoY2xvc2VzdCBhbmNlc3RvciBlbGVtZW50IChzdWdhcmVkKSkgbWF0Y2hpbmcgJ3NlbGVjdG9yJyB1cCB0byBpc1Jvb3QsIG9yIE5vbmUoKSBvdGhlcndpc2VcbmNvbnN0IGNsb3Nlc3QgPSA8VCBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PiAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgc2VsZWN0b3I6IHN0cmluZywgaXNSb290PzogKGU6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gYm9vbGVhbik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxUPj4gPT4ge1xuICBjb25zdCBpcyA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIHNlbGVjdG9yOiBzdHJpbmcpOiBlbGVtZW50IGlzIFN1Z2FyRWxlbWVudDxUPiA9PiBTZWxlY3RvcnMuaXM8VD4oZWxlbWVudCwgc2VsZWN0b3IpO1xuICByZXR1cm4gQ2xvc2VzdE9yQW5jZXN0b3I8c3RyaW5nLCBUPihpcywgYW5jZXN0b3IsIHNjb3BlLCBzZWxlY3RvciwgaXNSb290KTtcbn07XG5cbmV4cG9ydCB7XG4gIGZpcnN0LFxuICBhbmNlc3RvcixcbiAgc2libGluZyxcbiAgY2hpbGQsXG4gIGRlc2NlbmRhbnQsXG4gIGNsb3Nlc3Rcbn07XG4iLCJpbXBvcnQgeyBBcnIsIE9wdGlvbmFsIH0gZnJvbSAnQGVwaG94L2thdGFtYXJpJztcblxuaW1wb3J0IHsgRE9DVU1FTlQsIERPQ1VNRU5UX0ZSQUdNRU5ULCBFTEVNRU5UIH0gZnJvbSAnLi4vbm9kZS9Ob2RlVHlwZXMnO1xuaW1wb3J0IHsgU3VnYXJFbGVtZW50IH0gZnJvbSAnLi4vbm9kZS9TdWdhckVsZW1lbnQnO1xuXG5pbnRlcmZhY2UgVmVuZG9yRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBtc01hdGNoZXNTZWxlY3Rvcj86IChzZWxlY3Rvcjogc3RyaW5nKSA9PiBib29sZWFuO1xuICBtb3pNYXRjaGVzU2VsZWN0b3I/OiAoc2VsZWN0b3I6IHN0cmluZykgPT4gYm9vbGVhbjtcbn1cblxuY29uc3QgaXMgPSA8VCBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PiAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+LCBzZWxlY3Rvcjogc3RyaW5nKTogZWxlbWVudCBpcyBTdWdhckVsZW1lbnQ8VD4gPT4ge1xuICBjb25zdCBkb20gPSBlbGVtZW50LmRvbTtcbiAgaWYgKGRvbS5ub2RlVHlwZSAhPT0gRUxFTUVOVCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBlbGVtID0gZG9tIGFzIFZlbmRvckVsZW1lbnQ7XG4gICAgaWYgKGVsZW0ubWF0Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZWxlbS5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0ubXNNYXRjaGVzU2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGVsZW0ubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH0gZWxzZSBpZiAoZWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGVsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKGVsZW0ubW96TWF0Y2hlc1NlbGVjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNhc3QgdG8gYW55IGFzIG1vek1hdGNoZXNTZWxlY3RvciBkb2Vzbid0IGV4aXN0IGluIFRTIERPTSBsaWJcbiAgICAgIHJldHVybiBlbGVtLm1vek1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBsYWNrcyBuYXRpdmUgc2VsZWN0b3JzJyk7XG4gICAgfSAvLyB1bmZvcnR1bmF0ZWx5IHdlIGNhbid0IHRocm93IHRoaXMgb24gc3RhcnR1cCA6KFxuICB9XG59O1xuXG5jb25zdCBieXBhc3NTZWxlY3RvciA9IChkb206IE5vZGUpID0+XG4gIC8vIE9ubHkgZWxlbWVudHMsIGRvY3VtZW50cyBhbmQgc2hhZG93IHJvb3RzIHN1cHBvcnQgcXVlcnlTZWxlY3RvclxuICAvLyBzaGFkb3cgcm9vdCBlbGVtZW50IHR5cGUgaXMgRE9DVU1FTlRfRlJBR01FTlRcbiAgZG9tLm5vZGVUeXBlICE9PSBFTEVNRU5UICYmIGRvbS5ub2RlVHlwZSAhPT0gRE9DVU1FTlQgJiYgZG9tLm5vZGVUeXBlICE9PSBET0NVTUVOVF9GUkFHTUVOVCB8fFxuICAgIC8vIElFIGZpeCBmb3IgY29tcGxleCBxdWVyaWVzIG9uIGVtcHR5IG5vZGVzOiBodHRwOi8vanNmaWRkbGUubmV0L3NweWRlci9mdjlwdHI1TC9cbiAgICAoZG9tIGFzIEVsZW1lbnQgfCBEb2N1bWVudCB8IERvY3VtZW50RnJhZ21lbnQpLmNoaWxkRWxlbWVudENvdW50ID09PSAwO1xuXG5jb25zdCBhbGwgPSA8VCBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PiAoc2VsZWN0b3I6IHN0cmluZywgc2NvcGU/OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBTdWdhckVsZW1lbnQ8VD5bXSA9PiB7XG4gIGNvbnN0IGJhc2UgPSBzY29wZSA9PT0gdW5kZWZpbmVkID8gZG9jdW1lbnQgOiBzY29wZS5kb207XG4gIHJldHVybiBieXBhc3NTZWxlY3RvcihiYXNlKSA/IFtdIDogQXJyLm1hcCgoYmFzZSBhcyBFbGVtZW50IHwgRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGw8VD4oc2VsZWN0b3IpLCBTdWdhckVsZW1lbnQuZnJvbURvbSk7XG59O1xuXG5jb25zdCBvbmUgPSA8VCBleHRlbmRzIEVsZW1lbnQgPSBFbGVtZW50PiAoc2VsZWN0b3I6IHN0cmluZywgc2NvcGU/OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8VD4+ID0+IHtcbiAgY29uc3QgYmFzZSA9IHNjb3BlID09PSB1bmRlZmluZWQgPyBkb2N1bWVudCA6IHNjb3BlLmRvbTtcbiAgcmV0dXJuIGJ5cGFzc1NlbGVjdG9yKGJhc2UpID8gT3B0aW9uYWwubm9uZTxTdWdhckVsZW1lbnQ8VD4+KCkgOiBPcHRpb25hbC5mcm9tKChiYXNlIGFzIEVsZW1lbnQgfCBEb2N1bWVudCkucXVlcnlTZWxlY3RvcjxUPihzZWxlY3RvcikpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG59O1xuXG5leHBvcnQge1xuICBhbGwsXG4gIGlzLFxuICBvbmVcbn07XG4iLCJpbXBvcnQgeyBBcnIsIEZ1biwgT3B0aW9uYWwsIFR5cGUgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgKiBhcyBSZWN1cnNlIGZyb20gJy4uLy4uL2FsaWVuL1JlY3Vyc2UnO1xuaW1wb3J0ICogYXMgQ29tcGFyZSBmcm9tICcuLi9kb20vQ29tcGFyZSc7XG5pbXBvcnQgeyBTdWdhckVsZW1lbnQgfSBmcm9tICcuLi9ub2RlL1N1Z2FyRWxlbWVudCc7XG5pbXBvcnQgKiBhcyBTdWdhck5vZGUgZnJvbSAnLi4vbm9kZS9TdWdhck5vZGUnO1xuXG4vKipcbiAqIFRoZSBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudFxuICogTk9URTogdGhpcyB3aWxsIHRocm93IGlmIHRoZSBvd25lciBpcyBudWxsLlxuICovXG5jb25zdCBvd25lciA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBTdWdhckVsZW1lbnQ8RG9jdW1lbnQ+ID0+XG4gIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGVsZW1lbnQuZG9tLm93bmVyRG9jdW1lbnQgYXMgRG9jdW1lbnQpO1xuXG4vKipcbiAqIElmIHRoZSBlbGVtZW50IGlzIGEgZG9jdW1lbnQsIHJldHVybiBpdC4gT3RoZXJ3aXNlLCByZXR1cm4gaXRzIG93bmVyRG9jdW1lbnQuXG4gKiBAcGFyYW0gZG9zXG4gKi9cbmNvbnN0IGRvY3VtZW50T3JPd25lciA9IChkb3M6IFN1Z2FyRWxlbWVudDxOb2RlPik6IFN1Z2FyRWxlbWVudDxEb2N1bWVudD4gPT5cbiAgU3VnYXJOb2RlLmlzRG9jdW1lbnQoZG9zKSA/IGRvcyA6IG93bmVyKGRvcyk7XG5cbmNvbnN0IGRvY3VtZW50RWxlbWVudCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnQ+ID0+XG4gIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvY3VtZW50T3JPd25lcihlbGVtZW50KS5kb20uZG9jdW1lbnRFbGVtZW50KTtcblxuLyoqXG4gKiBUaGUgd2luZG93IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBOT1RFOiB0aGlzIHdpbGwgdGhyb3cgaWYgdGhlIGRlZmF1bHRWaWV3IGlzIG51bGwuXG4gKi9cbmNvbnN0IGRlZmF1bHRWaWV3ID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IFN1Z2FyRWxlbWVudDxXaW5kb3c+ID0+XG4gIFN1Z2FyRWxlbWVudC5mcm9tRG9tKGRvY3VtZW50T3JPd25lcihlbGVtZW50KS5kb20uZGVmYXVsdFZpZXcgYXMgV2luZG93KTtcblxuY29uc3QgcGFyZW50ID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxOb2RlICYgUGFyZW50Tm9kZT4+ID0+XG4gIE9wdGlvbmFsLmZyb20oZWxlbWVudC5kb20ucGFyZW50Tm9kZSkubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcblxuLy8gQ2FzdCBkb3duIHRvIGp1c3QgYmUgU3VnYXJFbGVtZW50PE5vZGU+XG5jb25zdCBwYXJlbnROb2RlID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxOb2RlPj4gPT5cbiAgcGFyZW50KGVsZW1lbnQpIGFzIGFueTtcblxuY29uc3QgcGFyZW50RWxlbWVudCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnQ+PiA9PlxuICBPcHRpb25hbC5mcm9tKGVsZW1lbnQuZG9tLnBhcmVudEVsZW1lbnQpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG5cbmNvbnN0IGZpbmRJbmRleCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBPcHRpb25hbDxudW1iZXI+ID0+XG4gIHBhcmVudChlbGVtZW50KS5iaW5kKChwKSA9PiB7XG4gICAgLy8gVE9ETzogUmVmYWN0b3Igb3V0IGNoaWxkcmVuIHNvIHdlIGNhbiBhdm9pZCB0aGUgY29uc3RhbnQgdW53cmFwcGluZ1xuICAgIGNvbnN0IGtpbiA9IGNoaWxkcmVuKHApO1xuICAgIHJldHVybiBBcnIuZmluZEluZGV4KGtpbiwgKGVsZW0pID0+IENvbXBhcmUuZXEoZWxlbWVudCwgZWxlbSkpO1xuICB9KTtcblxuY29uc3QgcGFyZW50cyA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGlzUm9vdD86IChlOiBTdWdhckVsZW1lbnQ8Tm9kZT4pID0+IGJvb2xlYW4pOiBTdWdhckVsZW1lbnQ8Tm9kZT5bXSA9PiB7XG4gIGNvbnN0IHN0b3AgPSBUeXBlLmlzRnVuY3Rpb24oaXNSb290KSA/IGlzUm9vdCA6IEZ1bi5uZXZlcjtcblxuICAvLyBUaGlzIGlzIHVzZWQgYSAqbG90KiBzbyBpdCBuZWVkcyB0byBiZSBwZXJmb3JtYW50LCBub3QgcmVjdXJzaXZlXG4gIGxldCBkb206IE5vZGUgPSBlbGVtZW50LmRvbTtcbiAgY29uc3QgcmV0OiBTdWdhckVsZW1lbnQ8Tm9kZT5bXSA9IFtdO1xuXG4gIHdoaWxlIChkb20ucGFyZW50Tm9kZSAhPT0gbnVsbCAmJiBkb20ucGFyZW50Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgcmF3UGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgY29uc3QgcCA9IFN1Z2FyRWxlbWVudC5mcm9tRG9tKHJhd1BhcmVudCk7XG4gICAgcmV0LnB1c2gocCk7XG5cbiAgICBpZiAoc3RvcChwKSA9PT0gdHJ1ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbSA9IHJhd1BhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbmNvbnN0IHNpYmxpbmdzID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IFN1Z2FyRWxlbWVudDxOb2RlPltdID0+IHtcbiAgLy8gVE9ETzogUmVmYWN0b3Igb3V0IGNoaWxkcmVuIHNvIHdlIGNhbiBqdXN0IG5vdCBhZGQgc2VsZiBpbnN0ZWFkIG9mIGZpbHRlcmluZyBhZnRlcndhcmRzXG4gIGNvbnN0IGZpbHRlclNlbGYgPSA8RT4gKGVsZW1lbnRzOiBTdWdhckVsZW1lbnQ8RT5bXSkgPT4gQXJyLmZpbHRlcihlbGVtZW50cywgKHgpID0+ICFDb21wYXJlLmVxKGVsZW1lbnQsIHgpKTtcblxuICByZXR1cm4gcGFyZW50KGVsZW1lbnQpLm1hcChjaGlsZHJlbikubWFwKGZpbHRlclNlbGYpLmdldE9yKFtdKTtcbn07XG5cbmNvbnN0IG9mZnNldFBhcmVudCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8SFRNTEVsZW1lbnQ+KTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PEhUTUxFbGVtZW50Pj4gPT5cbiAgT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5vZmZzZXRQYXJlbnQgYXMgSFRNTEVsZW1lbnQpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG5cbmNvbnN0IHByZXZTaWJsaW5nID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxOb2RlICYgQ2hpbGROb2RlPj4gPT5cbiAgT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5wcmV2aW91c1NpYmxpbmcpLm1hcChTdWdhckVsZW1lbnQuZnJvbURvbSk7XG5cbmNvbnN0IG5leHRTaWJsaW5nID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxOb2RlICYgQ2hpbGROb2RlPj4gPT5cbiAgT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5uZXh0U2libGluZykubWFwKFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcblxuLy8gVGhpcyBvbmUgbmVlZHMgdG8gYmUgcmV2ZXJzZWQsIHNvIHRoZXkncmUgc3RpbGwgaW4gRE9NIG9yZGVyXG5jb25zdCBwcmV2U2libGluZ3MgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogU3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+W10gPT5cbiAgQXJyLnJldmVyc2UoUmVjdXJzZS50b0FycmF5KGVsZW1lbnQsIHByZXZTaWJsaW5nKSk7XG5cbmNvbnN0IG5leHRTaWJsaW5ncyA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBTdWdhckVsZW1lbnQ8Tm9kZSAmIENoaWxkTm9kZT5bXSA9PlxuICBSZWN1cnNlLnRvQXJyYXkoZWxlbWVudCwgbmV4dFNpYmxpbmcpO1xuXG5jb25zdCBjaGlsZHJlbiA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBTdWdhckVsZW1lbnQ8Tm9kZSAmIENoaWxkTm9kZT5bXSA9PlxuICBBcnIubWFwKGVsZW1lbnQuZG9tLmNoaWxkTm9kZXMsIFN1Z2FyRWxlbWVudC5mcm9tRG9tKTtcblxuY29uc3QgY2hpbGQgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+LCBpbmRleDogbnVtYmVyKTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+PiA9PiB7XG4gIGNvbnN0IGNzID0gZWxlbWVudC5kb20uY2hpbGROb2RlcztcbiAgcmV0dXJuIE9wdGlvbmFsLmZyb20oY3NbaW5kZXhdKS5tYXAoU3VnYXJFbGVtZW50LmZyb21Eb20pO1xufTtcblxuY29uc3QgZmlyc3RDaGlsZCA9IChlbGVtZW50OiBTdWdhckVsZW1lbnQ8Tm9kZT4pOiBPcHRpb25hbDxTdWdhckVsZW1lbnQ8Tm9kZSAmIENoaWxkTm9kZT4+ID0+XG4gIGNoaWxkKGVsZW1lbnQsIDApO1xuXG5jb25zdCBsYXN0Q2hpbGQgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogT3B0aW9uYWw8U3VnYXJFbGVtZW50PE5vZGUgJiBDaGlsZE5vZGU+PiA9PlxuICBjaGlsZChlbGVtZW50LCBlbGVtZW50LmRvbS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpO1xuXG5jb25zdCBjaGlsZE5vZGVzQ291bnQgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogbnVtYmVyID0+XG4gIGVsZW1lbnQuZG9tLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG5jb25zdCBoYXNDaGlsZE5vZGVzID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPik6IGJvb2xlYW4gPT5cbiAgZWxlbWVudC5kb20uaGFzQ2hpbGROb2RlcygpO1xuXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnRBbmRPZmZzZXQ8RT4ge1xuICByZWFkb25seSBlbGVtZW50OiBTdWdhckVsZW1lbnQ8RT47XG4gIHJlYWRvbmx5IG9mZnNldDogbnVtYmVyO1xufVxuXG5jb25zdCBzcG90ID0gPEU+KGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxFPiwgb2Zmc2V0OiBudW1iZXIpOiBFbGVtZW50QW5kT2Zmc2V0PEU+ID0+ICh7XG4gIGVsZW1lbnQsXG4gIG9mZnNldFxufSk7XG5cbmNvbnN0IGxlYWYgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+LCBvZmZzZXQ6IG51bWJlcik6IEVsZW1lbnRBbmRPZmZzZXQ8Tm9kZT4gPT4ge1xuICBjb25zdCBjcyA9IGNoaWxkcmVuKGVsZW1lbnQpO1xuICByZXR1cm4gY3MubGVuZ3RoID4gMCAmJiBvZmZzZXQgPCBjcy5sZW5ndGggPyBzcG90KGNzW29mZnNldF0sIDApIDogc3BvdChlbGVtZW50LCBvZmZzZXQpO1xufTtcblxuZXhwb3J0IHtcbiAgb3duZXIsXG4gIGRvY3VtZW50T3JPd25lcixcbiAgZGVmYXVsdFZpZXcsXG4gIGRvY3VtZW50RWxlbWVudCxcbiAgcGFyZW50LFxuICBwYXJlbnROb2RlLFxuICBwYXJlbnRFbGVtZW50LFxuICBmaW5kSW5kZXgsXG4gIHBhcmVudHMsXG4gIHNpYmxpbmdzLFxuICBwcmV2U2libGluZyxcbiAgb2Zmc2V0UGFyZW50LFxuICBwcmV2U2libGluZ3MsXG4gIG5leHRTaWJsaW5nLFxuICBuZXh0U2libGluZ3MsXG4gIGNoaWxkcmVuLFxuICBjaGlsZCxcbiAgZmlyc3RDaGlsZCxcbiAgbGFzdENoaWxkLFxuICBjaGlsZE5vZGVzQ291bnQsXG4gIGhhc0NoaWxkTm9kZXMsXG4gIGxlYWZcbn07XG4iLCJpbXBvcnQgeyBPcHRpb25hbCwgVHlwZSB9IGZyb20gJ0BlcGhveC9rYXRhbWFyaSc7XG5cbmltcG9ydCB0eXBlIHsgU3VnYXJFbGVtZW50IH0gZnJvbSAnLi4vYXBpL25vZGUvU3VnYXJFbGVtZW50JztcblxudHlwZSBUZXN0Rm4gPSAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuO1xudHlwZSBTY29wZVRlc3RGbjxULCBSIGV4dGVuZHMgTm9kZT4gPSAoc2NvcGU6IFN1Z2FyRWxlbWVudDxOb2RlPiwgYTogVCkgPT4gc2NvcGUgaXMgU3VnYXJFbGVtZW50PFI+O1xudHlwZSBBbmNlc3RvckZuPFQsIFIgZXh0ZW5kcyBOb2RlPiA9IChzY29wZTogU3VnYXJFbGVtZW50PE5vZGU+LCBwcmVkaWNhdGU6IFQsIGlzUm9vdD86IFRlc3RGbikgPT4gT3B0aW9uYWw8U3VnYXJFbGVtZW50PFI+PjtcblxuZXhwb3J0IGRlZmF1bHQgPFQsIFIgZXh0ZW5kcyBOb2RlID0gTm9kZT4gKGlzOiBTY29wZVRlc3RGbjxULCBSPiwgYW5jZXN0b3I6IEFuY2VzdG9yRm48VCwgUj4sIHNjb3BlOiBTdWdhckVsZW1lbnQ8Tm9kZT4sIGE6IFQsIGlzUm9vdD86IFRlc3RGbik6IE9wdGlvbmFsPFN1Z2FyRWxlbWVudDxSPj4gPT4ge1xuICBpZiAoaXMoc2NvcGUsIGEpKSB7XG4gICAgcmV0dXJuIE9wdGlvbmFsLnNvbWUoc2NvcGUpO1xuICB9IGVsc2UgaWYgKFR5cGUuaXNGdW5jdGlvbihpc1Jvb3QpICYmIGlzUm9vdChzY29wZSkpIHtcbiAgICByZXR1cm4gT3B0aW9uYWwubm9uZTxTdWdhckVsZW1lbnQ8Uj4+KCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFuY2VzdG9yKHNjb3BlLCBhLCBpc1Jvb3QpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgT3B0aW9uYWwgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgdHlwZSB7IFN1Z2FyRWxlbWVudCB9IGZyb20gJy4uL2FwaS9ub2RlL1N1Z2FyRWxlbWVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9kZVZhbHVlIHtcbiAgcmVhZG9ubHkgZ2V0OiAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBzdHJpbmc7XG4gIHJlYWRvbmx5IGdldE9wdGlvbjogKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPikgPT4gT3B0aW9uYWw8c3RyaW5nPjtcbiAgcmVhZG9ubHkgc2V0OiAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+LCB2YWx1ZTogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgTm9kZVZhbHVlID0gKGlzOiAoZTogU3VnYXJFbGVtZW50PE5vZGU+KSA9PiBib29sZWFuLCBuYW1lOiBzdHJpbmcpOiBOb2RlVmFsdWUgPT4ge1xuICBjb25zdCBnZXQgPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogc3RyaW5nID0+IHtcbiAgICBpZiAoIWlzKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IGdldCAnICsgbmFtZSArICcgdmFsdWUgb2YgYSAnICsgbmFtZSArICcgbm9kZScpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0T3B0aW9uKGVsZW1lbnQpLmdldE9yKCcnKTtcbiAgfTtcblxuICBjb25zdCBnZXRPcHRpb24gPSAoZWxlbWVudDogU3VnYXJFbGVtZW50PE5vZGU+KTogT3B0aW9uYWw8c3RyaW5nPiA9PlxuICAgIGlzKGVsZW1lbnQpID8gT3B0aW9uYWwuZnJvbShlbGVtZW50LmRvbS5ub2RlVmFsdWUpIDogT3B0aW9uYWwubm9uZTxzdHJpbmc+KCk7XG5cbiAgY29uc3Qgc2V0ID0gKGVsZW1lbnQ6IFN1Z2FyRWxlbWVudDxOb2RlPiwgdmFsdWU6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgIGlmICghaXMoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG9ubHkgc2V0IHJhdyAnICsgbmFtZSArICcgdmFsdWUgb2YgYSAnICsgbmFtZSArICcgbm9kZScpO1xuICAgIH1cbiAgICBlbGVtZW50LmRvbS5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGdldCxcbiAgICBnZXRPcHRpb24sXG4gICAgc2V0XG4gIH07XG59O1xuIiwiaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0BlcGhveC9rYXRhbWFyaSc7XG5cbi8vIHNvbWUgZWxlbWVudHMsIHN1Y2ggYXMgbWF0aG1sLCBkb24ndCBoYXZlIHN0eWxlIGF0dHJpYnV0ZXNcbi8vIG90aGVycywgc3VjaCBhcyBhbmd1bGFyIGVsZW1lbnRzLCBoYXZlIHN0eWxlIGF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgYSBDU1NTdHlsZURlY2xhcmF0aW9uXG5jb25zdCBpc1N1cHBvcnRlZCA9IDxUIGV4dGVuZHMgTm9kZT4oZG9tOiBUKTogZG9tIGlzIChUICYgRWxlbWVudENTU0lubGluZVN0eWxlKSA9PlxuXG4gIChkb20gYXMgYW55KS5zdHlsZSAhPT0gdW5kZWZpbmVkICYmIFR5cGUuaXNGdW5jdGlvbigoZG9tIGFzIGFueSkuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSk7XG5cbmV4cG9ydCB7IGlzU3VwcG9ydGVkIH07XG4iLCJpbXBvcnQgUGx1Z2luTWFuYWdlciBmcm9tICd0aW55bWNlL2NvcmUvYXBpL1BsdWdpbk1hbmFnZXInO1xuXG5pbXBvcnQgKiBhcyBDb21tYW5kcyBmcm9tICcuL2FwaS9Db21tYW5kcyc7XG5pbXBvcnQgKiBhcyBGaWx0ZXJDb250ZW50IGZyb20gJy4vY29yZS9jb250ZW50L0ZpbHRlckNvbnRlbnQnO1xuaW1wb3J0ICogYXMgS2V5Ym9hcmQgZnJvbSAnLi9jb3JlL0tleWJvYXJkJztcbmltcG9ydCAqIGFzIFF1aXJrcyBmcm9tICcuL2NvcmUvUXVpcmtzJztcbmltcG9ydCAqIGFzIEJ1dHRvbnMgZnJvbSAnLi91aS9CdXR0b25zJztcblxuZXhwb3J0IGRlZmF1bHQgKCk6IHZvaWQgPT4ge1xuICBQbHVnaW5NYW5hZ2VyLmFkZCgnYWNjb3JkaW9uJywgKGVkaXRvcikgPT4ge1xuICAgIEJ1dHRvbnMucmVnaXN0ZXIoZWRpdG9yKTtcbiAgICBDb21tYW5kcy5yZWdpc3RlcihlZGl0b3IpO1xuICAgIEtleWJvYXJkLnNldHVwKGVkaXRvcik7XG4gICAgRmlsdGVyQ29udGVudC5zZXR1cChlZGl0b3IpO1xuICAgIFF1aXJrcy5zZXR1cChlZGl0b3IpO1xuICB9KTtcbn07XG4iLCJpbXBvcnQgdHlwZSBFZGl0b3IgZnJvbSAndGlueW1jZS9jb3JlL2FwaS9FZGl0b3InO1xuXG5pbXBvcnQgKiBhcyBBY3Rpb25zIGZyb20gJy4uL2NvcmUvQWN0aW9ucyc7XG5cbmNvbnN0IHJlZ2lzdGVyID0gKGVkaXRvcjogRWRpdG9yKTogdm9pZCA9PiB7XG4gIGVkaXRvci5hZGRDb21tYW5kKCdJbnNlcnRBY2NvcmRpb24nLCAoKSA9PiBBY3Rpb25zLmluc2VydEFjY29yZGlvbihlZGl0b3IpKTtcbiAgZWRpdG9yLmFkZENvbW1hbmQoJ1RvZ2dsZUFjY29yZGlvbicsIChfdWksIHZhbHVlPzogYm9vbGVhbikgPT4gQWN0aW9ucy50b2dnbGVBY2NvcmRpb24oZWRpdG9yLCB2YWx1ZSkpO1xuICBlZGl0b3IuYWRkQ29tbWFuZCgnVG9nZ2xlQWxsQWNjb3JkaW9ucycsIChfdWksIHZhbHVlPzogYm9vbGVhbikgPT4gQWN0aW9ucy50b2dnbGVBbGxBY2NvcmRpb25zKGVkaXRvciwgdmFsdWUpKTtcbiAgZWRpdG9yLmFkZENvbW1hbmQoJ1JlbW92ZUFjY29yZGlvbicsICgpID0+IEFjdGlvbnMucmVtb3ZlQWNjb3JkaW9uKGVkaXRvcikpO1xufTtcblxuZXhwb3J0IHsgcmVnaXN0ZXIgfTtcbiIsImltcG9ydCB0eXBlIEVkaXRvciBmcm9tICd0aW55bWNlL2NvcmUvYXBpL0VkaXRvcic7XG5pbXBvcnQgdHlwZSB7IEVkaXRvckV2ZW50IH0gZnJvbSAndGlueW1jZS9jb3JlL2FwaS91dGlsL0V2ZW50RGlzcGF0Y2hlcic7XG5cbmV4cG9ydCB0eXBlIFRvZ2dsZWRBY2NvcmRpb25FdmVudCA9IEVkaXRvckV2ZW50PHsgZWxlbWVudDogSFRNTERldGFpbHNFbGVtZW50OyBzdGF0ZTogYm9vbGVhbiB9PjtcbmV4cG9ydCB0eXBlIFRvZ2dsZWRBbGxBY2NvcmRpb25zRXZlbnQgPSBFZGl0b3JFdmVudDx7IGVsZW1lbnRzOiBIVE1MRGV0YWlsc0VsZW1lbnRbXTsgc3RhdGU/OiBib29sZWFuIH0+O1xuXG5leHBvcnQgY29uc3QgZmlyZVRvZ2dsZUFjY29yZGlvbkV2ZW50ID1cbiAgKGVkaXRvcjogRWRpdG9yLCBlbGVtZW50OiBIVE1MRGV0YWlsc0VsZW1lbnQsIHN0YXRlOiBib29sZWFuKTogVG9nZ2xlZEFjY29yZGlvbkV2ZW50ID0+XG4gICAgZWRpdG9yLmRpc3BhdGNoKCdUb2dnbGVkQWNjb3JkaW9uJywgeyBlbGVtZW50LCBzdGF0ZSB9KTtcblxuZXhwb3J0IGNvbnN0IGZpcmVUb2dnbGVBbGxBY2NvcmRpb25zRXZlbnQgPVxuICAoZWRpdG9yOiBFZGl0b3IsIGVsZW1lbnRzOiBIVE1MRGV0YWlsc0VsZW1lbnRbXSwgc3RhdGU/OiBib29sZWFuKTogVG9nZ2xlZEFsbEFjY29yZGlvbnNFdmVudCA9PlxuICAgIGVkaXRvci5kaXNwYXRjaCgnVG9nZ2xlZEFsbEFjY29yZGlvbnMnLCB7IGVsZW1lbnRzLCBzdGF0ZSB9KTtcbiIsImltcG9ydCB0eXBlIEVkaXRvciBmcm9tICd0aW55bWNlL2NvcmUvYXBpL0VkaXRvcic7XG5pbXBvcnQgdHlwZSB7IEVkaXRvck9wdGlvbnMgfSBmcm9tICd0aW55bWNlL2NvcmUvYXBpL09wdGlvblR5cGVzJztcblxuY29uc3Qgb3B0aW9uID0gPEsgZXh0ZW5kcyBrZXlvZiBFZGl0b3JPcHRpb25zPihuYW1lOiBLKSA9PiAoZWRpdG9yOiBFZGl0b3IpID0+XG4gIGVkaXRvci5vcHRpb25zLmdldChuYW1lKTtcblxuY29uc3QgaXNEaXNhYmxlZCA9IG9wdGlvbignZGlzYWJsZWQnKTtcblxuZXhwb3J0IHtcbiAgaXNEaXNhYmxlZFxufTtcbiIsImltcG9ydCB7IElkLCBBcnIgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuaW1wb3J0IHsgRG9tRGVzY2VudCB9IGZyb20gJ0BlcGhveC9waG9lbml4JztcbmltcG9ydCB7IEF0dHJpYnV0ZSwgU2VsZWN0b3JGaW5kLCBTdWdhckVsZW1lbnQgfSBmcm9tICdAZXBob3gvc3VnYXInO1xuXG5pbXBvcnQgdHlwZSBFZGl0b3IgZnJvbSAndGlueW1jZS9jb3JlL2FwaS9FZGl0b3InO1xuXG5pbXBvcnQgKiBhcyBFdmVudHMgZnJvbSAnLi4vYXBpL0V2ZW50cyc7XG5pbXBvcnQgKiBhcyBPcHRpb25zIGZyb20gJy4uL2FwaS9PcHRpb25zJztcblxuaW1wb3J0ICogYXMgSWRlbnRpZmllcnMgZnJvbSAnLi9JZGVudGlmaWVycyc7XG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL1V0aWxzJztcblxuY29uc3QgaW5zZXJ0QWNjb3JkaW9uID0gKGVkaXRvcjogRWRpdG9yKTogdm9pZCA9PiB7XG4gIGlmICghVXRpbHMuaXNJbnNlcnRBbGxvd2VkKGVkaXRvcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBlZGl0b3JCb2R5ID0gU3VnYXJFbGVtZW50LmZyb21Eb20oZWRpdG9yLmdldEJvZHkoKSk7XG4gIGNvbnN0IHVpZCA9IElkLmdlbmVyYXRlKCdhY2MnKTtcbiAgY29uc3Qgc3VtbWFyeVRleHQgPSBlZGl0b3IuZG9tLmVuY29kZShlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpLnRvU3RyaW5nKCkgfHwgZWRpdG9yLnRyYW5zbGF0ZSgnQWNjb3JkaW9uIHN1bW1hcnkuLi4nKSk7XG4gIGNvbnN0IGJvZHlUZXh0ID0gZWRpdG9yLmRvbS5lbmNvZGUoZWRpdG9yLnRyYW5zbGF0ZSgnQWNjb3JkaW9uIGJvZHkuLi4nKSk7XG5cbiAgY29uc3QgYWNjb3JkaW9uU3VtbWFyeUh0bWwgPSBgPHN1bW1hcnkgY2xhc3M9XCIke0lkZW50aWZpZXJzLmFjY29yZGlvblN1bW1hcnlDbGFzc31cIj4ke3N1bW1hcnlUZXh0fTwvc3VtbWFyeT5gO1xuICBjb25zdCBhY2NvcmRpb25Cb2R5SHRtbCA9IGA8JHtJZGVudGlmaWVycy5hY2NvcmRpb25Cb2R5V3JhcHBlclRhZ30gY2xhc3M9XCIke0lkZW50aWZpZXJzLmFjY29yZGlvbkJvZHlXcmFwcGVyQ2xhc3N9XCI+PHA+JHtib2R5VGV4dH08L3A+PC8ke0lkZW50aWZpZXJzLmFjY29yZGlvbkJvZHlXcmFwcGVyVGFnfT5gO1xuXG4gIGVkaXRvci51bmRvTWFuYWdlci50cmFuc2FjdCgoKSA9PiB7XG4gICAgZWRpdG9yLmluc2VydENvbnRlbnQoW1xuICAgICAgYDxkZXRhaWxzIGRhdGEtbWNlLWlkPVwiJHt1aWR9XCIgY2xhc3M9XCIke0lkZW50aWZpZXJzLmFjY29yZGlvbkRldGFpbHNDbGFzc31cIiBvcGVuPVwib3BlblwiPmAsXG4gICAgICBhY2NvcmRpb25TdW1tYXJ5SHRtbCxcbiAgICAgIGFjY29yZGlvbkJvZHlIdG1sLFxuICAgICAgYDwvZGV0YWlscz5gXG4gICAgXS5qb2luKCcnKSk7XG5cbiAgICBTZWxlY3RvckZpbmQuZGVzY2VuZGFudChlZGl0b3JCb2R5LCBgW2RhdGEtbWNlLWlkPVwiJHt1aWR9XCJdYCkuZWFjaCgoZGV0YWlsc0VsbSkgPT4ge1xuICAgICAgQXR0cmlidXRlLnJlbW92ZShkZXRhaWxzRWxtLCAnZGF0YS1tY2UtaWQnKTtcbiAgICAgIFNlbGVjdG9yRmluZC5kZXNjZW5kYW50KGRldGFpbHNFbG0sIGBzdW1tYXJ5YCkuZWFjaCgoc3VtbWFyeUVsbSkgPT4ge1xuICAgICAgICAvLyBTZXQgdGhlIGN1cnNvciBsb2NhdGlvbiB0byBiZSBhdCB0aGUgZW5kIG9mIHRoZSBzdW1tYXJ5IHRleHRcbiAgICAgICAgY29uc3Qgcm5nID0gZWRpdG9yLmRvbS5jcmVhdGVSbmcoKTtcbiAgICAgICAgY29uc3QgZGVzID0gRG9tRGVzY2VudC5mcmVlZmFsbFJ0bChzdW1tYXJ5RWxtKTtcbiAgICAgICAgcm5nLnNldFN0YXJ0KGRlcy5lbGVtZW50LmRvbSBhcyBOb2RlLCBkZXMub2Zmc2V0KTtcbiAgICAgICAgcm5nLnNldEVuZChkZXMuZWxlbWVudC5kb20gYXMgTm9kZSwgZGVzLm9mZnNldCk7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Um5nKHJuZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5jb25zdCB0b2dnbGVEZXRhaWxzRWxlbWVudCA9IChpc1JlYWRvbmx5OiBib29sZWFuLCBkZXRhaWxzOiBIVE1MRGV0YWlsc0VsZW1lbnQsIHN0YXRlPzogYm9vbGVhbik6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBzaG91bGRPcGVuID0gc3RhdGUgPz8gIVV0aWxzLmlzT3BlbihkZXRhaWxzKTtcblxuICBpZiAoIWlzUmVhZG9ubHkpIHtcbiAgICBkZXRhaWxzLnNldEF0dHJpYnV0ZShJZGVudGlmaWVycy5hY2NvcmRpb25SZWFkb25seUNvbXBlbnNhdGlvbkF0dHJpYnV0ZSwgc2hvdWxkT3BlbiA/ICdvcGVuJyA6ICdjbG9zZWQnKTtcbiAgfVxuXG4gIGlmIChzaG91bGRPcGVuKSB7XG4gICAgZGV0YWlscy5zZXRBdHRyaWJ1dGUoJ29wZW4nLCAnb3BlbicpO1xuICB9IGVsc2Uge1xuICAgIGRldGFpbHMucmVtb3ZlQXR0cmlidXRlKCdvcGVuJyk7XG4gIH1cbiAgcmV0dXJuIHNob3VsZE9wZW47XG59O1xuXG5jb25zdCB0b2dnbGVBY2NvcmRpb24gPSAoZWRpdG9yOiBFZGl0b3IsIHN0YXRlPzogYm9vbGVhbik6IHZvaWQgPT4ge1xuICBpZiAoT3B0aW9ucy5pc0Rpc2FibGVkKGVkaXRvcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBVdGlscy5nZXRTZWxlY3RlZERldGFpbHMoZWRpdG9yKS5lYWNoKChkZXRhaWxzKSA9PiB7XG4gICAgRXZlbnRzLmZpcmVUb2dnbGVBY2NvcmRpb25FdmVudChlZGl0b3IsIGRldGFpbHMsIHRvZ2dsZURldGFpbHNFbGVtZW50KGVkaXRvci5yZWFkb25seSwgZGV0YWlscywgc3RhdGUpKTtcbiAgfSk7XG59O1xuXG5jb25zdCByZW1vdmVBY2NvcmRpb24gPSAoZWRpdG9yOiBFZGl0b3IpOiB2b2lkID0+IHtcbiAgaWYgKCFlZGl0b3IubW9kZS5pc1JlYWRPbmx5KCkpIHtcbiAgICBVdGlscy5nZXRTZWxlY3RlZERldGFpbHMoZWRpdG9yKVxuICAgICAgLmVhY2goKGRldGFpbHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBuZXh0U2libGluZyB9ID0gZGV0YWlscztcbiAgICAgICAgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QobmV4dFNpYmxpbmcsIHRydWUpO1xuICAgICAgICAgIGVkaXRvci5zZWxlY3Rpb24uY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVXRpbHMuaW5zZXJ0QW5kU2VsZWN0UGFyYWdyYXBoQWZ0ZXIoZWRpdG9yLCBkZXRhaWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRldGFpbHMucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgfVxufTtcblxuY29uc3QgdG9nZ2xlQWxsQWNjb3JkaW9ucyA9IChlZGl0b3I6IEVkaXRvciwgc3RhdGU/OiBib29sZWFuKTogdm9pZCA9PiB7XG4gIGNvbnN0IGFjY29yZGlvbnMgPSBBcnJheS5mcm9tKGVkaXRvci5nZXRCb2R5KCkucXVlcnlTZWxlY3RvckFsbCgnZGV0YWlscycpKTtcbiAgaWYgKGFjY29yZGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIEFyci5lYWNoKGFjY29yZGlvbnMsIChhY2NvcmRpb24pID0+IHRvZ2dsZURldGFpbHNFbGVtZW50KGVkaXRvci5yZWFkb25seSwgYWNjb3JkaW9uLCBzdGF0ZSA/PyAhVXRpbHMuaXNPcGVuKGFjY29yZGlvbikpKTtcbiAgRXZlbnRzLmZpcmVUb2dnbGVBbGxBY2NvcmRpb25zRXZlbnQoZWRpdG9yLCBhY2NvcmRpb25zLCBzdGF0ZSk7XG59O1xuXG5leHBvcnQge1xuICBpbnNlcnRBY2NvcmRpb24sXG4gIHRvZ2dsZUFjY29yZGlvbixcbiAgcmVtb3ZlQWNjb3JkaW9uLFxuICB0b2dnbGVBbGxBY2NvcmRpb25zXG59O1xuIiwiY29uc3QgYWNjb3JkaW9uVGFnID0gJ2RldGFpbHMnO1xuY29uc3QgYWNjb3JkaW9uRGV0YWlsc0NsYXNzID0gJ21jZS1hY2NvcmRpb24nO1xuY29uc3QgYWNjb3JkaW9uU3VtbWFyeUNsYXNzID0gJ21jZS1hY2NvcmRpb24tc3VtbWFyeSc7XG5jb25zdCBhY2NvcmRpb25Cb2R5V3JhcHBlckNsYXNzID0gJ21jZS1hY2NvcmRpb24tYm9keSc7XG5jb25zdCBhY2NvcmRpb25Cb2R5V3JhcHBlclRhZyA9ICdkaXYnO1xuY29uc3QgYWNjb3JkaW9uUmVhZG9ubHlDb21wZW5zYXRpb25BdHRyaWJ1dGUgPSAnZGF0YS1tY2UtYWNjb3JkaW9uLW9wZW4nO1xuXG5leHBvcnQge1xuICBhY2NvcmRpb25Cb2R5V3JhcHBlckNsYXNzLFxuICBhY2NvcmRpb25Cb2R5V3JhcHBlclRhZyxcbiAgYWNjb3JkaW9uRGV0YWlsc0NsYXNzLFxuICBhY2NvcmRpb25SZWFkb25seUNvbXBlbnNhdGlvbkF0dHJpYnV0ZSxcbiAgYWNjb3JkaW9uU3VtbWFyeUNsYXNzLFxuICBhY2NvcmRpb25UYWdcbn07XG4iLCJpbXBvcnQgdHlwZSBFZGl0b3IgZnJvbSAndGlueW1jZS9jb3JlL2FwaS9FZGl0b3InO1xuaW1wb3J0IFZLIGZyb20gJ3RpbnltY2UvY29yZS9hcGkvdXRpbC9WSyc7XG5cbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vVXRpbHMnO1xuXG5jb25zdCBzZXR1cEVudGVyS2V5SW5TdW1tYXJ5ID0gKGVkaXRvcjogRWRpdG9yKTogdm9pZCA9PiB7XG4gIGVkaXRvci5vbigna2V5ZG93bicsIChldmVudCk6IHZvaWQgPT4ge1xuICAgIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gVksuRU5URVJcbiAgICAgICYmIFV0aWxzLmlzSW5TdW1tYXJ5KGVkaXRvcikgfHwgVXRpbHMuaXNBdERldGFpbHNTdGFydChlZGl0b3IpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWRpdG9yLmV4ZWNDb21tYW5kKCdUb2dnbGVBY2NvcmRpb24nKTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3Qgc2V0dXAgPSAoZWRpdG9yOiBFZGl0b3IpOiB2b2lkID0+IHtcbiAgc2V0dXBFbnRlcktleUluU3VtbWFyeShlZGl0b3IpO1xuXG4gIGVkaXRvci5vbignRXhlY0NvbW1hbmQnLCAoZSkgPT4ge1xuICAgIGNvbnN0IGNtZCA9IGUuY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICgoY21kID09PSAnZGVsZXRlJyB8fCBjbWQgPT09ICdmb3J3YXJkZGVsZXRlJykgJiYgVXRpbHMuaXNEZXRhaWxzU2VsZWN0ZWQoZWRpdG9yKSkge1xuICAgICAgVXRpbHMubm9ybWFsaXplRGV0YWlscyhlZGl0b3IpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnQgeyBzZXR1cCB9O1xuIiwiaW1wb3J0IHR5cGUgRWRpdG9yIGZyb20gJ3RpbnltY2UvY29yZS9hcGkvRWRpdG9yJztcbmltcG9ydCBFbnYgZnJvbSAndGlueW1jZS9jb3JlL2FwaS9FbnYnO1xuXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL1V0aWxzJztcblxuY29uc3Qgc2V0dXAgPSAoZWRpdG9yOiBFZGl0b3IpOiB2b2lkID0+IHtcbiAgLy8gVElOWS0xMDE3NzogT24gU2FmYXJpLCBjbGlja2luZyBvbiB0aGUgZXhwYW5kIGFycm93IG9mIHRoZSBgZGV0YWlsc2AgZWxlbWVudCBzZXRzIHRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoZSBgc3VtbWFyeWAsXG4gIC8vIHNvIHdlIG92ZXJyaWRlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGJlZ2lubmluZyBvZiBgc3VtbWFyeWAgY29udGVudFxuICBpZiAoRW52LmJyb3dzZXIuaXNTYWZhcmkoKSkge1xuICAgIGVkaXRvci5vbignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgaWYgKFV0aWxzLmlzU3VtbWFyeShlLnRhcmdldCkpIHtcbiAgICAgICAgY29uc3Qgc3VtbWFyeSA9IGUudGFyZ2V0O1xuICAgICAgICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICAgICAgICBpZiAocm5nLmNvbGxhcHNlZCAmJiBybmcuc3RhcnRDb250YWluZXIgPT09IHN1bW1hcnkucGFyZW50Tm9kZSAmJiBybmcuc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uLnNldEN1cnNvckxvY2F0aW9uKHN1bW1hcnksIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbmV4cG9ydCB7XG4gIHNldHVwXG59O1xuIiwiaW1wb3J0IHsgT3B0aW9uYWwgfSBmcm9tICdAZXBob3gva2F0YW1hcmknO1xuXG5pbXBvcnQgdHlwZSBFZGl0b3IgZnJvbSAndGlueW1jZS9jb3JlL2FwaS9FZGl0b3InO1xuaW1wb3J0IFRvb2xzIGZyb20gJ3RpbnltY2UvY29yZS9hcGkvdXRpbC9Ub29scyc7XG5cbmV4cG9ydCBjb25zdCBpc1N1bW1hcnkgPSAobm9kZT86IE5vZGUgfCBudWxsKTogbm9kZSBpcyBIVE1MRWxlbWVudCA9PlxuICBub2RlPy5ub2RlTmFtZSA9PT0gJ1NVTU1BUlknO1xuXG5leHBvcnQgY29uc3QgaXNEZXRhaWxzID0gKG5vZGU/OiBOb2RlIHwgbnVsbCk6IG5vZGUgaXMgSFRNTERldGFpbHNFbGVtZW50ID0+XG4gIG5vZGU/Lm5vZGVOYW1lID09PSAnREVUQUlMUyc7XG5cbmV4cG9ydCBjb25zdCBpc09wZW4gPSAoZGV0YWlsczogSFRNTERldGFpbHNFbGVtZW50KTogYm9vbGVhbiA9PlxuICBkZXRhaWxzLmhhc0F0dHJpYnV0ZSgnb3BlbicpO1xuXG5leHBvcnQgY29uc3QgaXNJblN1bW1hcnkgPSAoZWRpdG9yOiBFZGl0b3IpOiBib29sZWFuID0+IHtcbiAgY29uc3Qgbm9kZSA9IGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpO1xuICByZXR1cm4gaXNTdW1tYXJ5KG5vZGUpIHx8IEJvb2xlYW4oZWRpdG9yLmRvbS5nZXRQYXJlbnQobm9kZSwgaXNTdW1tYXJ5KSk7XG59O1xuXG5leHBvcnQgY29uc3QgaXNBdERldGFpbHNTdGFydCA9IChlZGl0b3I6IEVkaXRvcik6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBybmcgPSBlZGl0b3Iuc2VsZWN0aW9uLmdldFJuZygpO1xuICByZXR1cm4gaXNEZXRhaWxzKHJuZy5zdGFydENvbnRhaW5lcilcbiAgICAmJiBybmcuY29sbGFwc2VkXG4gICAgJiYgcm5nLnN0YXJ0T2Zmc2V0ID09PSAwO1xufTtcblxuZXhwb3J0IGNvbnN0IGlzSW5zZXJ0QWxsb3dlZCA9IChlZGl0b3I6IEVkaXRvcik6IGJvb2xlYW4gPT5cbiAgIWlzSW5TdW1tYXJ5KGVkaXRvcikgJiYgZWRpdG9yLmRvbS5pc0VkaXRhYmxlKGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpKSAmJiAhZWRpdG9yLm1vZGUuaXNSZWFkT25seSgpO1xuXG5leHBvcnQgY29uc3QgZ2V0U2VsZWN0ZWREZXRhaWxzID0gKGVkaXRvcjogRWRpdG9yKTogT3B0aW9uYWw8SFRNTERldGFpbHNFbGVtZW50PiA9PlxuICBPcHRpb25hbC5mcm9tKGVkaXRvci5kb20uZ2V0UGFyZW50KGVkaXRvci5zZWxlY3Rpb24uZ2V0Tm9kZSgpLCBpc0RldGFpbHMpKTtcblxuZXhwb3J0IGNvbnN0IGlzRGV0YWlsc1NlbGVjdGVkID0gKGVkaXRvcjogRWRpdG9yKTogYm9vbGVhbiA9PlxuICBnZXRTZWxlY3RlZERldGFpbHMoZWRpdG9yKS5pc1NvbWUoKTtcblxuZXhwb3J0IGNvbnN0IGluc2VydEJvZ3VzID0gPFQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oZWxlbWVudDogVCk6IFQgPT4ge1xuICBlbGVtZW50LmlubmVySFRNTCA9ICc8YnIgZGF0YS1tY2UtYm9ndXM9XCIxXCIgLz4nO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVQYXJhZ3JhcGggPSAoZWRpdG9yOiBFZGl0b3IpOiBIVE1MUGFyYWdyYXBoRWxlbWVudCA9PlxuICBpbnNlcnRCb2d1cyhlZGl0b3IuZG9tLmNyZWF0ZSgncCcpKTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVN1bW1hcnkgPSAoZWRpdG9yOiBFZGl0b3IpOiBIVE1MRWxlbWVudCA9PlxuICBpbnNlcnRCb2d1cyhlZGl0b3IuZG9tLmNyZWF0ZSgnc3VtbWFyeScpKTtcblxuZXhwb3J0IGNvbnN0IGluc2VydEFuZFNlbGVjdFBhcmFncmFwaEFmdGVyID0gKGVkaXRvcjogRWRpdG9yLCB0YXJnZXQ6IEhUTUxFbGVtZW50KTogdm9pZCA9PiB7XG4gIGNvbnN0IHBhcmFncmFwaCA9IGNyZWF0ZVBhcmFncmFwaChlZGl0b3IpO1xuICB0YXJnZXQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHBhcmFncmFwaCk7XG4gIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24ocGFyYWdyYXBoLCAwKTtcbn07XG5cbmV4cG9ydCBjb25zdCBub3JtYWxpemVDb250ZW50ID0gKGVkaXRvcjogRWRpdG9yLCBhY2NvcmRpb246IEhUTUxEZXRhaWxzRWxlbWVudCk6IHZvaWQgPT4ge1xuICBpZiAoaXNTdW1tYXJ5KGFjY29yZGlvbj8ubGFzdENoaWxkKSkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9IGNyZWF0ZVBhcmFncmFwaChlZGl0b3IpO1xuICAgIGFjY29yZGlvbi5hcHBlbmRDaGlsZChwYXJhZ3JhcGgpO1xuICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24ocGFyYWdyYXBoLCAwKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVN1bW1hcnkgPSAoZWRpdG9yOiBFZGl0b3IsIGFjY29yZGlvbjogSFRNTERldGFpbHNFbGVtZW50KTogdm9pZCA9PiB7XG4gIGlmICghaXNTdW1tYXJ5KGFjY29yZGlvbj8uZmlyc3RDaGlsZCkpIHtcbiAgICBjb25zdCBzdW1tYXJ5ID0gY3JlYXRlU3VtbWFyeShlZGl0b3IpO1xuICAgIGFjY29yZGlvbi5wcmVwZW5kKHN1bW1hcnkpO1xuICAgIGVkaXRvci5zZWxlY3Rpb24uc2V0Q3Vyc29yTG9jYXRpb24oc3VtbWFyeSwgMCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBub3JtYWxpemVBY2NvcmRpb24gPSAoZWRpdG9yOiBFZGl0b3IpID0+IChhY2NvcmRpb246IEhUTUxEZXRhaWxzRWxlbWVudCk6IHZvaWQgPT4ge1xuICBub3JtYWxpemVDb250ZW50KGVkaXRvciwgYWNjb3JkaW9uKTtcbiAgbm9ybWFsaXplU3VtbWFyeShlZGl0b3IsIGFjY29yZGlvbik7XG59O1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplRGV0YWlscyA9IChlZGl0b3I6IEVkaXRvcik6IHZvaWQgPT4ge1xuICBUb29scy5lYWNoKFxuICAgIFRvb2xzLmdyZXAoZWRpdG9yLmRvbS5zZWxlY3Q8SFRNTERldGFpbHNFbGVtZW50PignZGV0YWlscycsIGVkaXRvci5nZXRCb2R5KCkpKSxcbiAgICBub3JtYWxpemVBY2NvcmRpb24oZWRpdG9yKVxuICApO1xufTtcbiIsImltcG9ydCB7IEFyciwgVHlwZSB9IGZyb20gJ0BlcGhveC9rYXRhbWFyaSc7XG5cbmltcG9ydCB0eXBlIEVkaXRvciBmcm9tICd0aW55bWNlL2NvcmUvYXBpL0VkaXRvcic7XG5pbXBvcnQgQXN0Tm9kZSBmcm9tICd0aW55bWNlL2NvcmUvYXBpL2h0bWwvTm9kZSc7XG5cbmltcG9ydCAqIGFzIElkZW50aWZpZXJzIGZyb20gJy4uL0lkZW50aWZpZXJzJztcblxuaW1wb3J0ICogYXMgTm9ybWFsaXplIGZyb20gJy4vTm9ybWFsaXplJztcblxuaW50ZXJmYWNlIEFjY29yZGlvbkNoaWxkcmVuIHtcbiAgc3VtbWFyeU5vZGU6IEFzdE5vZGUgfCB1bmRlZmluZWQ7XG4gIHdyYXBwZXJOb2RlOiBBc3ROb2RlIHwgdW5kZWZpbmVkO1xuICBvdGhlck5vZGVzOiBBc3ROb2RlW107XG59XG5cbmNvbnN0IGdldENsYXNzTGlzdCA9IChub2RlOiBBc3ROb2RlKTogc3RyaW5nW10gPT5cbiAgbm9kZS5hdHRyKCdjbGFzcycpPy5zcGxpdCgnICcpID8/IFtdO1xuXG5jb25zdCBhZGRDbGFzc2VzID0gKG5vZGU6IEFzdE5vZGUsIGNsYXNzZXM6IHN0cmluZ1tdKTogdm9pZCA9PiB7XG4gIGNvbnN0IGNsYXNzTGlzdFNldCA9IG5ldyBTZXQoWyAuLi5nZXRDbGFzc0xpc3Qobm9kZSksIC4uLmNsYXNzZXMgXSk7XG4gIGNvbnN0IG5ld0NsYXNzTGlzdCA9IEFycmF5LmZyb20oY2xhc3NMaXN0U2V0KTtcblxuICBpZiAobmV3Q2xhc3NMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICBub2RlLmF0dHIoJ2NsYXNzJywgbmV3Q2xhc3NMaXN0LmpvaW4oJyAnKSk7XG4gIH1cbn07XG5cbmNvbnN0IHJlbW92ZUNsYXNzZXMgPSAobm9kZTogQXN0Tm9kZSwgY2xhc3NlczogU2V0PHN0cmluZz4pOiB2b2lkID0+IHtcbiAgY29uc3QgbmV3Q2xhc3NMaXN0ID0gQXJyLmZpbHRlcihnZXRDbGFzc0xpc3Qobm9kZSksIChjbGF6eikgPT4gIWNsYXNzZXMuaGFzKGNsYXp6KSk7XG4gIG5vZGUuYXR0cignY2xhc3MnLCBuZXdDbGFzc0xpc3QubGVuZ3RoID4gMCA/IG5ld0NsYXNzTGlzdC5qb2luKCcgJykgOiBudWxsKTtcbn07XG5cbmNvbnN0IGlzQWNjb3JkaW9uRGV0YWlsc05vZGUgPSAobm9kZTogQXN0Tm9kZSk6IGJvb2xlYW4gPT5cbiAgbm9kZS5uYW1lID09PSBJZGVudGlmaWVycy5hY2NvcmRpb25UYWcgJiYgQXJyLmNvbnRhaW5zKGdldENsYXNzTGlzdChub2RlKSwgSWRlbnRpZmllcnMuYWNjb3JkaW9uRGV0YWlsc0NsYXNzKTtcblxuY29uc3QgaXNBY2NvcmRpb25Cb2R5V3JhcHBlck5vZGUgPSAobm9kZTogQXN0Tm9kZSk6IGJvb2xlYW4gPT5cbiAgbm9kZS5uYW1lID09PSBJZGVudGlmaWVycy5hY2NvcmRpb25Cb2R5V3JhcHBlclRhZyAmJiBBcnIuY29udGFpbnMoZ2V0Q2xhc3NMaXN0KG5vZGUpLCBJZGVudGlmaWVycy5hY2NvcmRpb25Cb2R5V3JhcHBlckNsYXNzKTtcblxuY29uc3QgZ2V0QWNjb3JkaW9uQ2hpbGRyZW4gPSAoYWNjb3JkaW9uTm9kZTogQXN0Tm9kZSk6IEFjY29yZGlvbkNoaWxkcmVuID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBhY2NvcmRpb25Ob2RlLmNoaWxkcmVuKCk7XG4gIGxldCBzdW1tYXJ5Tm9kZTogQXN0Tm9kZSB8IHVuZGVmaW5lZDtcbiAgbGV0IHdyYXBwZXJOb2RlOiBBc3ROb2RlIHwgdW5kZWZpbmVkO1xuICBjb25zdCBvdGhlck5vZGVzOiBBc3ROb2RlW10gPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBPbmx5IHdhbnQgdG8gZ2V0IHRoZSBmaXJzdCBzdW1tYXJ5IGVsZW1lbnRcbiAgICBpZiAoY2hpbGQubmFtZSA9PT0gJ3N1bW1hcnknICYmIFR5cGUuaXNOdWxsYWJsZShzdW1tYXJ5Tm9kZSkpIHtcbiAgICAgIHN1bW1hcnlOb2RlID0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChpc0FjY29yZGlvbkJvZHlXcmFwcGVyTm9kZShjaGlsZCkgJiYgVHlwZS5pc051bGxhYmxlKHdyYXBwZXJOb2RlKSkge1xuICAgICAgd3JhcHBlck5vZGUgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXJOb2Rlcy5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN1bW1hcnlOb2RlLFxuICAgIHdyYXBwZXJOb2RlLFxuICAgIG90aGVyTm9kZXNcbiAgfTtcbn07XG5cbmNvbnN0IHBhZElucHV0Tm9kZSA9IChub2RlOiBBc3ROb2RlKTogdm9pZCA9PiB7XG4gIC8vIEFkZCBiciB0byBub2RlIHRvIGVuc3VyZSB0aGUgY3Vyc29yIGNhbiBiZSBwbGFjZWQgaW5zaWRlIHRoZSBub2RlXG4gIC8vIE1hcmsgYXMgYm9ndXMgc28gdGhhdCBpdCBpcyBjb252ZXJ0ZWQgdG8gYW4gbmJzcCBvbiBzZXJpYWxpemF0aW9uXG4gIGNvbnN0IGJyID0gbmV3IEFzdE5vZGUoJ2JyJywgMSk7XG4gIGJyLmF0dHIoJ2RhdGEtbWNlLWJvZ3VzJywgJzEnKTtcbiAgbm9kZS5lbXB0eSgpO1xuICBub2RlLmFwcGVuZChicik7XG59O1xuXG5jb25zdCBzZXR1cCA9IChlZGl0b3I6IEVkaXRvcik6IHZvaWQgPT4ge1xuICBlZGl0b3Iub24oJ1ByZUluaXQnLCAoKSA9PiB7XG4gICAgY29uc3QgeyBzZXJpYWxpemVyLCBwYXJzZXIgfSA9IGVkaXRvcjtcblxuICAgIC8vIFB1cnBvc2U6XG4gICAgLy8gLSBhZGQgbWNlLWFjY29yZGlvbi1zdW1tYXJ5IGNsYXNzIHRvIHN1bW1hcnkgbm9kZVxuICAgIC8vIC0gd3JhcCBkZXRhaWxzIGJvZHkgaW4gZGl2IGFuZCBhZGQgbWNlLWFjY29yZGlvbi1ib2R5IGNsYXNzIChUSU5ZLTk5NTkgYXNzaXN0cyB3aXRoIENocm9tZSBzZWxlY3Rpb24gaXNzdWUpXG4gICAgLy8gLSBOb3JtYWxpemUgYWNjb3JkaW9uICdvcGVuJyBhdHRyaWJ1dGUgdmFsdWUgdG8gb3Blbj1cIm9wZW5cIlxuICAgIHBhcnNlci5hZGROb2RlRmlsdGVyKElkZW50aWZpZXJzLmFjY29yZGlvblRhZywgKG5vZGVzKSA9PiB7XG4gICAgICAvLyBVc2luZyBhIHRyYWRpdGlvbmFsIGZvciBsb29wIGhlcmUgYXMgd2UgbWF5IGhhdmUgdG8gaXRlcmF0ZSBvdmVyIG1hbnkgbm9kZXMgYW5kIGl0IGlzIHRoZSBtb3N0IHBlcmZvcm1hbnQgd2F5IG9mIGRvaW5nIHNvXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgTm9ybWFsaXplLm5vcm1hbGl6ZU9wZW5BdHRyaWJ1dGUobm9kZSk7XG4gICAgICAgIGlmIChpc0FjY29yZGlvbkRldGFpbHNOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgYWNjb3JkaW9uTm9kZSA9IG5vZGU7XG4gICAgICAgICAgYWNjb3JkaW9uTm9kZS5hdHRyKElkZW50aWZpZXJzLmFjY29yZGlvblJlYWRvbmx5Q29tcGVuc2F0aW9uQXR0cmlidXRlLCBhY2NvcmRpb25Ob2RlLmF0dHIoJ29wZW4nKSA9PT0gJ29wZW4nID8gJ29wZW4nIDogJ2Nsb3NlZCcpO1xuICAgICAgICAgIGNvbnN0IHsgc3VtbWFyeU5vZGUsIHdyYXBwZXJOb2RlLCBvdGhlck5vZGVzIH0gPSBnZXRBY2NvcmRpb25DaGlsZHJlbihhY2NvcmRpb25Ob2RlKTtcblxuICAgICAgICAgIGNvbnN0IGhhc1N1bW1hcnlOb2RlID0gVHlwZS5pc05vbk51bGxhYmxlKHN1bW1hcnlOb2RlKTtcbiAgICAgICAgICBjb25zdCBuZXdTdW1tYXJ5Tm9kZSA9IGhhc1N1bW1hcnlOb2RlID8gc3VtbWFyeU5vZGUgOiBuZXcgQXN0Tm9kZSgnc3VtbWFyeScsIDEpO1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vdGhpbmcgaW4gdGhlIHN1bW1hcnksIHBhZCBpdCB3aXRoIGEgYnJcbiAgICAgICAgICAvLyBzbyB0aGUgY3Vyc29yIGNhbiBiZSBwdXQgaW5zaWRlIHRoZSBhY2NvcmRpb24gc3VtbWFyeVxuICAgICAgICAgIGlmIChUeXBlLmlzTnVsbGFibGUobmV3U3VtbWFyeU5vZGUuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgIHBhZElucHV0Tm9kZShuZXdTdW1tYXJ5Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZENsYXNzZXMobmV3U3VtbWFyeU5vZGUsIFsgSWRlbnRpZmllcnMuYWNjb3JkaW9uU3VtbWFyeUNsYXNzIF0pO1xuICAgICAgICAgIGlmICghaGFzU3VtbWFyeU5vZGUpIHtcbiAgICAgICAgICAgIGlmIChUeXBlLmlzTm9uTnVsbGFibGUoYWNjb3JkaW9uTm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICBhY2NvcmRpb25Ob2RlLmluc2VydChuZXdTdW1tYXJ5Tm9kZSwgYWNjb3JkaW9uTm9kZS5maXJzdENoaWxkLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFjY29yZGlvbk5vZGUuYXBwZW5kKG5ld1N1bW1hcnlOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoYXNXcmFwcGVyTm9kZSA9IFR5cGUuaXNOb25OdWxsYWJsZSh3cmFwcGVyTm9kZSk7XG4gICAgICAgICAgY29uc3QgbmV3V3JhcHBlck5vZGUgPSBoYXNXcmFwcGVyTm9kZSA/IHdyYXBwZXJOb2RlIDogbmV3IEFzdE5vZGUoSWRlbnRpZmllcnMuYWNjb3JkaW9uQm9keVdyYXBwZXJUYWcsIDEpO1xuICAgICAgICAgIG5ld1dyYXBwZXJOb2RlLmF0dHIoJ2RhdGEtbWNlLWJvZ3VzJywgJzEnKTtcbiAgICAgICAgICBhZGRDbGFzc2VzKG5ld1dyYXBwZXJOb2RlLCBbIElkZW50aWZpZXJzLmFjY29yZGlvbkJvZHlXcmFwcGVyQ2xhc3MgXSk7XG4gICAgICAgICAgaWYgKG90aGVyTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlck5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG90aGVyTm9kZSA9IG90aGVyTm9kZXNbal07XG4gICAgICAgICAgICAgIG5ld1dyYXBwZXJOb2RlLmFwcGVuZChvdGhlck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBub3RoaW5nIGluIHRoZSB3cmFwcGVyLCBhcHBlbmQgYSBwbGFjZWhvbGRlciBwIHRhZ1xuICAgICAgICAgIC8vIHNvIHRoZSBjdXJzb3IgY2FuIGJlIHB1dCBpbnNpZGUgdGhlIGFjY29yZGlvbiBib2R5XG4gICAgICAgICAgaWYgKFR5cGUuaXNOdWxsYWJsZShuZXdXcmFwcGVyTm9kZS5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgcE5vZGUgPSBuZXcgQXN0Tm9kZSgncCcsIDEpO1xuICAgICAgICAgICAgcGFkSW5wdXROb2RlKHBOb2RlKTtcbiAgICAgICAgICAgIG5ld1dyYXBwZXJOb2RlLmFwcGVuZChwTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaGFzV3JhcHBlck5vZGUpIHtcbiAgICAgICAgICAgIGFjY29yZGlvbk5vZGUuYXBwZW5kKG5ld1dyYXBwZXJOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFB1cnBvc2U6XG4gICAgLy8gLSByZW1vdmUgZGl2IHdyYXBwaW5nIGRldGFpbHMgY29udGVudCBhcyBpdCBpcyBvbmx5IHJlcXVpcmVkIGR1cmluZyBlZGl0b3IgKHNlZSBUSU5ZLTk5NTkgZm9yIGRldGFpbHMpXG4gICAgLy8gLSByZW1vdmUgbWNlLWFjY29yZGlvbi1zdW1tYXJ5IGNsYXNzIG9uIHRoZSBzdW1tYXJ5IG5vZGVcbiAgICBzZXJpYWxpemVyLmFkZE5vZGVGaWx0ZXIoSWRlbnRpZmllcnMuYWNjb3JkaW9uVGFnLCAobm9kZXMpID0+IHtcbiAgICAgIGNvbnN0IHN1bW1hcnlDbGFzc1JlbW92ZVNldCA9IG5ldyBTZXQoWyBJZGVudGlmaWVycy5hY2NvcmRpb25TdW1tYXJ5Q2xhc3MgXSk7XG4gICAgICAvLyBVc2luZyBhIHRyYWRpdGlvbmFsIGZvciBsb29wIGhlcmUgYXMgd2UgbWF5IGhhdmUgdG8gaXRlcmF0ZSBvdmVyIG1hbnkgbm9kZXMgYW5kIGl0IGlzIHRoZSBtb3N0IHBlcmZvcm1hbnQgd2F5IG9mIGRvaW5nIHNvXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKGlzQWNjb3JkaW9uRGV0YWlsc05vZGUobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBhY2NvcmRpb25Ob2RlID0gbm9kZTtcbiAgICAgICAgICBhY2NvcmRpb25Ob2RlLmF0dHIoJ29wZW4nLCBhY2NvcmRpb25Ob2RlLmF0dHIoSWRlbnRpZmllcnMuYWNjb3JkaW9uUmVhZG9ubHlDb21wZW5zYXRpb25BdHRyaWJ1dGUpID09PSAnb3BlbicgPyAnb3BlbicgOiBudWxsKTtcbiAgICAgICAgICBhY2NvcmRpb25Ob2RlLmF0dHIoSWRlbnRpZmllcnMuYWNjb3JkaW9uUmVhZG9ubHlDb21wZW5zYXRpb25BdHRyaWJ1dGUsIG51bGwpO1xuICAgICAgICAgIGNvbnN0IHsgc3VtbWFyeU5vZGUsIHdyYXBwZXJOb2RlIH0gPSBnZXRBY2NvcmRpb25DaGlsZHJlbihhY2NvcmRpb25Ob2RlKTtcblxuICAgICAgICAgIGlmIChUeXBlLmlzTm9uTnVsbGFibGUoc3VtbWFyeU5vZGUpKSB7XG4gICAgICAgICAgICByZW1vdmVDbGFzc2VzKHN1bW1hcnlOb2RlLCBzdW1tYXJ5Q2xhc3NSZW1vdmVTZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChUeXBlLmlzTm9uTnVsbGFibGUod3JhcHBlck5vZGUpKSB7XG4gICAgICAgICAgICB3cmFwcGVyTm9kZS51bndyYXAoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5leHBvcnQge1xuICBzZXR1cFxufTtcbiIsIlxuaW1wb3J0IHR5cGUgQXN0Tm9kZSBmcm9tICd0aW55bWNlL2NvcmUvYXBpL2h0bWwvTm9kZSc7XG5cbmNvbnN0IG5vcm1hbGl6ZU9wZW5BdHRyaWJ1dGUgPSAobm9kZTogQXN0Tm9kZSk6IHZvaWQgPT4ge1xuICBpZiAoaGFzQXR0cmlidXRlKG5vZGUsICdvcGVuJykpIHtcbiAgICBzZXRBdHRyaWJ1dGUobm9kZSwgJ29wZW4nLCAnb3BlbicpO1xuICB9XG59O1xuXG5jb25zdCBoYXNBdHRyaWJ1dGUgPSAobm9kZTogQXN0Tm9kZSwgYXR0cmlidXRlOiBzdHJpbmcpOiBib29sZWFuID0+XG4gIG5vZGUuYXR0cihhdHRyaWJ1dGUpICE9PSB1bmRlZmluZWQ7XG5cbmNvbnN0IHNldEF0dHJpYnV0ZSA9IChub2RlOiBBc3ROb2RlLCBhdHRyaWJ1dGU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQgPT4ge1xuICBub2RlLmF0dHIoYXR0cmlidXRlLCB2YWx1ZSk7XG59O1xuXG5leHBvcnQgeyBub3JtYWxpemVPcGVuQXR0cmlidXRlIH07XG4iLCJpbXBvcnQgdHlwZSB7IE1lbnUsIFRvb2xiYXIgfSBmcm9tICdAZXBob3gvYnJpZGdlJztcblxuaW1wb3J0IHR5cGUgRWRpdG9yIGZyb20gJ3RpbnltY2UvY29yZS9hcGkvRWRpdG9yJztcblxuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi4vY29yZS9VdGlscyc7XG5cbmNvbnN0IG9uU2V0dXAgPSAoZWRpdG9yOiBFZGl0b3IpID0+IChidXR0b25BcGk6IFRvb2xiYXIuVG9vbGJhckJ1dHRvbkluc3RhbmNlQXBpIHwgTWVudS5NZW51SXRlbUluc3RhbmNlQXBpKSA9PiB7XG4gIGNvbnN0IG9uTm9kZUNoYW5nZSA9ICgpID0+IGJ1dHRvbkFwaS5zZXRFbmFibGVkKFV0aWxzLmlzSW5zZXJ0QWxsb3dlZChlZGl0b3IpKTtcbiAgZWRpdG9yLm9uKCdOb2RlQ2hhbmdlJywgb25Ob2RlQ2hhbmdlKTtcbiAgcmV0dXJuICgpID0+IGVkaXRvci5vZmYoJ05vZGVDaGFuZ2UnLCBvbk5vZGVDaGFuZ2UpO1xufTtcblxuY29uc3QgcmVnaXN0ZXIgPSAoZWRpdG9yOiBFZGl0b3IpOiB2b2lkID0+IHtcbiAgY29uc3Qgb25BY3Rpb24gPSAoKSA9PiBlZGl0b3IuZXhlY0NvbW1hbmQoJ0luc2VydEFjY29yZGlvbicpO1xuICBlZGl0b3IudWkucmVnaXN0cnkuYWRkQnV0dG9uKCdhY2NvcmRpb24nLCB7IGljb246ICdhY2NvcmRpb24nLCB0b29sdGlwOiAnSW5zZXJ0IGFjY29yZGlvbicsIG9uU2V0dXA6IG9uU2V0dXAoZWRpdG9yKSwgb25BY3Rpb24gfSk7XG4gIGVkaXRvci51aS5yZWdpc3RyeS5hZGRNZW51SXRlbSgnYWNjb3JkaW9uJywgeyBpY29uOiAnYWNjb3JkaW9uJywgdGV4dDogJ0FjY29yZGlvbicsIG9uU2V0dXA6IG9uU2V0dXAoZWRpdG9yKSwgb25BY3Rpb24gfSk7XG5cbiAgZWRpdG9yLnVpLnJlZ2lzdHJ5LmFkZFRvZ2dsZUJ1dHRvbignYWNjb3JkaW9udG9nZ2xlJywge1xuICAgIGljb246ICdhY2NvcmRpb24tdG9nZ2xlJyxcbiAgICB0b29sdGlwOiAnVG9nZ2xlIGFjY29yZGlvbicsXG4gICAgb25BY3Rpb246ICgpID0+IGVkaXRvci5leGVjQ29tbWFuZCgnVG9nZ2xlQWNjb3JkaW9uJyksXG4gICAgY29udGV4dDogJ2FueScsXG4gIH0pO1xuXG4gIGVkaXRvci51aS5yZWdpc3RyeS5hZGRUb2dnbGVCdXR0b24oJ2FjY29yZGlvbnJlbW92ZScsIHtcbiAgICBpY29uOiAncmVtb3ZlJyxcbiAgICB0b29sdGlwOiAnRGVsZXRlIGFjY29yZGlvbicsXG4gICAgb25BY3Rpb246ICgpID0+IGVkaXRvci5leGVjQ29tbWFuZCgnUmVtb3ZlQWNjb3JkaW9uJylcbiAgfSk7XG5cbiAgZWRpdG9yLnVpLnJlZ2lzdHJ5LmFkZENvbnRleHRUb29sYmFyKCdhY2NvcmRpb24nLCB7XG4gICAgcHJlZGljYXRlOiAoYWNjb3JkaW9uOiBOb2RlKSA9PlxuICAgICAgZWRpdG9yLmRvbS5pcyhhY2NvcmRpb24sICdkZXRhaWxzJykgJiYgZWRpdG9yLmdldEJvZHkoKS5jb250YWlucyhhY2NvcmRpb24pICYmIGVkaXRvci5kb20uaXNFZGl0YWJsZShhY2NvcmRpb24ucGFyZW50Tm9kZSksXG4gICAgaXRlbXM6ICdhY2NvcmRpb250b2dnbGUgYWNjb3JkaW9ucmVtb3ZlJyxcbiAgICBzY29wZTogJ25vZGUnLFxuICAgIHBvc2l0aW9uOiAnbm9kZSdcbiAgfSk7XG59O1xuXG5leHBvcnQgeyByZWdpc3RlciB9O1xuIiwiaW1wb3J0ICogYXMgVHlwZSBmcm9tICcuLi9jb3JlL1R5cGUnO1xuaW1wb3J0ICogYXMgQXJyYXlVdGlsIGZyb20gJy4uL2NvcmUvQXJyYXlVdGlsJztcblxuLyoqIEEgd2F5IG9mIGNvbXBhcmluZyB0d28gdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGUgZm9yIGVxdWFsaXR5LiAqL1xuZXhwb3J0IGludGVyZmFjZSBFcTxBPiB7XG4gIGVxOiAoeDogQSwgeTogQSkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGNvbnRyYW1hcCA9IDxBLCBCPiAoZXFhOiBFcTxBPiwgZjogKGI6IEIpID0+IEEpOiBFcTxCPiA9PlxuICBlcSgoeCwgeSkgPT4gZXFhLmVxKGYoeCksIGYoeSkpKTtcblxuZXhwb3J0IGNvbnN0IGVxID0gPEE+IChmOiAoeDogQSwgeTogQSkgPT4gYm9vbGVhbik6IEVxPEE+ID0+XG4gICh7IGVxOiBmIH0pO1xuXG5leHBvcnQgY29uc3QgdHJpcGxlRXE6IEVxPGFueT4gPSBlcSgoeCwgeSkgPT4geCA9PT0geSk7XG5cbmV4cG9ydCBjb25zdCBlcVN0cmluZzogRXE8c3RyaW5nPiA9IHRyaXBsZUVxO1xuXG5leHBvcnQgY29uc3QgZXFCb29sZWFuOiBFcTxib29sZWFuPiA9IHRyaXBsZUVxO1xuXG5leHBvcnQgY29uc3QgZXFOdW1iZXI6IEVxPG51bWJlcj4gPSB0cmlwbGVFcTtcblxuZXhwb3J0IGNvbnN0IGVxVW5kZWZpbmVkOiBFcTx1bmRlZmluZWQ+ID0gdHJpcGxlRXE7XG5cbmV4cG9ydCBjb25zdCBlcU51bGw6IEVxPG51bGw+ID0gdHJpcGxlRXE7XG5cbmV4cG9ydCBjb25zdCBlcUFycmF5ID0gPEE+IChlcWE6IEVxPEE+KTogRXE8QXJyYXlMaWtlPEE+PiA9PiBlcSgoeCwgeSkgPT4ge1xuICBpZiAoeC5sZW5ndGggIT09IHkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxlbiA9IHgubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFlcWEuZXEoeFtpXSwgeVtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuLy8gVE9ETzogTWFrZSBhbiBPcmQgdHlwZWNsYXNzXG5jb25zdCBlcVNvcnRlZEFycmF5ID0gPEE+KGVxYTogRXE8QT4sIGNvbXBhcmVGbj86IChhOiBBLCBiOiBBKSA9PiBudW1iZXIpOiBFcTxBcnJheUxpa2U8QT4+ID0+XG4gIGNvbnRyYW1hcChlcUFycmF5KGVxYSksICh4cykgPT4gQXJyYXlVdGlsLnNvcnQoeHMsIGNvbXBhcmVGbikpO1xuXG5leHBvcnQgY29uc3QgZXFSZWNvcmQgPSA8QT4gKGVxYTogRXE8QT4pOiBFcTxSZWNvcmQ8c3RyaW5nLCBBPj4gPT4gZXEoKHgsIHkpID0+IHtcbiAgY29uc3Qga3ggPSBPYmplY3Qua2V5cyh4KTtcbiAgY29uc3Qga3kgPSBPYmplY3Qua2V5cyh5KTtcbiAgaWYgKCFlcVNvcnRlZEFycmF5KGVxU3RyaW5nKS5lcShreCwga3kpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGxlbiA9IGt4Lmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHEgPSBreFtpXTtcbiAgICBpZiAoIWVxYS5lcSh4W3FdLCB5W3FdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pO1xuXG5leHBvcnQgY29uc3QgZXFBbnk6IEVxPGFueT4gPSBlcSgoeCwgeSkgPT4ge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgdHggPSBUeXBlLnR5cGVPZih4KTtcbiAgY29uc3QgdHkgPSBUeXBlLnR5cGVPZih5KTtcbiAgaWYgKHR4ICE9PSB0eSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChUeXBlLmlzRXF1YXRhYmxlVHlwZSh0eCkpIHtcbiAgICByZXR1cm4geCA9PT0geTtcblxuICB9IGVsc2UgaWYgKHR4ID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIGVxQXJyYXkoZXFBbnkpLmVxKHgsIHkpO1xuXG4gIH0gZWxzZSBpZiAodHggPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGVxUmVjb3JkKGVxQW55KS5lcSh4LCB5KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0pO1xuIiwiZXhwb3J0IGNvbnN0IG1hcCA9IDxBLCBCPih4czogQXJyYXlMaWtlPEE+LCBmOiAoYTogQSkgPT4gQik6IEJbXSA9PiB7XG4gIGNvbnN0IGxlbiA9IHhzLmxlbmd0aDtcbiAgY29uc3QgciA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgeCA9IHhzW2ldO1xuICAgIHJbaV0gPSBmKHgpO1xuICB9XG4gIHJldHVybiByO1xufTtcblxuLyoqIG1hcCBhIGZ1bmN0aW9uIG92ZXIgYW4gYXJyYXksIHRoZW4gbWFwIGFub3RoZXIgZnVuY3Rpb24gb3ZlciBldmVyeSBpdGVtIGV4Y2VwdCB0aGUgbGFzdCAqL1xuZXhwb3J0IGNvbnN0IG1hcERlbGltaXQgPSA8QSwgQj4gKHhzOiBBcnJheUxpa2U8QT4sIGY6IChhOiBBKSA9PiBCLCBkZWxpbWl0OiAoYjogQikgPT4gQik6IEJbXSA9PiB7XG4gIGNvbnN0IGxlbiA9IHhzLmxlbmd0aDtcbiAgY29uc3QgciA9IG5ldyBBcnJheShsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgIGNvbnN0IHggPSB4c1tpXTtcbiAgICByW2ldID0gZGVsaW1pdChmKHgpKTtcbiAgfVxuICBpZiAobGVuID4gMCkge1xuICAgIHJbbGVuIC0gMV0gPSAoZih4c1tsZW4gLSAxXSkpO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG5leHBvcnQgY29uc3Qgc29ydCA9IDxBPiAoeHM6IEFycmF5TGlrZTxBPiwgY29tcGFyZUZuPzogKGE6IEEsIGI6IEEpID0+IG51bWJlcik6IEFbXSA9PiB7XG4gIGNvbnN0IGNsb25lOiBBW10gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh4cyk7XG4gIHJldHVybiBjbG9uZS5zb3J0KGNvbXBhcmVGbik7XG59O1xuIiwiZXhwb3J0IGNvbnN0IHR5cGVPZiA9ICh4OiBhbnkpID0+IHtcbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cbiAgY29uc3QgdCA9IHR5cGVvZiB4O1xuICBpZiAodCA9PT0gJ29iamVjdCcgJiYgKEFycmF5LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHgpIHx8IHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXknKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmICh0ID09PSAnb2JqZWN0JyAmJiAoU3RyaW5nLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHgpIHx8IHguY29uc3RydWN0b3IgJiYgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnU3RyaW5nJykpIHtcbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuXG5jb25zdCBpc1R5cGUgPSA8VD4odHlwZTogc3RyaW5nKSA9PiAodmFsdWU6IGFueSk6IHZhbHVlIGlzIFQgPT4gdHlwZU9mKHZhbHVlKSA9PT0gdHlwZTtcblxuZXhwb3J0IGNvbnN0IGlzU3RyaW5nID0gaXNUeXBlPHN0cmluZz4oJ3N0cmluZycpO1xuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gaXNUeXBlPE9iamVjdD4oJ29iamVjdCcpO1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBpc1R5cGU8QXJyYXk8dW5rbm93bj4+KCdhcnJheScpO1xuZXhwb3J0IGNvbnN0IGlzTnVsbCA9IGlzVHlwZTxudWxsPignbnVsbCcpO1xuZXhwb3J0IGNvbnN0IGlzQm9vbGVhbiA9IGlzVHlwZTxib29sZWFuPignYm9vbGVhbicpO1xuZXhwb3J0IGNvbnN0IGlzVW5kZWZpbmVkID0gaXNUeXBlPHVuZGVmaW5lZD4oJ3VuZGVmaW5lZCcpO1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSBpc1R5cGU8RnVuY3Rpb24+KCdmdW5jdGlvbicpO1xuZXhwb3J0IGNvbnN0IGlzTnVtYmVyID0gaXNUeXBlPG51bWJlcj4oJ251bWJlcicpO1xuXG5leHBvcnQgY29uc3QgaXNFcXVhdGFibGVUeXBlID0gKHg6IHN0cmluZyk6IGJvb2xlYW4gPT5cbiAgWyAndW5kZWZpbmVkJywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZycsICdmdW5jdGlvbicsICd4bWwnLCAnbnVsbCcgXS5pbmRleE9mKHgpICE9PSAtMTtcbiIsIl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuICAgICAgICB9XG4gICAgfVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ydiA9ICgpID0+IChcIjEuNS4yXCIpIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ydWlkID0gXCJidW5kbGVyPXJzcGFja0AxLjUuMlwiO1xuIiwiaW1wb3J0IFBsdWdpbiBmcm9tICcuL1BsdWdpbic7XG5cblBsdWdpbigpO1xuXG4vKiogKioqKipcbiAqIERPIE5PVCBFWFBPUlQgQU5ZVEhJTkdcbiAqXG4gKiBJRiBZT1UgRE8gUk9MTFVQIFdJTEwgTEVBVkUgQSBHTE9CQUwgT04gVEhFIFBBR0VcbiAqKioqKioqL1xuIl0sIm5hbWVzIjpbIkFyciIsIkZ1biIsIk9wdGlvbmFsIiwiQXR0cmlidXRlIiwiQ29tcGFyZSIsIkNzcyIsIkluc2VydCIsIkluc2VydEFsbCIsIlByZWRpY2F0ZUZpbHRlciIsIlByZWRpY2F0ZUZpbmQiLCJSZW1vdmUiLCJTZWxlY3RvckZpbHRlciIsIlNlbGVjdG9yRmluZCIsIlN1Z2FyRWxlbWVudCIsIlN1Z2FyTm9kZSIsIlN1Z2FyVGV4dCIsIlRyYXZlcnNlIiwiVGFnQm91bmRhcmllcyIsImNsb25lIiwiZWxlbWVudCIsImRvY3VtZW50IiwiaXNCb3VuZGFyeSIsImlzRW1wdHlUYWciLCJpc05vbkVkaXRhYmxlIiwiY29tcGFyZVBvc2l0aW9uIiwib3RoZXIiLCJjb3B5QXR0cmlidXRlc1RvIiwic291cmNlIiwiZGVzdGluYXRpb24iLCJhcyIsImlzU3BlY2lhbCIsInRhZyIsImdldExhbmd1YWdlIiwiRXEiLCJUeXBlIiwibmF0aXZlU2xpY2UiLCJBcnJheSIsIm5hdGl2ZUluZGV4T2YiLCJuYXRpdmVQdXNoIiwicmF3SW5kZXhPZiIsInRzIiwidCIsImluZGV4T2YiLCJ4cyIsIngiLCJyIiwiY29udGFpbnMiLCJleGlzdHMiLCJwcmVkIiwiaSIsImxlbiIsInJhbmdlIiwibnVtIiwiZiIsImNodW5rIiwiYXJyYXkiLCJzaXplIiwicyIsIm1hcCIsImVhY2giLCJlYWNociIsInBhcnRpdGlvbiIsInBhc3MiLCJmYWlsIiwiYXJyIiwiZmlsdGVyIiwiZ3JvdXBCeSIsIndhc1R5cGUiLCJncm91cCIsInR5cGUiLCJmb2xkciIsImFjYyIsImZvbGRsIiwiZmluZFVudGlsIiwidW50aWwiLCJmaW5kIiwiZmluZEluZGV4IiwiZmluZExhc3RJbmRleCIsImZsYXR0ZW4iLCJFcnJvciIsImJpbmQiLCJmb3JhbGwiLCJlcXVhbCIsImExIiwiYTIiLCJlcSIsInJldmVyc2UiLCJkaWZmZXJlbmNlIiwibWFwVG9PYmplY3QiLCJTdHJpbmciLCJwdXJlIiwic29ydCIsImNvbXBhcmF0b3IiLCJjb3B5IiwiZ2V0IiwiaGVhZCIsImxhc3QiLCJmcm9tIiwiZmluZE1hcCIsInVuaXF1ZSIsImlzRHVwbGljYXRlZCIsIm5vb3AiLCJub2FyZyIsImNvbXBvc2UiLCJmYSIsImZiIiwiYXJncyIsImNvbXBvc2UxIiwiZmJjIiwiZmFiIiwiYSIsImNvbnN0YW50IiwidmFsdWUiLCJpZGVudGl0eSIsInRyaXBsZUVxdWFscyIsImIiLCJjdXJyeSIsImZuIiwiaW5pdGlhbEFyZ3MiLCJyZXN0QXJncyIsImFsbCIsIm5vdCIsImRpZSIsIm1zZyIsImFwcGx5IiwiY2FsbCIsIm5ldmVyIiwiYWx3YXlzIiwid2Vha2VuIiwicGlwZSIsImFiIiwiYmMiLCJjZCIsImRlIiwiZWYiLCJmZyIsImdoIiwiYyIsImQiLCJlIiwiZyIsIkdsb2JhbCIsIndpbmRvdyIsIkZ1bmN0aW9uIiwiSWRVdGlscyIsIk51bSIsImdlbmVyYXRlIiwicHJlZml4IiwiZGF0ZSIsIkRhdGUiLCJ0aW1lIiwicmFuZG9tIiwiTWF0aCIsInV1aWRWNCIsImN5Y2xlQnkiLCJkZWx0YSIsIm1pbiIsIm1heCIsImNsYW1wIiwiVWludDMyQXJyYXkiLCJrZXlzIiwiT2JqZWN0IiwiaGFzT3duUHJvcGVydHkiLCJvYmoiLCJwcm9wcyIsImsiLCJ0dXBsZU1hcCIsInR1cGxlIiwib2JqQWNjIiwiaW50ZXJuYWxGaWx0ZXIiLCJvblRydWUiLCJvbkZhbHNlIiwiYmlmaWx0ZXIiLCJtYXBUb0FycmF5IiwibmFtZSIsInZhbHVlcyIsImtleSIsImhhcyIsImhhc05vbk51bGxhYmxlS2V5IiwidW5kZWZpbmVkIiwiaXNFbXB0eSIsIm9uTm9uZSIsIm9uU29tZSIsIm1hcHBlciIsImJpbmRlciIsInByZWRpY2F0ZSIsInJlcGxhY2VtZW50IiwidGh1bmsiLCJtZXNzYWdlIiwid29ya2VyIiwiaXMiLCJsaHMiLCJyaHMiLCJsZWZ0IiwiZXF1YWxzIiwibGlmdDIiLCJjYXQiLCJwdXNoIiwic2VxdWVuY2UiLCJ0cmF2ZXJzZSIsIm9hIiwib2IiLCJsaWZ0MyIsIm9jIiwibGlmdDQiLCJvZCIsImxpZnQ1Iiwib2UiLCJtYXBGcm9tIiwiYmluZEZyb20iLCJvb3QiLCJzb21lSWYiLCJwYXRoIiwicGFydHMiLCJzY29wZSIsIm8iLCJyZXNvbHZlIiwicCIsInN0ZXAiLCJwYXJ0IiwiZm9yZ2UiLCJ0YXJnZXQiLCJuYW1lc3BhY2UiLCJTdHJBcHBlbmQiLCJjaGVja1JhbmdlIiwic3RyIiwic3Vic3RyIiwic3RhcnQiLCJzdXBwbGFudCIsImlzU3RyaW5nT3JOdW1iZXIiLCJmdWxsTWF0Y2giLCJyZW1vdmVMZWFkaW5nIiwic3RhcnRzV2l0aCIsInJlbW92ZVRyYWlsaW5nIiwic3VmZml4IiwiZW5kc1dpdGgiLCJlbnN1cmVMZWFkaW5nIiwiZW5zdXJlVHJhaWxpbmciLCJlbmQiLCJpZHgiLCJjYXBpdGFsaXplIiwiYmxhbmsiLCJ0cmltIiwibFRyaW0iLCJyVHJpbSIsImlzTm90RW1wdHkiLCJyZXBlYXQiLCJjb3VudCIsImZyb21Db2RlUG9pbnQiLCJ0b0ludCIsInJhZGl4IiwicGFyc2VJbnQiLCJpc05hTiIsInRvRmxvYXQiLCJwYXJzZUZsb2F0IiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNQcm90byIsInYiLCJjb25zdHJ1Y3RvciIsInR5cGVPZiIsInByb3RvIiwiaXNUeXBlIiwiaXNTaW1wbGVUeXBlIiwiaXNPYmplY3QiLCJpc1N0cmluZyIsImlzUGxhaW5PYmplY3QiLCJpc0FycmF5IiwiaXNOdWxsIiwiaXNCb29sZWFuIiwiaXNVbmRlZmluZWQiLCJpc051bGxhYmxlIiwiaXNOb25OdWxsYWJsZSIsImlzRnVuY3Rpb24iLCJpc051bWJlciIsImlzQXJyYXlPZiIsImlzUHJvbWlzZUxpa2UiLCJhZGRUb1N0YXJ0IiwiYWRkVG9FbmQiLCJyZW1vdmVGcm9tU3RhcnQiLCJudW1DaGFycyIsInJlbW92ZUZyb21FbmQiLCJ1dWlkVjRCeXRlcyIsImJ5dGVzIiwiVWludDhBcnJheSIsInV1aWRWNFN0cmluZyIsInV1aWQiLCJnZXRIZXhSYW5nZSIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsImJ1ZmYiLCJoZXhCeXRlIiwicG9pbnQiLCJvZmZzZXQiLCJkZWx0YU9mZnNldCIsImZpbmlzaCIsInBvaW50cyIsImJlZ2luIiwidGV4dCIsIkRvbVVuaXZlcnNlIiwiRGVzY2VudCIsInVuaXZlcnNlIiwidG9MZWFmIiwiZnJlZWZhbGxMdHIiLCJmcmVlZmFsbFJ0bCIsIk5hdmlnYXRpb24iLCJTcG90IiwidG9MYXN0Iiwibm9kZSIsImNoaWxkcmVuIiwidG9Mb3dlciIsImxhc3RPZmZzZXQiLCJzY2FuIiwiZGlyZWN0aW9uIiwiZWxlbSIsImNhbmRpZGF0ZSIsInRvRW5kIiwiUmVzb2x2ZSIsInNhbmRIVE1MRWxlbWVudCIsImlzUHJvdG90eXBlT2YiLCJ1bnNhZmUiLCJnZXRPckRpZSIsImFjdHVhbCIsInRvQXJyYXkiLCJyZWN1cnNlIiwiY3VyIiwiU2VsZWN0b3JzIiwiZTEiLCJlMiIsImlzRXF1YWxOb2RlIiwibWVtYmVyIiwiZWxlbWVudHMiLCJkMSIsImQyIiwiYmVmb3JlIiwibWFya2VyIiwicGFyZW50IiwiYWZ0ZXIiLCJzaWJsaW5nIiwiYXBwZW5kIiwicHJlcGVuZCIsImZpcnN0Q2hpbGQiLCJhcHBlbmRBdCIsImluZGV4Iiwid3JhcCIsIndyYXBwZXIiLCJlbXB0eSIsInJvZ3VlIiwicmVtb3ZlIiwiZG9tIiwidW53cmFwIiwiQVRUUklCVVRFIiwiQ0RBVEFfU0VDVElPTiIsIkNPTU1FTlQiLCJET0NVTUVOVCIsIkRPQ1VNRU5UX1RZUEUiLCJET0NVTUVOVF9GUkFHTUVOVCIsIkVMRU1FTlQiLCJURVhUIiwiUFJPQ0VTU0lOR19JTlNUUlVDVElPTiIsIkVOVElUWV9SRUZFUkVOQ0UiLCJFTlRJVFkiLCJOT1RBVElPTiIsImdldFNoYWRvd0hvc3QiLCJnZXRTaGFkb3dSb290IiwiaW5Cb2R5IiwiZG9jIiwiYm9keSIsImdldEJvZHkiLCJmcm9tSHRtbCIsImh0bWwiLCJkaXYiLCJjb25zb2xlIiwiZnJvbURvbSIsImZyb21UYWciLCJmcm9tVGV4dCIsImZyb21Qb2ludCIsImRvY0VsbSIsInkiLCJnZXRIZWFkIiwiU2FuZEhUTUxFbGVtZW50IiwiTm9kZVR5cGVzIiwiaXNDb21tZW50IiwiaXNIVE1MRWxlbWVudCIsImlzRWxlbWVudCIsImlzVGV4dCIsImlzRG9jdW1lbnQiLCJpc0RvY3VtZW50RnJhZ21lbnQiLCJpc1RhZyIsIlN1Z2FySGVhZCIsImlzU2hhZG93Um9vdCIsImRvcyIsImdldFJvb3ROb2RlIiwiY3JlYXRlRWxlbWVudCIsImdldFN0eWxlQ29udGFpbmVyIiwiZ2V0Q29udGVudENvbnRhaW5lciIsImlzSW5TaGFkb3dSb290IiwiZ2V0T3JpZ2luYWxFdmVudFRhcmdldCIsImV2ZW50IiwiZWwiLCJpc09wZW5TaGFkb3dIb3N0IiwiY29tcG9zZWRQYXRoIiwiaXNPcGVuU2hhZG93Um9vdCIsInNyIiwiaXNDbG9zZWRTaGFkb3dSb290IiwiTm9kZVZhbHVlIiwiYXBpIiwiZ2V0T3B0aW9uIiwic2V0IiwiT2JqIiwicmF3U2V0Iiwic2V0QWxsIiwiYXR0cnMiLCJzZXRPcHRpb25zIiwiZ2V0T3B0IiwiaGFzTm9uZSIsImF0dHIiLCJ0cmFuc2Zlck9uZSIsInNyY1ZhbHVlIiwidHJhbnNmZXIiLCJPcHRpb25hbHMiLCJTdHJpbmdzIiwiU3R5bGUiLCJTdWdhckJvZHkiLCJpbnRlcm5hbFNldCIsInByb3BlcnR5IiwiaW50ZXJuYWxSZW1vdmUiLCJjc3MiLCJzdHlsZXMiLCJnZXRVbnNhZmVQcm9wZXJ0eSIsImdldFJhdyIsInJhdyIsImdldEFsbFJhdyIsInJ1bGVOYW1lIiwiaXNWYWxpZFZhbHVlIiwic3R5bGUiLCJwcmVzZXJ2ZSIsIm9sZFN0eWxlcyIsInJlc3VsdCIsInNvdXJjZURvbSIsInRhcmdldERvbSIsInJlZmxvdyIsImRlc2NlbmRhbnRzIiwiYW5jZXN0b3JzIiwiaXNSb290Iiwic2libGluZ3MiLCJDbG9zZXN0T3JBbmNlc3RvciIsImZpcnN0IiwiZGVzY2VuZGFudCIsImFuY2VzdG9yIiwic3RvcCIsImNsb3Nlc3QiLCJ0ZXN0IiwiY2hpbGQiLCJkZXNjZW5kIiwicmVzIiwic2VsZWN0b3IiLCJieXBhc3NTZWxlY3RvciIsImJhc2UiLCJvbmUiLCJSZWN1cnNlIiwib3duZXIiLCJkb2N1bWVudE9yT3duZXIiLCJkb2N1bWVudEVsZW1lbnQiLCJkZWZhdWx0VmlldyIsInBhcmVudE5vZGUiLCJwYXJlbnRFbGVtZW50Iiwia2luIiwicGFyZW50cyIsInJldCIsInJhd1BhcmVudCIsImZpbHRlclNlbGYiLCJvZmZzZXRQYXJlbnQiLCJwcmV2U2libGluZyIsIm5leHRTaWJsaW5nIiwicHJldlNpYmxpbmdzIiwibmV4dFNpYmxpbmdzIiwiY3MiLCJsYXN0Q2hpbGQiLCJjaGlsZE5vZGVzQ291bnQiLCJoYXNDaGlsZE5vZGVzIiwic3BvdCIsImxlYWYiLCJpc1N1cHBvcnRlZCIsIlBsdWdpbk1hbmFnZXIiLCJDb21tYW5kcyIsIkZpbHRlckNvbnRlbnQiLCJLZXlib2FyZCIsIlF1aXJrcyIsIkJ1dHRvbnMiLCJlZGl0b3IiLCJBY3Rpb25zIiwicmVnaXN0ZXIiLCJfdWkiLCJmaXJlVG9nZ2xlQWNjb3JkaW9uRXZlbnQiLCJzdGF0ZSIsImZpcmVUb2dnbGVBbGxBY2NvcmRpb25zRXZlbnQiLCJvcHRpb24iLCJpc0Rpc2FibGVkIiwiSWQiLCJEb21EZXNjZW50IiwiRXZlbnRzIiwiT3B0aW9ucyIsIklkZW50aWZpZXJzIiwiVXRpbHMiLCJpbnNlcnRBY2NvcmRpb24iLCJlZGl0b3JCb2R5IiwidWlkIiwic3VtbWFyeVRleHQiLCJib2R5VGV4dCIsImFjY29yZGlvblN1bW1hcnlIdG1sIiwiYWNjb3JkaW9uQm9keUh0bWwiLCJkZXRhaWxzRWxtIiwic3VtbWFyeUVsbSIsInJuZyIsImRlcyIsInRvZ2dsZURldGFpbHNFbGVtZW50IiwiaXNSZWFkb25seSIsImRldGFpbHMiLCJzaG91bGRPcGVuIiwidG9nZ2xlQWNjb3JkaW9uIiwicmVtb3ZlQWNjb3JkaW9uIiwidG9nZ2xlQWxsQWNjb3JkaW9ucyIsImFjY29yZGlvbnMiLCJhY2NvcmRpb24iLCJhY2NvcmRpb25UYWciLCJhY2NvcmRpb25EZXRhaWxzQ2xhc3MiLCJhY2NvcmRpb25TdW1tYXJ5Q2xhc3MiLCJhY2NvcmRpb25Cb2R5V3JhcHBlckNsYXNzIiwiYWNjb3JkaW9uQm9keVdyYXBwZXJUYWciLCJhY2NvcmRpb25SZWFkb25seUNvbXBlbnNhdGlvbkF0dHJpYnV0ZSIsIlZLIiwic2V0dXBFbnRlcktleUluU3VtbWFyeSIsInNldHVwIiwiY21kIiwiRW52Iiwic3VtbWFyeSIsIlRvb2xzIiwiaXNTdW1tYXJ5IiwiaXNEZXRhaWxzIiwiaXNPcGVuIiwiaXNJblN1bW1hcnkiLCJCb29sZWFuIiwiaXNBdERldGFpbHNTdGFydCIsImlzSW5zZXJ0QWxsb3dlZCIsImdldFNlbGVjdGVkRGV0YWlscyIsImlzRGV0YWlsc1NlbGVjdGVkIiwiaW5zZXJ0Qm9ndXMiLCJjcmVhdGVQYXJhZ3JhcGgiLCJjcmVhdGVTdW1tYXJ5IiwiaW5zZXJ0QW5kU2VsZWN0UGFyYWdyYXBoQWZ0ZXIiLCJwYXJhZ3JhcGgiLCJub3JtYWxpemVDb250ZW50Iiwibm9ybWFsaXplU3VtbWFyeSIsIm5vcm1hbGl6ZUFjY29yZGlvbiIsIm5vcm1hbGl6ZURldGFpbHMiLCJBc3ROb2RlIiwiTm9ybWFsaXplIiwiZ2V0Q2xhc3NMaXN0IiwiYWRkQ2xhc3NlcyIsImNsYXNzZXMiLCJjbGFzc0xpc3RTZXQiLCJTZXQiLCJuZXdDbGFzc0xpc3QiLCJyZW1vdmVDbGFzc2VzIiwiY2xhenoiLCJpc0FjY29yZGlvbkRldGFpbHNOb2RlIiwiaXNBY2NvcmRpb25Cb2R5V3JhcHBlck5vZGUiLCJnZXRBY2NvcmRpb25DaGlsZHJlbiIsImFjY29yZGlvbk5vZGUiLCJzdW1tYXJ5Tm9kZSIsIndyYXBwZXJOb2RlIiwib3RoZXJOb2RlcyIsInBhZElucHV0Tm9kZSIsImJyIiwic2VyaWFsaXplciIsInBhcnNlciIsIm5vZGVzIiwiaGFzU3VtbWFyeU5vZGUiLCJuZXdTdW1tYXJ5Tm9kZSIsImhhc1dyYXBwZXJOb2RlIiwibmV3V3JhcHBlck5vZGUiLCJqIiwib3RoZXJOb2RlIiwicE5vZGUiLCJzdW1tYXJ5Q2xhc3NSZW1vdmVTZXQiLCJub3JtYWxpemVPcGVuQXR0cmlidXRlIiwiaGFzQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiYXR0cmlidXRlIiwib25TZXR1cCIsImJ1dHRvbkFwaSIsIm9uTm9kZUNoYW5nZSIsIm9uQWN0aW9uIiwiUGx1Z2luIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUEsNkRBQWUsTUFBTSxFQUFDO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7O0FDSFA7O0FBRUEsNkRBQWUsTUFBTSxFQUFDO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7O0FDSFA7O0FBRUEsNkRBQWUsTUFBTSxFQUFDO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7O0FDSFA7O0FBRUEsNkRBQWUsTUFBTSxFQUFDO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7O0FDSFA7O0FBRUEsNkRBQWUsTUFBTSxFQUFDO0FBQ2Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIOEM7QUFJL0I7QUFFOEI7QUFJcEQsNkRBQWdCO0lBQ2QsTUFBTWtCLFFBQVEsQ0FBQ0M7UUFDYixPQUFPTiw4REFBb0IsQ0FBQ00sUUFBUSxHQUFHLENBQUMsU0FBUyxDQUFDO0lBQ3BEO0lBRUEsTUFBTUMsV0FBVyxDQUFDRCxVQUFnQ0gseURBQXdCLENBQUNHLFNBQVMsR0FBRztJQUV2RixNQUFNRSxhQUFhLENBQUNGO1FBQ2xCLElBQUksQ0FBQ0wsbURBQW1CLENBQUNLLFVBQVU7WUFDakMsT0FBTztRQUNUO1FBQ0EsSUFBSUwsOENBQWMsQ0FBQ0ssYUFBYSxRQUFRO1lBQ3RDLE9BQU87UUFDVDtRQUNBLE9BQU9uQixxREFBWSxDQUFDaUIsNkRBQWFBLEVBQUVILDhDQUFjLENBQUNLO0lBQ3BEO0lBRUEsTUFBTUcsYUFBYSxDQUFDSDtRQUNsQixJ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